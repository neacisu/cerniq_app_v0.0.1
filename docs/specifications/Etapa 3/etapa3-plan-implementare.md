# CERNIQ.APP – ETAPA 3: PLAN IMPLEMENTARE GRANULAR COMPLET

## Faze, Subfaze și Taskuri pentru AI Sales Agent Neuro-Symbolic

### Versiunea 1.0 | 19 Ianuarie 2026

---

**DOCUMENT STATUS:** NORMATIV – Subordonat Master Spec v1.2  
**SCOPE:** Plan complet implementare Etapa 3 AI Agent cu taskuri JSON pentru AI Agents  
**FORMAT:** F3.x.x.Txxx (Fază.Subfază.Task) - continuare de la Etapa 0/1/2  
**PARADIGMA:** Neuro-Symbolic AI (Zero Hallucination)

---

## SUMAR EXECUTIV

Etapa 3 implementează un **Agent Comercial AI Autonom** care navighează ciclul complet de vânzare pentru piața agricolă din România. Sistemul combină flexibilitatea lingvistică a LLM-urilor cu rigoarea verificabilă a componentelor simbolice (Guardrails), eliminând complet riscul de halucinații în prețuri, stocuri, discounturi și documente fiscale.

### Metrici Cheie

| Metric | Target | Justificare |
| ------ | ------ | ----------- |
| Workers Totali | 78 (53 core + 25 adiționali) | Acoperire completă flux vânzare |
| Categorii | 14 (A-N) | Separare responsabilități clare |
| Timp Implementare | 12 săptămâni | Livrare incrementală |
| Faze | 15 | De la F3.1 la F3.15 |
| Taskuri | ~210 | Granularitate detaliată |
| Coverage Test | 80%+ | Zero regresii |
| Hallucination Rate | 0% | Guardrails validate toate outputs |

---

## CUPRINS FAZE

| Fază | Denumire | Nr. Taskuri | Săptămâna |
| ---- | -------- | ----------- | --------- |
| F3.1 | Database Schema & Migrations | 15 | S1-S2 |
| F3.2 | Product Knowledge Workers (A) | 12 | S2-S3 |
| F3.3 | Hybrid Search RAG Workers (B) | 10 | S3-S4 |
| F3.4 | AI Agent Core Workers (C) | 14 | S4-S5 |
| F3.5 | Negotiation FSM Workers (D) | 16 | S5-S6 |
| F3.6 | Pricing & Discount Workers (E) | 12 | S6-S7 |
| F3.7 | Stock & Inventory Workers (F) | 10 | S7 |
| F3.8 | Oblio Integration Workers (G) | 14 | S7-S8 |
| F3.9 | e-Factura SPV Workers (H) | 12 | S8-S9 |
| F3.10 | Document Generation Workers (I) | 10 | S9 |
| F3.11 | Handover & Channel Workers (J) | 10 | S9-S10 |
| F3.12 | Sentiment & Intent Workers (K) | 10 | S10 |
| F3.13 | MCP Server Workers (L) | 12 | S10-S11 |
| F3.14 | Guardrails Workers (M) | 15 | S11 |
| F3.15 | Human Intervention & HITL (N) | 12 | S11-S12 |
| F3.16 | Frontend UI/UX | 20 | S1-S12 |
| F3.17 | Testing & QA | 12 | S10-S12 |
| F3.18 | Integration & Deployment | 8 | S12 |
| **TOTAL** | | **~214 Taskuri** | **12 Săptămâni** |

---

## DEPENDENȚE CRITICE

### De la Etape Anterioare

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                      DEPENDENȚE ETAPA 3                                 │
│                                                                         │
│  ETAPA 0 (Infrastructură)                                               │
│  ├── Docker + PostgreSQL 18.1 + Redis 8.4 ✓                             │
│  ├── Traefik SSL/TLS ✓                                                  │
│  ├── SigNoz Observability ✓                                             │
│  └── Monorepo PNPM ✓                                                    │
│                                                                         │
│  ETAPA 1 (Data Enrichment)                                              │
│  ├── Schema bronze/silver/gold ✓                                        │
│  ├── Contacte validate ✓                                                │
│  └── HITL base system ✓                                                 │
│                                                                         │
│  ETAPA 2 (Cold Outreach)                                                │
│  ├── Campanii outreach ✓                                                │
│  ├── Template engine ✓                                                  │
│  └── Channel management (Email/WhatsApp) ✓                              │
│                                                                         │
│  ETAPA 3 (AI Agent) - CURRENT                                           │
│  ├── Negotiation FSM                                                    │
│  ├── Product Knowledge Base                                             │
│  ├── Guardrails neuro-simbolice                                         │
│  ├── Fiscal Integration (Oblio + e-Factura)                             │
│  └── Human-in-the-Loop advanced                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

# FAZA F3.1: DATABASE SCHEMA & MIGRATIONS

## F3.1.1 Schema Negotiations

```json
{
  "taskID": "F3.1.1.T001",
  "denumire_task": "Creare schema și tabel negotiations pentru FSM",
  "context_anterior": "Etapa 3 necesită persistența negocierilor cu state machine complet. Schema existentă include contacte (gold tier) și campanii din Etapa 2. Negocierile conectează contacte la produse cu tracking complet al stărilor.",
  "descriere_task": "Ești un expert DBA PostgreSQL cu experiență în design schema pentru aplicații B2B. Task-ul tău este să creezi tabelul principal negotiations cu toate coloanele necesare pentru Negotiation FSM.\n\nCreează migration Drizzle în /packages/db/src/migrations/etapa3/001_negotiations_table.ts:\n\n```typescript\nimport { pgTable, uuid, text, timestamp, jsonb, decimal, integer, index } from 'drizzle-orm/pg-core';\nimport { createId } from '@paralleldrive/cuid2';\n\nexport const negotiations = pgTable('negotiations', {\n  // Primary Key\n  id: uuid('id').primaryKey().defaultRandom(),\n  \n  // Tenant Isolation\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  \n  // Relations\n  contactId: uuid('contact_id').notNull().references(() => contactsGold.id),\n  assignedUserId: uuid('assigned_user_id').references(() => users.id),\n  \n  // FSM State\n  currentState: text('current_state').notNull().default('INITIAL_CONTACT'),\n  previousState: text('previous_state'),\n  stateHistory: jsonb('state_history').notNull().default('[]'),\n  stateEnteredAt: timestamp('state_entered_at', { withTimezone: true }).notNull().defaultNow(),\n  \n  // Conversation\n  conversationId: uuid('conversation_id').unique(),\n  channelType: text('channel_type').notNull(), // 'whatsapp', 'email', 'web_chat'\n  channelId: text('channel_id'), // External channel reference\n  \n  // Products & Pricing\n  products: jsonb('products').notNull().default('[]'),\n  totalValue: decimal('total_value', { precision: 15, scale: 2 }),\n  currency: text('currency').notNull().default('RON'),\n  discountPercent: decimal('discount_percent', { precision: 5, scale: 2 }),\n  discountReason: text('discount_reason'),\n  \n  // AI Agent\n  aiEnabled: boolean('ai_enabled').notNull().default(true),\n  aiModel: text('ai_model').default('grok-4'),\n  lastAiResponseAt: timestamp('last_ai_response_at', { withTimezone: true }),\n  aiMessageCount: integer('ai_message_count').notNull().default(0),\n  aiTokensUsed: integer('ai_tokens_used').notNull().default(0),\n  aiCostEstimate: decimal('ai_cost_estimate', { precision: 10, scale: 4 }),\n  \n  // HITL\n  requiresHumanReview: boolean('requires_human_review').notNull().default(false),\n  hitlReason: text('hitl_reason'),\n  hitlEscalatedAt: timestamp('hitl_escalated_at', { withTimezone: true }),\n  hitlResolvedAt: timestamp('hitl_resolved_at', { withTimezone: true }),\n  hitlResolvedBy: uuid('hitl_resolved_by').references(() => users.id),\n  \n  // Outcome\n  outcome: text('outcome'), // 'won', 'lost', 'abandoned', 'transferred'\n  outcomeReason: text('outcome_reason'),\n  closedAt: timestamp('closed_at', { withTimezone: true }),\n  \n  // Metadata\n  priority: text('priority').notNull().default('normal'), // 'low', 'normal', 'high', 'urgent'\n  tags: jsonb('tags').notNull().default('[]'),\n  customFields: jsonb('custom_fields').notNull().default('{}'),\n  \n  // Audit\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),\n  createdBy: uuid('created_by').references(() => users.id),\n  version: integer('version').notNull().default(1)\n}, (table) => ({\n  // Indexes\n  tenantIdx: index('negotiations_tenant_idx').on(table.tenantId),\n  contactIdx: index('negotiations_contact_idx').on(table.contactId),\n  stateIdx: index('negotiations_state_idx').on(table.currentState),\n  tenantStateIdx: index('negotiations_tenant_state_idx').on(table.tenantId, table.currentState),\n  outcomeIdx: index('negotiations_outcome_idx').on(table.outcome),\n  createdAtIdx: index('negotiations_created_at_idx').on(table.createdAt),\n  hitlPendingIdx: index('negotiations_hitl_pending_idx').on(table.requiresHumanReview).where(eq(table.requiresHumanReview, true))\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "NU omite tenantId - TOATE tabelele TREBUIE să fie multi-tenant",
    "NU folosi auto-increment pentru id - foloseşte UUID",
    "INCLUDE state_history ca JSONB - necesar pentru audit trail",
    "NU omite indexul compus tenant_state - este critic pentru performanță",
    "ASIGURĂ-TE că stateHistory este array JSON valid, nu string",
    "INCLUDE version pentru optimistic locking"
  ],
  "validare_task": "1. Migration-ul compilează fără erori TypeScript\n2. Toate coloanele au tipuri corecte\n3. Foreign keys sunt definite corect\n4. Indexurile includ tenant_id pentru toate queries frecvente\n5. Constraint-ul UNIQUE pe conversationId este prezent\n6. Default-urile sunt setate pentru toate coloanele obligatorii",
  "outcome": "Tabelul negotiations creat cu schema completă pentru Negotiation FSM, indexuri optimizate și audit trail"
}
```

```json
{
  "taskID": "F3.1.1.T002",
  "denumire_task": "Creare enum-uri și constante pentru Negotiation States",
  "context_anterior": "Tabelul negotiations creat în F3.1.1.T001 folosește text pentru currentState. Acum trebuie definite toate stările valide ale FSM-ului.",
  "descriere_task": "Ești un expert în State Machine design. Task-ul tău este să creezi definițiile TypeScript pentru toate stările și tranzițiile Negotiation FSM.\n\nCreează fișierul /packages/shared/src/constants/negotiation-states.ts:\n\n```typescript\n/**\n * Negotiation FSM States\n * Definește toate stările posibile ale unei negocieri\n */\nexport const NEGOTIATION_STATES = {\n  // Initial States\n  INITIAL_CONTACT: 'INITIAL_CONTACT',\n  QUALIFICATION: 'QUALIFICATION',\n  \n  // Discovery States\n  NEEDS_DISCOVERY: 'NEEDS_DISCOVERY',\n  PRODUCT_PRESENTATION: 'PRODUCT_PRESENTATION',\n  \n  // Negotiation States\n  PRICE_NEGOTIATION: 'PRICE_NEGOTIATION',\n  DISCOUNT_REVIEW: 'DISCOUNT_REVIEW',\n  TERMS_DISCUSSION: 'TERMS_DISCUSSION',\n  \n  // Decision States\n  PROPOSAL_SENT: 'PROPOSAL_SENT',\n  AWAITING_DECISION: 'AWAITING_DECISION',\n  OBJECTION_HANDLING: 'OBJECTION_HANDLING',\n  \n  // Approval States\n  PENDING_APPROVAL: 'PENDING_APPROVAL',\n  MANAGER_REVIEW: 'MANAGER_REVIEW',\n  \n  // Closing States\n  VERBAL_AGREEMENT: 'VERBAL_AGREEMENT',\n  CONTRACT_SENT: 'CONTRACT_SENT',\n  CONTRACT_SIGNED: 'CONTRACT_SIGNED',\n  \n  // Fiscal States\n  PROFORMA_GENERATED: 'PROFORMA_GENERATED',\n  INVOICE_GENERATED: 'INVOICE_GENERATED',\n  EFACTURA_SUBMITTED: 'EFACTURA_SUBMITTED',\n  PAYMENT_PENDING: 'PAYMENT_PENDING',\n  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',\n  \n  // Terminal States\n  WON: 'WON',\n  LOST: 'LOST',\n  ABANDONED: 'ABANDONED',\n  TRANSFERRED: 'TRANSFERRED',\n  \n  // Special States\n  ON_HOLD: 'ON_HOLD',\n  REQUIRES_HUMAN: 'REQUIRES_HUMAN'\n} as const;\n\nexport type NegotiationState = typeof NEGOTIATION_STATES[keyof typeof NEGOTIATION_STATES];\n\n/**\n * Tranziții valide FSM\n * Definește toate tranzițiile permise între stări\n */\nexport const NEGOTIATION_TRANSITIONS: Record<NegotiationState, NegotiationState[]> = {\n  [NEGOTIATION_STATES.INITIAL_CONTACT]: [\n    NEGOTIATION_STATES.QUALIFICATION,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.QUALIFICATION]: [\n    NEGOTIATION_STATES.NEEDS_DISCOVERY,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.NEEDS_DISCOVERY]: [\n    NEGOTIATION_STATES.PRODUCT_PRESENTATION,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.PRODUCT_PRESENTATION]: [\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.PRICE_NEGOTIATION]: [\n    NEGOTIATION_STATES.DISCOUNT_REVIEW,\n    NEGOTIATION_STATES.TERMS_DISCUSSION,\n    NEGOTIATION_STATES.PROPOSAL_SENT,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.DISCOUNT_REVIEW]: [\n    NEGOTIATION_STATES.PENDING_APPROVAL,\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.PROPOSAL_SENT\n  ],\n  [NEGOTIATION_STATES.TERMS_DISCUSSION]: [\n    NEGOTIATION_STATES.PROPOSAL_SENT,\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.LOST\n  ],\n  [NEGOTIATION_STATES.PROPOSAL_SENT]: [\n    NEGOTIATION_STATES.AWAITING_DECISION,\n    NEGOTIATION_STATES.OBJECTION_HANDLING,\n    NEGOTIATION_STATES.LOST\n  ],\n  [NEGOTIATION_STATES.AWAITING_DECISION]: [\n    NEGOTIATION_STATES.VERBAL_AGREEMENT,\n    NEGOTIATION_STATES.OBJECTION_HANDLING,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.OBJECTION_HANDLING]: [\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.PROPOSAL_SENT,\n    NEGOTIATION_STATES.LOST\n  ],\n  [NEGOTIATION_STATES.PENDING_APPROVAL]: [\n    NEGOTIATION_STATES.MANAGER_REVIEW,\n    NEGOTIATION_STATES.PRICE_NEGOTIATION\n  ],\n  [NEGOTIATION_STATES.MANAGER_REVIEW]: [\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.PROPOSAL_SENT,\n    NEGOTIATION_STATES.LOST\n  ],\n  [NEGOTIATION_STATES.VERBAL_AGREEMENT]: [\n    NEGOTIATION_STATES.CONTRACT_SENT,\n    NEGOTIATION_STATES.PROFORMA_GENERATED,\n    NEGOTIATION_STATES.LOST\n  ],\n  [NEGOTIATION_STATES.CONTRACT_SENT]: [\n    NEGOTIATION_STATES.CONTRACT_SIGNED,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.CONTRACT_SIGNED]: [\n    NEGOTIATION_STATES.PROFORMA_GENERATED,\n    NEGOTIATION_STATES.INVOICE_GENERATED\n  ],\n  [NEGOTIATION_STATES.PROFORMA_GENERATED]: [\n    NEGOTIATION_STATES.INVOICE_GENERATED,\n    NEGOTIATION_STATES.LOST\n  ],\n  [NEGOTIATION_STATES.INVOICE_GENERATED]: [\n    NEGOTIATION_STATES.EFACTURA_SUBMITTED,\n    NEGOTIATION_STATES.PAYMENT_PENDING\n  ],\n  [NEGOTIATION_STATES.EFACTURA_SUBMITTED]: [\n    NEGOTIATION_STATES.PAYMENT_PENDING\n  ],\n  [NEGOTIATION_STATES.PAYMENT_PENDING]: [\n    NEGOTIATION_STATES.PAYMENT_RECEIVED,\n    NEGOTIATION_STATES.WON\n  ],\n  [NEGOTIATION_STATES.PAYMENT_RECEIVED]: [\n    NEGOTIATION_STATES.WON\n  ],\n  // Terminal states - no transitions out\n  [NEGOTIATION_STATES.WON]: [],\n  [NEGOTIATION_STATES.LOST]: [],\n  [NEGOTIATION_STATES.ABANDONED]: [],\n  [NEGOTIATION_STATES.TRANSFERRED]: [],\n  // Special states\n  [NEGOTIATION_STATES.ON_HOLD]: [\n    NEGOTIATION_STATES.INITIAL_CONTACT,\n    NEGOTIATION_STATES.QUALIFICATION,\n    NEGOTIATION_STATES.NEEDS_DISCOVERY,\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED\n  ],\n  [NEGOTIATION_STATES.REQUIRES_HUMAN]: [\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.PROPOSAL_SENT,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.TRANSFERRED\n  ]\n};\n\n/**\n * State Groups pentru raportare și filtrare\n */\nexport const STATE_GROUPS = {\n  ACTIVE: [\n    NEGOTIATION_STATES.INITIAL_CONTACT,\n    NEGOTIATION_STATES.QUALIFICATION,\n    NEGOTIATION_STATES.NEEDS_DISCOVERY,\n    NEGOTIATION_STATES.PRODUCT_PRESENTATION,\n    NEGOTIATION_STATES.PRICE_NEGOTIATION,\n    NEGOTIATION_STATES.DISCOUNT_REVIEW,\n    NEGOTIATION_STATES.TERMS_DISCUSSION,\n    NEGOTIATION_STATES.PROPOSAL_SENT,\n    NEGOTIATION_STATES.AWAITING_DECISION,\n    NEGOTIATION_STATES.OBJECTION_HANDLING,\n    NEGOTIATION_STATES.PENDING_APPROVAL,\n    NEGOTIATION_STATES.MANAGER_REVIEW,\n    NEGOTIATION_STATES.VERBAL_AGREEMENT,\n    NEGOTIATION_STATES.CONTRACT_SENT\n  ],\n  CLOSING: [\n    NEGOTIATION_STATES.CONTRACT_SIGNED,\n    NEGOTIATION_STATES.PROFORMA_GENERATED,\n    NEGOTIATION_STATES.INVOICE_GENERATED,\n    NEGOTIATION_STATES.EFACTURA_SUBMITTED,\n    NEGOTIATION_STATES.PAYMENT_PENDING,\n    NEGOTIATION_STATES.PAYMENT_RECEIVED\n  ],\n  TERMINAL: [\n    NEGOTIATION_STATES.WON,\n    NEGOTIATION_STATES.LOST,\n    NEGOTIATION_STATES.ABANDONED,\n    NEGOTIATION_STATES.TRANSFERRED\n  ],\n  REQUIRES_ATTENTION: [\n    NEGOTIATION_STATES.PENDING_APPROVAL,\n    NEGOTIATION_STATES.MANAGER_REVIEW,\n    NEGOTIATION_STATES.REQUIRES_HUMAN,\n    NEGOTIATION_STATES.ON_HOLD\n  ]\n} as const;\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/shared/src/constants",
  "restrictii_antihalucinatie": [
    "NU omite stările fiscale - sunt CRITICE pentru compliance e-Factura",
    "NU permite tranziții circulare infinite - fiecare cale trebuie să ajungă la terminal",
    "INCLUDE REQUIRES_HUMAN pentru escalare HITL",
    "ASIGURĂ-TE că toate stările au tranziții definite (chiar și array gol pentru terminale)",
    "NU hardcoda stările în alte fișiere - importă ÎNTOTDEAUNA din acest modul"
  ],
  "validare_task": "1. Toate cele 28 de stări sunt definite\n2. NEGOTIATION_TRANSITIONS include toate stările ca chei\n3. Stările terminale au array gol pentru tranziții\n4. STATE_GROUPS acoperă toate stările\n5. TypeScript compiles fără erori\n6. Export-urile sunt corecte (const și type)",
  "outcome": "Definițiile complete FSM cu stări, tranziții și grupuri pentru Negotiation State Machine"
}
```

```json
{
  "taskID": "F3.1.1.T003",
  "denumire_task": "Creare tabel negotiation_messages pentru conversații",
  "context_anterior": "Tabelul negotiations și enum-urile FSM create în T001 și T002. Acum trebuie să persistăm toate mesajele din conversații pentru audit și training AI.",
  "descriere_task": "Ești un expert DBA cu experiență în sisteme conversaționale. Task-ul tău este să creezi tabelul pentru stocarea mesajelor negocierilor.\n\nCreează migration în /packages/db/src/migrations/etapa3/002_negotiation_messages.ts:\n\n```typescript\nimport { pgTable, uuid, text, timestamp, jsonb, integer, boolean, index } from 'drizzle-orm/pg-core';\n\nexport const negotiationMessages = pgTable('negotiation_messages', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  negotiationId: uuid('negotiation_id').notNull().references(() => negotiations.id, { onDelete: 'cascade' }),\n  \n  // Message Content\n  role: text('role').notNull(), // 'user', 'assistant', 'system', 'tool'\n  content: text('content').notNull(),\n  contentType: text('content_type').notNull().default('text'), // 'text', 'image', 'document', 'audio'\n  \n  // AI Context\n  modelUsed: text('model_used'), // 'grok-4', 'claude-3.5-sonnet', etc.\n  promptTokens: integer('prompt_tokens'),\n  completionTokens: integer('completion_tokens'),\n  totalTokens: integer('total_tokens'),\n  costEstimate: decimal('cost_estimate', { precision: 10, scale: 6 }),\n  latencyMs: integer('latency_ms'),\n  \n  // Tool Calls\n  toolCalls: jsonb('tool_calls'), // Array of tool calls made\n  toolResults: jsonb('tool_results'), // Results from tool calls\n  \n  // Guardrails\n  guardrailChecks: jsonb('guardrail_checks'), // Array of guardrail results\n  guardrailPassed: boolean('guardrail_passed'),\n  guardrailFailures: jsonb('guardrail_failures'),\n  regenerationCount: integer('regeneration_count').default(0),\n  \n  // Sentiment & Intent\n  detectedIntent: text('detected_intent'),\n  sentimentScore: decimal('sentiment_score', { precision: 4, scale: 3 }), // -1.0 to 1.0\n  sentimentLabel: text('sentiment_label'), // 'positive', 'neutral', 'negative'\n  urgencyLevel: text('urgency_level'), // 'low', 'medium', 'high', 'critical'\n  \n  // Channel\n  channelMessageId: text('channel_message_id'), // External message ID\n  channelType: text('channel_type').notNull(),\n  deliveryStatus: text('delivery_status'), // 'pending', 'sent', 'delivered', 'read', 'failed'\n  deliveredAt: timestamp('delivered_at', { withTimezone: true }),\n  readAt: timestamp('read_at', { withTimezone: true }),\n  \n  // References\n  replyToMessageId: uuid('reply_to_message_id').references(() => negotiationMessages.id),\n  attachments: jsonb('attachments').default('[]'),\n  \n  // Metadata\n  metadata: jsonb('metadata').default('{}'),\n  isEdited: boolean('is_edited').default(false),\n  editedAt: timestamp('edited_at', { withTimezone: true }),\n  isDeleted: boolean('is_deleted').default(false),\n  deletedAt: timestamp('deleted_at', { withTimezone: true }),\n  \n  // Audit\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n  createdBy: uuid('created_by').references(() => users.id)\n}, (table) => ({\n  negotiationIdx: index('neg_messages_negotiation_idx').on(table.negotiationId),\n  tenantNegotiationIdx: index('neg_messages_tenant_neg_idx').on(table.tenantId, table.negotiationId),\n  roleIdx: index('neg_messages_role_idx').on(table.role),\n  createdAtIdx: index('neg_messages_created_at_idx').on(table.createdAt),\n  sentimentIdx: index('neg_messages_sentiment_idx').on(table.sentimentLabel),\n  guardrailFailedIdx: index('neg_messages_guardrail_failed_idx').on(table.guardrailPassed).where(eq(table.guardrailPassed, false))\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "NU omite guardrail_checks - ESENȚIAL pentru audit anti-halucinație",
    "INCLUDE tool_calls și tool_results pentru MCP debugging",
    "NU folosi TEXT pentru content dacă este foarte lung - consider BYTEA pentru attachments",
    "ASIGURĂ-TE că onDelete: cascade este setat pentru negotiation_id",
    "INCLUDE sentiment tracking pentru analytics"
  ],
  "validare_task": "1. Tabelul are toate coloanele specificate\n2. Foreign key cu cascade delete pentru negotiationId\n3. Indexuri pentru queries frecvente\n4. JSONB pentru tool_calls, guardrail_checks, attachments\n5. Coloane pentru sentiment analysis",
  "outcome": "Tabelul negotiation_messages creat pentru stocarea completă a conversațiilor cu metadata AI"
}
```

```json
{
  "taskID": "F3.1.1.T004",
  "denumire_task": "Creare tabel negotiation_state_transitions pentru audit FSM",
  "context_anterior": "Tabelele negotiations și negotiation_messages create. Acum trebuie să persistăm fiecare tranziție de stare pentru audit și analytics.",
  "descriere_task": "Ești un expert în audit trail design. Task-ul tău este să creezi tabelul pentru logarea tuturor tranzițiilor FSM.\n\nCreează migration în /packages/db/src/migrations/etapa3/003_state_transitions.ts:\n\n```typescript\nexport const negotiationStateTransitions = pgTable('negotiation_state_transitions', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  negotiationId: uuid('negotiation_id').notNull().references(() => negotiations.id, { onDelete: 'cascade' }),\n  \n  // Transition Details\n  fromState: text('from_state').notNull(),\n  toState: text('to_state').notNull(),\n  transitionReason: text('transition_reason'),\n  transitionType: text('transition_type').notNull(), // 'automatic', 'manual', 'ai_suggested', 'escalation'\n  \n  // Trigger\n  triggeredBy: text('triggered_by').notNull(), // 'ai_agent', 'user', 'system', 'cron', 'human'\n  triggeredByUserId: uuid('triggered_by_user_id').references(() => users.id),\n  triggerMessageId: uuid('trigger_message_id').references(() => negotiationMessages.id),\n  \n  // Context\n  contextSnapshot: jsonb('context_snapshot'), // State at transition time\n  aiConfidence: decimal('ai_confidence', { precision: 4, scale: 3 }), // 0.0 to 1.0\n  aiReasoning: text('ai_reasoning'),\n  \n  // Validation\n  validationPassed: boolean('validation_passed').notNull().default(true),\n  validationErrors: jsonb('validation_errors'),\n  \n  // Timing\n  durationInPreviousStateMs: integer('duration_in_previous_state_ms'),\n  transitionedAt: timestamp('transitioned_at', { withTimezone: true }).notNull().defaultNow(),\n  \n  // Metadata\n  metadata: jsonb('metadata').default('{}')\n}, (table) => ({\n  negotiationIdx: index('state_trans_negotiation_idx').on(table.negotiationId),\n  fromStateIdx: index('state_trans_from_state_idx').on(table.fromState),\n  toStateIdx: index('state_trans_to_state_idx').on(table.toState),\n  transitionedAtIdx: index('state_trans_at_idx').on(table.transitionedAt),\n  tenantTimeIdx: index('state_trans_tenant_time_idx').on(table.tenantId, table.transitionedAt)\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "INCLUDE ai_confidence și ai_reasoning pentru explainability",
    "NU permite tranziții fără fromState și toState",
    "INCLUDE context_snapshot pentru debugging",
    "ASIGURĂ-TE că toate tranzițiile sunt logate, inclusiv cele failed"
  ],
  "validare_task": "1. Tabelul captează toate tranzițiile\n2. ai_confidence este decimal între 0 și 1\n3. contextSnapshot este JSONB pentru flexibilitate\n4. Indexuri pentru analytics pe stări",
  "outcome": "Tabelul state_transitions creat pentru audit complet FSM cu AI explainability"
}
```

## F3.1.2 Schema Products

```json
{
  "taskID": "F3.1.2.T001",
  "denumire_task": "Creare tabel products pentru catalogul de produse agricole",
  "context_anterior": "Schema negotiations completă. Acum trebuie să creăm catalogul de produse agricole care va fi interogat de AI Agent.",
  "descriere_task": "Ești un expert în e-commerce database design cu experiență în produse agricole. Task-ul tău este să creezi tabelul products optimizat pentru RAG și search.\n\nCreează migration în /packages/db/src/migrations/etapa3/004_products.ts:\n\n```typescript\nexport const products = pgTable('products', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  \n  // Identification\n  sku: text('sku').notNull(),\n  ean: text('ean'), // Barcode\n  internalCode: text('internal_code'),\n  \n  // Basic Info\n  name: text('name').notNull(),\n  nameRo: text('name_ro'), // Romanian name\n  description: text('description'),\n  descriptionRo: text('description_ro'),\n  shortDescription: text('short_description'),\n  \n  // Categorization\n  categoryId: uuid('category_id').references(() => productCategories.id),\n  subcategoryId: uuid('subcategory_id').references(() => productSubcategories.id),\n  brand: text('brand'),\n  manufacturer: text('manufacturer'),\n  \n  // Pricing\n  basePrice: decimal('base_price', { precision: 15, scale: 2 }).notNull(),\n  currency: text('currency').notNull().default('RON'),\n  vatRate: decimal('vat_rate', { precision: 5, scale: 2 }).notNull().default('19.00'),\n  priceWithVat: decimal('price_with_vat', { precision: 15, scale: 2 }),\n  minPrice: decimal('min_price', { precision: 15, scale: 2 }), // Minimum allowed (after max discount)\n  costPrice: decimal('cost_price', { precision: 15, scale: 2 }), // For margin calculation\n  \n  // Discounts\n  maxDiscountPercent: decimal('max_discount_percent', { precision: 5, scale: 2 }).default('0'),\n  volumeDiscounts: jsonb('volume_discounts').default('[]'), // [{minQty: 10, discount: 5}, ...]\n  \n  // Units\n  unitOfMeasure: text('unit_of_measure').notNull().default('BUC'), // BUC, KG, L, M, etc.\n  minOrderQuantity: decimal('min_order_quantity', { precision: 10, scale: 2 }).default('1'),\n  maxOrderQuantity: decimal('max_order_quantity', { precision: 10, scale: 2 }),\n  quantityStep: decimal('quantity_step', { precision: 10, scale: 2 }).default('1'),\n  \n  // Stock\n  currentStock: decimal('current_stock', { precision: 15, scale: 2 }).default('0'),\n  reservedStock: decimal('reserved_stock', { precision: 15, scale: 2 }).default('0'),\n  availableStock: decimal('available_stock', { precision: 15, scale: 2 }), // computed\n  stockLocation: text('stock_location'),\n  reorderLevel: decimal('reorder_level', { precision: 15, scale: 2 }),\n  reorderQuantity: decimal('reorder_quantity', { precision: 15, scale: 2 }),\n  \n  // Agricultural Specific\n  cropType: text('crop_type'), // 'cereale', 'legume', 'fructe', etc.\n  applicationMethod: text('application_method'),\n  applicationTiming: text('application_timing'),\n  compatibleCrops: jsonb('compatible_crops').default('[]'),\n  activeIngredients: jsonb('active_ingredients').default('[]'),\n  dosageInfo: jsonb('dosage_info'),\n  safetyInfo: text('safety_info'),\n  certifications: jsonb('certifications').default('[]'), // ['bio', 'eco', etc.]\n  \n  // Media\n  images: jsonb('images').default('[]'),\n  documents: jsonb('documents').default('[]'),\n  videos: jsonb('videos').default('[]'),\n  \n  // AI/RAG\n  embedding: vector('embedding', { dimensions: 1536 }), // For semantic search\n  searchKeywords: text('search_keywords'), // Denormalized for FTS\n  aiSummary: text('ai_summary'), // AI-generated product summary\n  \n  // Status\n  status: text('status').notNull().default('active'), // 'active', 'inactive', 'discontinued', 'out_of_stock'\n  isVisible: boolean('is_visible').notNull().default(true),\n  isFeatured: boolean('is_featured').notNull().default(false),\n  \n  // E-commerce\n  weight: decimal('weight', { precision: 10, scale: 3 }), // in kg\n  dimensions: jsonb('dimensions'), // {length, width, height}\n  shippingClass: text('shipping_class'),\n  \n  // Metadata\n  tags: jsonb('tags').default('[]'),\n  customAttributes: jsonb('custom_attributes').default('{}'),\n  \n  // Audit\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),\n  createdBy: uuid('created_by').references(() => users.id),\n  version: integer('version').notNull().default(1)\n}, (table) => ({\n  tenantIdx: index('products_tenant_idx').on(table.tenantId),\n  skuIdx: index('products_sku_idx').on(table.tenantId, table.sku),\n  categoryIdx: index('products_category_idx').on(table.categoryId),\n  statusIdx: index('products_status_idx').on(table.status),\n  embeddingIdx: index('products_embedding_idx').using('hnsw', table.embedding.op('vector_cosine_ops')),\n  searchIdx: index('products_search_idx').using('gin', sql`to_tsvector('romanian', coalesce(${table.name}, '') || ' ' || coalesce(${table.nameRo}, '') || ' ' || coalesce(${table.description}, '') || ' ' || coalesce(${table.searchKeywords}, ''))`),\n  uniqueSkuTenant: unique('products_sku_tenant_unique').on(table.tenantId, table.sku)\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "NU omite embedding pentru vector search - CRITIC pentru RAG",
    "INCLUDE minPrice pentru validare discount (guardrail)",
    "NU permite SKU duplicat per tenant - constraint UNIQUE",
    "INCLUDE agricultural-specific fields pentru domain relevance",
    "FOLOSEȘTE HNSW index pentru embedding, NU IVFFlat"
  ],
  "validare_task": "1. Vector embedding column cu 1536 dimensiuni\n2. HNSW index creat pentru cosine similarity\n3. GIN index pentru full-text search în română\n4. Unique constraint pe (tenant_id, sku)\n5. Câmpuri agricole specifice prezente",
  "outcome": "Tabelul products creat cu suport complet pentru RAG semantic search și validare prețuri"
}
```

```json
{
  "taskID": "F3.1.2.T002",
  "denumire_task": "Creare tabel product_categories cu ierarhie",
  "context_anterior": "Tabelul products creeat referențiază product_categories. Trebuie să creăm structura ierarhică pentru categorii.",
  "descriere_task": "Ești un expert în hierarchical data structures în PostgreSQL. Task-ul tău este să creezi tabelul de categorii cu suport pentru ierarhii nelimitate.\n\nCreează migration în /packages/db/src/migrations/etapa3/005_product_categories.ts:\n\n```typescript\nexport const productCategories = pgTable('product_categories', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  \n  // Hierarchy\n  parentId: uuid('parent_id').references(() => productCategories.id),\n  path: text('path').notNull(), // Materialized path: 'root.category.subcategory'\n  level: integer('level').notNull().default(0),\n  \n  // Info\n  name: text('name').notNull(),\n  nameRo: text('name_ro'),\n  slug: text('slug').notNull(),\n  description: text('description'),\n  \n  // Display\n  icon: text('icon'),\n  image: text('image'),\n  color: text('color'),\n  sortOrder: integer('sort_order').notNull().default(0),\n  \n  // AI\n  embedding: vector('embedding', { dimensions: 1536 }),\n  aiDescription: text('ai_description'),\n  \n  // Status\n  isActive: boolean('is_active').notNull().default(true),\n  productCount: integer('product_count').notNull().default(0),\n  \n  // Metadata\n  metadata: jsonb('metadata').default('{}'),\n  \n  // Audit\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow()\n}, (table) => ({\n  tenantIdx: index('prod_cat_tenant_idx').on(table.tenantId),\n  parentIdx: index('prod_cat_parent_idx').on(table.parentId),\n  pathIdx: index('prod_cat_path_idx').on(table.path),\n  slugIdx: index('prod_cat_slug_idx').on(table.tenantId, table.slug),\n  uniqueSlugTenant: unique('prod_cat_slug_tenant_unique').on(table.tenantId, table.slug)\n}));\n```\n\nCreează și funcția pentru actualizarea path-ului:\n\n```sql\n-- Function to update category path\nCREATE OR REPLACE FUNCTION update_category_path()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.parent_id IS NULL THEN\n    NEW.path := NEW.slug;\n    NEW.level := 0;\n  ELSE\n    SELECT path || '.' || NEW.slug, level + 1\n    INTO NEW.path, NEW.level\n    FROM product_categories\n    WHERE id = NEW.parent_id;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER category_path_trigger\n  BEFORE INSERT OR UPDATE OF parent_id, slug\n  ON product_categories\n  FOR EACH ROW\n  EXECUTE FUNCTION update_category_path();\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE materialized path pentru queries rapide pe ierarhie",
    "NU implementa closure table - este overkill pentru acest use case",
    "INCLUDE embedding pentru category-level semantic search",
    "TRIGGER pentru path update TREBUIE să fie idempotent"
  ],
  "validare_task": "1. Tabelul suportă ierarhie nelimitată\n2. Materialized path se actualizează automat via trigger\n3. Embedding pentru semantic search\n4. Unique constraint pe (tenant_id, slug)",
  "outcome": "Tabelul product_categories creat cu ierarhie materialized path și suport AI"
}
```

## F3.1.3 Schema Fiscal (Oblio & e-Factura)

```json
{
  "taskID": "F3.1.3.T001",
  "denumire_task": "Creare tabel invoices pentru facturi și proforme",
  "context_anterior": "Schema products și negotiations complete. Acum trebuie să persistăm documentele fiscale generate.",
  "descriere_task": "Ești un expert în sisteme fiscale românești cu experiență în e-Factura. Task-ul tău este să creezi tabelul pentru facturi conforme cu legislația română.\n\nCreează migration în /packages/db/src/migrations/etapa3/006_invoices.ts:\n\n```typescript\nexport const invoices = pgTable('invoices', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  negotiationId: uuid('negotiation_id').references(() => negotiations.id),\n  contactId: uuid('contact_id').notNull().references(() => contactsGold.id),\n  \n  // Document Identification\n  documentType: text('document_type').notNull(), // 'proforma', 'invoice', 'credit_note', 'debit_note'\n  series: text('series').notNull(),\n  number: integer('number').notNull(),\n  documentNumber: text('document_number').notNull(), // 'FACT-2026-00001'\n  \n  // Dates\n  issueDate: date('issue_date').notNull(),\n  dueDate: date('due_date'),\n  deliveryDate: date('delivery_date'),\n  \n  // Supplier (fixed per tenant)\n  supplierName: text('supplier_name').notNull(),\n  supplierCui: text('supplier_cui').notNull(),\n  supplierRegCom: text('supplier_reg_com'),\n  supplierAddress: text('supplier_address').notNull(),\n  supplierCity: text('supplier_city').notNull(),\n  supplierCounty: text('supplier_county').notNull(),\n  supplierCountry: text('supplier_country').notNull().default('RO'),\n  supplierIban: text('supplier_iban'),\n  supplierBank: text('supplier_bank'),\n  supplierVatPayer: boolean('supplier_vat_payer').notNull().default(true),\n  \n  // Client\n  clientName: text('client_name').notNull(),\n  clientCui: text('client_cui').notNull(),\n  clientRegCom: text('client_reg_com'),\n  clientAddress: text('client_address').notNull(),\n  clientCity: text('client_city').notNull(),\n  clientCounty: text('client_county').notNull(),\n  clientCountry: text('client_country').notNull().default('RO'),\n  clientEmail: text('client_email'),\n  clientPhone: text('client_phone'),\n  clientVatPayer: boolean('client_vat_payer').notNull().default(false),\n  \n  // Amounts\n  subtotal: decimal('subtotal', { precision: 15, scale: 2 }).notNull(),\n  vatAmount: decimal('vat_amount', { precision: 15, scale: 2 }).notNull(),\n  totalAmount: decimal('total_amount', { precision: 15, scale: 2 }).notNull(),\n  currency: text('currency').notNull().default('RON'),\n  exchangeRate: decimal('exchange_rate', { precision: 10, scale: 6 }),\n  \n  // Discounts\n  discountPercent: decimal('discount_percent', { precision: 5, scale: 2 }),\n  discountAmount: decimal('discount_amount', { precision: 15, scale: 2 }),\n  discountReason: text('discount_reason'),\n  \n  // Payment\n  paymentMethod: text('payment_method'), // 'transfer', 'cash', 'card', 'cec'\n  paymentStatus: text('payment_status').notNull().default('pending'), // 'pending', 'partial', 'paid', 'overdue'\n  paidAmount: decimal('paid_amount', { precision: 15, scale: 2 }).default('0'),\n  paidAt: timestamp('paid_at', { withTimezone: true }),\n  \n  // Oblio Integration\n  oblioId: text('oblio_id'),\n  oblioSeriesName: text('oblio_series_name'),\n  oblioDocumentLink: text('oblio_document_link'),\n  oblioSyncedAt: timestamp('oblio_synced_at', { withTimezone: true }),\n  oblioError: text('oblio_error'),\n  \n  // e-Factura SPV\n  efacturaRequired: boolean('efactura_required').notNull().default(false),\n  efacturaStatus: text('efactura_status'), // 'pending', 'submitted', 'accepted', 'rejected', 'error'\n  efacturaUploadIndex: text('efactura_upload_index'),\n  efacturaDownloadId: text('efactura_download_id'),\n  efacturaSubmittedAt: timestamp('efactura_submitted_at', { withTimezone: true }),\n  efacturaResponseAt: timestamp('efactura_response_at', { withTimezone: true }),\n  efacturaErrors: jsonb('efactura_errors'),\n  efacturaXml: text('efactura_xml'), // Full XML for audit\n  \n  // Document Status\n  status: text('status').notNull().default('draft'), // 'draft', 'issued', 'sent', 'cancelled', 'storno'\n  cancelledAt: timestamp('cancelled_at', { withTimezone: true }),\n  cancelReason: text('cancel_reason'),\n  stornoInvoiceId: uuid('storno_invoice_id').references(() => invoices.id),\n  \n  // Delivery\n  sentToClientAt: timestamp('sent_to_client_at', { withTimezone: true }),\n  sentVia: text('sent_via'), // 'email', 'whatsapp', 'download'\n  viewedByClientAt: timestamp('viewed_by_client_at', { withTimezone: true }),\n  downloadedAt: timestamp('downloaded_at', { withTimezone: true }),\n  \n  // PDF\n  pdfUrl: text('pdf_url'),\n  pdfGeneratedAt: timestamp('pdf_generated_at', { withTimezone: true }),\n  \n  // Notes\n  internalNotes: text('internal_notes'),\n  clientNotes: text('client_notes'), // Appear on invoice\n  \n  // Metadata\n  metadata: jsonb('metadata').default('{}'),\n  \n  // Audit\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),\n  createdBy: uuid('created_by').references(() => users.id),\n  version: integer('version').notNull().default(1)\n}, (table) => ({\n  tenantIdx: index('invoices_tenant_idx').on(table.tenantId),\n  documentNumberIdx: index('invoices_doc_number_idx').on(table.tenantId, table.documentNumber),\n  clientIdx: index('invoices_client_idx').on(table.clientCui),\n  statusIdx: index('invoices_status_idx').on(table.status),\n  issueDateIdx: index('invoices_issue_date_idx').on(table.issueDate),\n  efacturaStatusIdx: index('invoices_efactura_status_idx').on(table.efacturaStatus),\n  paymentStatusIdx: index('invoices_payment_status_idx').on(table.paymentStatus),\n  uniqueDocNumber: unique('invoices_doc_number_unique').on(table.tenantId, table.series, table.number)\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "NU omite câmpurile e-Factura - sunt OBLIGATORII pentru B2G și B2B >5000 RON",
    "INCLUDE toate câmpurile furnizor și client conform codului fiscal",
    "NU permite document_number duplicat per tenant + series",
    "PĂSTREAZĂ XML complet pentru audit trail e-Factura"
  ],
  "validare_task": "1. Toate câmpurile fiscale obligatorii prezente\n2. Indexuri pentru lookup rapid pe CUI\n3. Unique constraint pe (tenant, series, number)\n4. Câmpuri complete pentru e-Factura SPV\n5. Istoric stări e-Factura",
  "outcome": "Tabelul invoices creat conform legislației fiscale române cu suport complet e-Factura"
}
```

```json
{
  "taskID": "F3.1.3.T002",
  "denumire_task": "Creare tabel invoice_items pentru linii factură",
  "context_anterior": "Tabelul invoices creat. Acum trebuie să creăm tabelul pentru liniile individuale ale facturilor.",
  "descriere_task": "Ești un expert în facturare electronică. Task-ul tău este să creezi tabelul pentru liniile de factură conforme cu UBL 2.1.\n\nCreează migration în /packages/db/src/migrations/etapa3/007_invoice_items.ts:\n\n```typescript\nexport const invoiceItems = pgTable('invoice_items', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  invoiceId: uuid('invoice_id').notNull().references(() => invoices.id, { onDelete: 'cascade' }),\n  productId: uuid('product_id').references(() => products.id),\n  \n  // Line Identification\n  lineNumber: integer('line_number').notNull(),\n  \n  // Product Info (denormalized for historical accuracy)\n  sku: text('sku'),\n  name: text('name').notNull(),\n  description: text('description'),\n  unitOfMeasure: text('unit_of_measure').notNull(),\n  ncCode: text('nc_code'), // Nomenclatură Combinată (customs)\n  cpvCode: text('cpv_code'), // Common Procurement Vocabulary\n  \n  // Quantity & Price\n  quantity: decimal('quantity', { precision: 15, scale: 4 }).notNull(),\n  unitPrice: decimal('unit_price', { precision: 15, scale: 4 }).notNull(),\n  unitPriceWithoutVat: decimal('unit_price_without_vat', { precision: 15, scale: 4 }).notNull(),\n  \n  // Discounts\n  discountPercent: decimal('discount_percent', { precision: 5, scale: 2 }),\n  discountAmount: decimal('discount_amount', { precision: 15, scale: 2 }),\n  \n  // Amounts\n  lineSubtotal: decimal('line_subtotal', { precision: 15, scale: 2 }).notNull(),\n  vatRate: decimal('vat_rate', { precision: 5, scale: 2 }).notNull(),\n  vatAmount: decimal('vat_amount', { precision: 15, scale: 2 }).notNull(),\n  lineTotal: decimal('line_total', { precision: 15, scale: 2 }).notNull(),\n  \n  // e-Factura specific\n  vatCategory: text('vat_category').notNull().default('S'), // S=Standard, Z=Zero, E=Exempt, AE=Reverse charge\n  vatExemptionReason: text('vat_exemption_reason'),\n  \n  // Sort & Display\n  sortOrder: integer('sort_order').notNull().default(0),\n  \n  // Metadata\n  metadata: jsonb('metadata').default('{}')\n}, (table) => ({\n  invoiceIdx: index('invoice_items_invoice_idx').on(table.invoiceId),\n  productIdx: index('invoice_items_product_idx').on(table.productId),\n  lineNumberUnique: unique('invoice_items_line_unique').on(table.invoiceId, table.lineNumber)\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "INCLUDE vatCategory pentru e-Factura (S, Z, E, AE)",
    "NU permite duplicate lineNumber per invoice",
    "DENORMALIZEAZĂ product info - prețurile se pot schimba",
    "FOLOSEȘTE precision: 4 pentru unitPrice (important pentru prețuri mici)"
  ],
  "validare_task": "1. Toate coloanele UBL 2.1 obligatorii prezente\n2. vatCategory conform codurilor e-Factura\n3. Unique constraint pe (invoice_id, line_number)\n4. Cascade delete de la invoice",
  "outcome": "Tabelul invoice_items creat conform UBL 2.1 pentru e-Factura"
}
```

```json
{
  "taskID": "F3.1.3.T003",
  "denumire_task": "Creare tabel efactura_submissions pentru tracking SPV",
  "context_anterior": "Tabelele invoices și invoice_items create. Acum trebuie să persistăm fiecare submission către ANAF SPV.",
  "descriere_task": "Ești un expert în integrare ANAF SPV. Task-ul tău este să creezi tabelul pentru tracking complet al submisiilor e-Factura.\n\nCreează migration în /packages/db/src/migrations/etapa3/008_efactura_submissions.ts:\n\n```typescript\nexport const efacturaSubmissions = pgTable('efactura_submissions', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),\n  invoiceId: uuid('invoice_id').notNull().references(() => invoices.id),\n  \n  // Submission Details\n  submissionType: text('submission_type').notNull(), // 'upload', 'storno', 'correction'\n  xmlContent: text('xml_content').notNull(), // Full UBL XML\n  xmlHash: text('xml_hash').notNull(), // SHA256 for integrity\n  xmlSize: integer('xml_size').notNull(),\n  \n  // ANAF Response\n  uploadIndex: text('upload_index'), // From ANAF response\n  downloadId: text('download_id'),\n  executionStatus: text('execution_status'), // 'in_prelucrare', 'ok', 'nok'\n  stare: text('stare'), // ANAF stare field\n  \n  // Status Tracking\n  status: text('status').notNull().default('pending'), // 'pending', 'submitted', 'processing', 'accepted', 'rejected', 'error'\n  \n  // Timestamps\n  submittedAt: timestamp('submitted_at', { withTimezone: true }),\n  lastCheckedAt: timestamp('last_checked_at', { withTimezone: true }),\n  completedAt: timestamp('completed_at', { withTimezone: true }),\n  \n  // Polling\n  checkAttempts: integer('check_attempts').notNull().default(0),\n  nextCheckAt: timestamp('next_check_at', { withTimezone: true }),\n  \n  // Errors\n  errorCode: text('error_code'),\n  errorMessage: text('error_message'),\n  errorDetails: jsonb('error_details'),\n  validationErrors: jsonb('validation_errors'), // From ANAF validation\n  \n  // Response Storage\n  responseXml: text('response_xml'),\n  responseReceivedAt: timestamp('response_received_at', { withTimezone: true }),\n  \n  // Retry\n  retryCount: integer('retry_count').notNull().default(0),\n  maxRetries: integer('max_retries').notNull().default(3),\n  lastRetryAt: timestamp('last_retry_at', { withTimezone: true }),\n  \n  // Audit\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n  createdBy: uuid('created_by').references(() => users.id)\n}, (table) => ({\n  tenantIdx: index('efactura_sub_tenant_idx').on(table.tenantId),\n  invoiceIdx: index('efactura_sub_invoice_idx').on(table.invoiceId),\n  statusIdx: index('efactura_sub_status_idx').on(table.status),\n  uploadIndexIdx: index('efactura_sub_upload_idx').on(table.uploadIndex),\n  nextCheckIdx: index('efactura_sub_next_check_idx').on(table.nextCheckAt).where(isNotNull(table.nextCheckAt))\n}));\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/db/src/migrations/etapa3",
  "restrictii_antihalucinatie": [
    "STOCHEAZĂ XML complet - necesar pentru audit și retry",
    "INCLUDE xml_hash pentru verificare integritate",
    "NU depăși 3 retries - ANAF poate bloca",
    "TRACKING polling status pentru job scheduling"
  ],
  "validare_task": "1. XML complet stocat pentru audit\n2. Hash SHA256 calculat și stocat\n3. Retry logic cu max_retries\n4. Index pentru next_check polling",
  "outcome": "Tabelul efactura_submissions creat pentru tracking complet SPV ANAF"
}
```

---

# FAZA F3.2: PRODUCT KNOWLEDGE WORKERS (CATEGORIA A)

## F3.2.1 Worker Setup Base

```json
{
  "taskID": "F3.2.1.T001",
  "denumire_task": "Setup infrastructură BullMQ pentru Etapa 3 workers",
  "context_anterior": "Schema database completă. Acum trebuie să configurăm queue-urile BullMQ pentru toți workerii Etapa 3.",
  "descriere_task": "Ești un expert BullMQ cu experiență în sisteme distribuite. Task-ul tău este să creezi configurația queue-urilor pentru Etapa 3.\n\nCreează fișierul /packages/workers/src/config/etapa3-queues.ts:\n\n```typescript\nimport { Queue, QueueOptions, Worker, WorkerOptions } from 'bullmq';\nimport { Redis } from 'ioredis';\n\n// Redis connection\nconst redisConnection = new Redis({\n  host: process.env.REDIS_HOST || 'localhost',\n  port: parseInt(process.env.REDIS_PORT || '6379'),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false\n});\n\n// Default queue options\nconst defaultQueueOptions: QueueOptions = {\n  connection: redisConnection,\n  defaultJobOptions: {\n    attempts: 3,\n    backoff: {\n      type: 'exponential',\n      delay: 1000\n    },\n    removeOnComplete: {\n      age: 24 * 3600, // Keep completed jobs for 24h\n      count: 1000\n    },\n    removeOnFail: {\n      age: 7 * 24 * 3600, // Keep failed jobs for 7 days\n      count: 5000\n    }\n  }\n};\n\n// Queue definitions per category\nexport const ETAPA3_QUEUES = {\n  // Category A: Product Knowledge\n  PRODUCT_INGEST: 'etapa3:product:ingest',\n  PRODUCT_EMBED: 'etapa3:product:embed',\n  PRODUCT_CHUNK: 'etapa3:product:chunk',\n  PRODUCT_INDEX: 'etapa3:product:index',\n  PRODUCT_CATEGORY_SYNC: 'etapa3:product:category-sync',\n  PRODUCT_ERP_SYNC: 'etapa3:product:erp-sync',\n  \n  // Category B: Hybrid Search RAG\n  RAG_SEMANTIC_SEARCH: 'etapa3:rag:semantic-search',\n  RAG_KEYWORD_SEARCH: 'etapa3:rag:keyword-search',\n  RAG_HYBRID_MERGE: 'etapa3:rag:hybrid-merge',\n  RAG_CONTEXT_BUILD: 'etapa3:rag:context-build',\n  RAG_RERANK: 'etapa3:rag:rerank',\n  RAG_CACHE_WARM: 'etapa3:rag:cache-warm',\n  \n  // Category C: AI Agent Core\n  AI_CONTEXT_BUILD: 'etapa3:ai:context-build',\n  AI_ORCHESTRATE: 'etapa3:ai:orchestrate',\n  AI_RESPONSE_GENERATE: 'etapa3:ai:response-generate',\n  AI_TOOL_EXECUTE: 'etapa3:ai:tool-execute',\n  AI_STREAM_PROCESS: 'etapa3:ai:stream-process',\n  AI_FALLBACK: 'etapa3:ai:fallback',\n  \n  // Category D: Negotiation FSM\n  NEG_CREATE: 'etapa3:neg:create',\n  NEG_TRANSITION: 'etapa3:neg:transition',\n  NEG_VALIDATE: 'etapa3:neg:validate',\n  NEG_TIMEOUT_CHECK: 'etapa3:neg:timeout-check',\n  NEG_AUTO_PROGRESS: 'etapa3:neg:auto-progress',\n  NEG_CLOSE: 'etapa3:neg:close',\n  NEG_ARCHIVE: 'etapa3:neg:archive',\n  NEG_ANALYTICS: 'etapa3:neg:analytics',\n  \n  // Category E: Pricing & Discount\n  PRICE_CALCULATE: 'etapa3:price:calculate',\n  PRICE_VALIDATE: 'etapa3:price:validate',\n  DISCOUNT_REQUEST: 'etapa3:discount:request',\n  DISCOUNT_APPROVE: 'etapa3:discount:approve',\n  MARGIN_CHECK: 'etapa3:margin:check',\n  PRICE_HISTORY: 'etapa3:price:history',\n  \n  // Category F: Stock & Inventory\n  STOCK_CHECK: 'etapa3:stock:check',\n  STOCK_RESERVE: 'etapa3:stock:reserve',\n  STOCK_RELEASE: 'etapa3:stock:release',\n  STOCK_SYNC: 'etapa3:stock:sync',\n  STOCK_ALERT: 'etapa3:stock:alert',\n  INVENTORY_AUDIT: 'etapa3:inventory:audit',\n  \n  // Category G: Oblio Integration\n  OBLIO_AUTH: 'etapa3:oblio:auth',\n  OBLIO_PROFORMA: 'etapa3:oblio:proforma',\n  OBLIO_INVOICE: 'etapa3:oblio:invoice',\n  OBLIO_STORNO: 'etapa3:oblio:storno',\n  OBLIO_SYNC: 'etapa3:oblio:sync',\n  OBLIO_WEBHOOK: 'etapa3:oblio:webhook',\n  OBLIO_RETRY: 'etapa3:oblio:retry',\n  \n  // Category H: e-Factura SPV\n  EFACTURA_GENERATE: 'etapa3:efactura:generate',\n  EFACTURA_VALIDATE: 'etapa3:efactura:validate',\n  EFACTURA_SUBMIT: 'etapa3:efactura:submit',\n  EFACTURA_POLL: 'etapa3:efactura:poll',\n  EFACTURA_DOWNLOAD: 'etapa3:efactura:download',\n  \n  // Category I: Document Generation\n  DOC_PROPOSAL: 'etapa3:doc:proposal',\n  DOC_CONTRACT: 'etapa3:doc:contract',\n  DOC_PDF: 'etapa3:doc:pdf',\n  DOC_EMAIL: 'etapa3:doc:email',\n  DOC_ARCHIVE: 'etapa3:doc:archive',\n  \n  // Category J: Handover & Channel\n  CHANNEL_INGEST: 'etapa3:channel:ingest',\n  CHANNEL_ROUTE: 'etapa3:channel:route',\n  CHANNEL_DELIVER: 'etapa3:channel:deliver',\n  HANDOVER_DETECT: 'etapa3:handover:detect',\n  HANDOVER_EXECUTE: 'etapa3:handover:execute',\n  \n  // Category K: Sentiment & Intent\n  SENTIMENT_ANALYZE: 'etapa3:sentiment:analyze',\n  INTENT_DETECT: 'etapa3:intent:detect',\n  URGENCY_ASSESS: 'etapa3:urgency:assess',\n  EMOTION_TRACK: 'etapa3:emotion:track',\n  CHURN_PREDICT: 'etapa3:churn:predict',\n  \n  // Category L: MCP Server\n  MCP_TOOL_REGISTER: 'etapa3:mcp:tool-register',\n  MCP_TOOL_EXECUTE: 'etapa3:mcp:tool-execute',\n  MCP_CONTEXT_INJECT: 'etapa3:mcp:context-inject',\n  MCP_RESPONSE_FORMAT: 'etapa3:mcp:response-format',\n  MCP_ERROR_HANDLE: 'etapa3:mcp:error-handle',\n  \n  // Category M: Guardrails\n  GUARD_PRICE: 'etapa3:guard:price',\n  GUARD_STOCK: 'etapa3:guard:stock',\n  GUARD_DISCOUNT: 'etapa3:guard:discount',\n  GUARD_SKU: 'etapa3:guard:sku',\n  GUARD_FISCAL: 'etapa3:guard:fiscal',\n  \n  // Category N: Human Intervention\n  HITL_ESCALATE: 'etapa3:hitl:escalate',\n  HITL_NOTIFY: 'etapa3:hitl:notify',\n  HITL_RESOLVE: 'etapa3:hitl:resolve'\n} as const;\n\nexport type Etapa3QueueName = typeof ETAPA3_QUEUES[keyof typeof ETAPA3_QUEUES];\n\n// Queue factory\nexport function createEtapa3Queue(name: Etapa3QueueName, options?: Partial<QueueOptions>): Queue {\n  return new Queue(name, {\n    ...defaultQueueOptions,\n    ...options\n  });\n}\n\n// Worker factory with sensible defaults\nexport function createEtapa3Worker(\n  name: Etapa3QueueName,\n  processor: WorkerOptions['processor'],\n  options?: Partial<WorkerOptions>\n): Worker {\n  return new Worker(name, processor, {\n    connection: redisConnection,\n    concurrency: 5,\n    limiter: {\n      max: 100,\n      duration: 1000\n    },\n    ...options\n  });\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/config",
  "restrictii_antihalucinatie": [
    "NU hardcoda conexiunea Redis - folosește env vars",
    "INCLUDE toate cele 78 de queue-uri definite în spec",
    "CONFIGURARE job retention diferită pentru completed vs failed",
    "NU seta concurrency > 10 fără load testing"
  ],
  "validare_task": "1. Toate cele 78 de queue-uri definite\n2. Factory functions pentru Queue și Worker\n3. Redis connection configurabilă via env\n4. Default job options cu exponential backoff",
  "outcome": "Infrastructură BullMQ configurată pentru toate queue-urile Etapa 3"
}
```

## F3.2.2 Product Ingest Worker (#1)

```json
{
  "taskID": "F3.2.2.T001",
  "denumire_task": "Implementare worker product:ingest pentru import produse",
  "context_anterior": "Queue-urile BullMQ configurate. Acum implementăm primul worker din Categoria A - ingestia produselor.",
  "descriere_task": "Ești un expert în data pipelines. Task-ul tău este să creezi workerul pentru ingestia produselor din multiple surse.\n\nCreează fișierul /packages/workers/src/etapa3/category-a/product-ingest.worker.ts:\n\n```typescript\nimport { Job, Worker } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products } from '@cerniq/db/schema';\nimport { z } from 'zod';\nimport { logger } from '@cerniq/logger';\n\n// Job payload schema\nconst ProductIngestPayload = z.object({\n  tenantId: z.string().uuid(),\n  source: z.enum(['csv', 'excel', 'api', 'erp', 'manual']),\n  sourceRef: z.string().optional(),\n  products: z.array(z.object({\n    sku: z.string().min(1),\n    name: z.string().min(1),\n    nameRo: z.string().optional(),\n    description: z.string().optional(),\n    descriptionRo: z.string().optional(),\n    categoryPath: z.string().optional(), // 'Pesticide.Fungicide'\n    brand: z.string().optional(),\n    basePrice: z.number().positive(),\n    currency: z.string().default('RON'),\n    vatRate: z.number().min(0).max(100).default(19),\n    unitOfMeasure: z.string().default('BUC'),\n    currentStock: z.number().min(0).default(0),\n    maxDiscountPercent: z.number().min(0).max(100).default(0),\n    cropType: z.string().optional(),\n    activeIngredients: z.array(z.string()).optional(),\n    images: z.array(z.string().url()).optional(),\n    customAttributes: z.record(z.any()).optional()\n  })),\n  options: z.object({\n    upsertMode: z.enum(['skip', 'update', 'replace']).default('update'),\n    generateEmbeddings: z.boolean().default(true),\n    validateStock: z.boolean().default(false)\n  }).optional()\n});\n\ntype ProductIngestJob = z.infer<typeof ProductIngestPayload>;\n\n// Worker processor\nasync function processProductIngest(job: Job<ProductIngestJob>): Promise<{\n  imported: number;\n  updated: number;\n  skipped: number;\n  errors: Array<{ sku: string; error: string }>;\n}> {\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  log.info('Starting product ingest', { source: job.data.source, count: job.data.products.length });\n  \n  const result = {\n    imported: 0,\n    updated: 0,\n    skipped: 0,\n    errors: [] as Array<{ sku: string; error: string }>\n  };\n  \n  const { tenantId, products: productList, options } = job.data;\n  const upsertMode = options?.upsertMode || 'update';\n  \n  // Process in batches\n  const BATCH_SIZE = 100;\n  const batches = Math.ceil(productList.length / BATCH_SIZE);\n  \n  for (let i = 0; i < batches; i++) {\n    const batch = productList.slice(i * BATCH_SIZE, (i + 1) * BATCH_SIZE);\n    \n    await job.updateProgress(Math.round((i / batches) * 100));\n    \n    for (const product of batch) {\n      try {\n        // Check if product exists\n        const existing = await db.query.products.findFirst({\n          where: (p, { and, eq }) => and(\n            eq(p.tenantId, tenantId),\n            eq(p.sku, product.sku)\n          )\n        });\n        \n        if (existing && upsertMode === 'skip') {\n          result.skipped++;\n          continue;\n        }\n        \n        // Calculate price with VAT\n        const priceWithVat = product.basePrice * (1 + product.vatRate / 100);\n        const minPrice = product.basePrice * (1 - (product.maxDiscountPercent || 0) / 100);\n        \n        // Resolve category\n        let categoryId: string | null = null;\n        if (product.categoryPath) {\n          const category = await db.query.productCategories.findFirst({\n            where: (c, { and, eq }) => and(\n              eq(c.tenantId, tenantId),\n              eq(c.path, product.categoryPath)\n            )\n          });\n          categoryId = category?.id || null;\n        }\n        \n        // Build searchable keywords\n        const searchKeywords = [\n          product.name,\n          product.nameRo,\n          product.brand,\n          product.sku,\n          ...(product.activeIngredients || []),\n          product.cropType\n        ].filter(Boolean).join(' ');\n        \n        const productData = {\n          tenantId,\n          sku: product.sku,\n          name: product.name,\n          nameRo: product.nameRo,\n          description: product.description,\n          descriptionRo: product.descriptionRo,\n          categoryId,\n          brand: product.brand,\n          basePrice: product.basePrice.toString(),\n          currency: product.currency,\n          vatRate: product.vatRate.toString(),\n          priceWithVat: priceWithVat.toFixed(2),\n          minPrice: minPrice.toFixed(2),\n          unitOfMeasure: product.unitOfMeasure,\n          currentStock: product.currentStock.toString(),\n          maxDiscountPercent: (product.maxDiscountPercent || 0).toString(),\n          cropType: product.cropType,\n          activeIngredients: product.activeIngredients || [],\n          images: product.images || [],\n          customAttributes: product.customAttributes || {},\n          searchKeywords,\n          status: 'active',\n          updatedAt: new Date()\n        };\n        \n        if (existing) {\n          if (upsertMode === 'replace') {\n            await db.update(products)\n              .set(productData)\n              .where(eq(products.id, existing.id));\n          } else {\n            // Update only non-null fields\n            await db.update(products)\n              .set({\n                ...productData,\n                version: sql`version + 1`\n              })\n              .where(eq(products.id, existing.id));\n          }\n          result.updated++;\n        } else {\n          await db.insert(products).values({\n            ...productData,\n            createdAt: new Date()\n          });\n          result.imported++;\n        }\n        \n        // Queue embedding generation if enabled\n        if (options?.generateEmbeddings !== false) {\n          const embedQueue = createEtapa3Queue(ETAPA3_QUEUES.PRODUCT_EMBED);\n          await embedQueue.add('embed-product', {\n            tenantId,\n            sku: product.sku,\n            priority: 'normal'\n          });\n        }\n        \n      } catch (error) {\n        log.error('Failed to ingest product', { sku: product.sku, error });\n        result.errors.push({\n          sku: product.sku,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n      }\n    }\n  }\n  \n  await job.updateProgress(100);\n  log.info('Product ingest completed', result);\n  \n  return result;\n}\n\n// Create and export worker\nexport const productIngestWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.PRODUCT_INGEST,\n  processProductIngest,\n  {\n    concurrency: 3,\n    limiter: {\n      max: 10,\n      duration: 1000\n    }\n  }\n);\n\n// Event handlers\nproductIngestWorker.on('completed', (job, result) => {\n  logger.info('Product ingest job completed', {\n    jobId: job.id,\n    imported: result.imported,\n    updated: result.updated,\n    errors: result.errors.length\n  });\n});\n\nproductIngestWorker.on('failed', (job, error) => {\n  logger.error('Product ingest job failed', {\n    jobId: job?.id,\n    error: error.message\n  });\n});\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-a",
  "restrictii_antihalucinatie": [
    "NU procesa toate produsele într-o singură tranzacție - folosește batches",
    "CALCULEAZĂ minPrice pentru guardrail validare discount",
    "QUEUE embedding generation ca job separat",
    "INCLUDE searchKeywords pentru full-text search",
    "LOGGING detaliat pentru debugging"
  ],
  "validare_task": "1. Zod schema validează payload-ul\n2. Batch processing implementat\n3. Upsert modes funcționează (skip/update/replace)\n4. Embedding jobs queued automat\n5. Progress updates trimise",
  "outcome": "Worker product:ingest funcțional pentru import produse din multiple surse"
}
```

## F3.2.3 Product Embed Worker (#2)

```json
{
  "taskID": "F3.2.3.T001",
  "denumire_task": "Implementare worker product:embed pentru generare embeddings",
  "context_anterior": "Product ingest worker queue-uiește jobs pentru embedding. Acum implementăm workerul pentru generare embeddings cu OpenAI.",
  "descriere_task": "Ești un expert în vector embeddings și RAG. Task-ul tău este să creezi workerul pentru generarea embeddings-urilor produselor.\n\nCreează fișierul /packages/workers/src/etapa3/category-a/product-embed.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products } from '@cerniq/db/schema';\nimport { eq, and, isNull } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY\n});\n\n// Job types\ninterface ProductEmbedJob {\n  tenantId: string;\n  sku?: string;\n  productId?: string;\n  priority: 'high' | 'normal' | 'low';\n  reembed?: boolean; // Force re-embedding\n}\n\ninterface BatchEmbedJob {\n  tenantId: string;\n  batchSize?: number;\n  onlyMissing?: boolean; // Only products without embeddings\n}\n\n// Build embedding text from product\nfunction buildEmbeddingText(product: any): string {\n  const parts = [\n    product.name,\n    product.nameRo,\n    product.description?.slice(0, 500), // Limit description\n    product.descriptionRo?.slice(0, 500),\n    product.brand,\n    product.cropType,\n    ...(product.activeIngredients || []),\n    ...(product.tags || [])\n  ].filter(Boolean);\n  \n  return parts.join('. ').slice(0, 8000); // OpenAI limit\n}\n\nasync function generateEmbedding(text: string): Promise<number[]> {\n  const response = await openai.embeddings.create({\n    model: 'text-embedding-3-small',\n    input: text,\n    dimensions: 1536\n  });\n  \n  return response.data[0].embedding;\n}\n\nasync function processProductEmbed(job: Job<ProductEmbedJob>): Promise<{ success: boolean; sku?: string }> {\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  const { tenantId, sku, productId, reembed } = job.data;\n  \n  // Find product\n  const product = await db.query.products.findFirst({\n    where: (p, { and, eq, or }) => and(\n      eq(p.tenantId, tenantId),\n      sku ? eq(p.sku, sku) : eq(p.id, productId!)\n    )\n  });\n  \n  if (!product) {\n    log.warn('Product not found for embedding', { sku, productId });\n    return { success: false };\n  }\n  \n  // Skip if already has embedding and not forced\n  if (product.embedding && !reembed) {\n    log.debug('Product already has embedding, skipping', { sku: product.sku });\n    return { success: true, sku: product.sku };\n  }\n  \n  log.info('Generating embedding for product', { sku: product.sku });\n  \n  // Build text and generate embedding\n  const text = buildEmbeddingText(product);\n  const embedding = await generateEmbedding(text);\n  \n  // Update product with embedding\n  await db.update(products)\n    .set({\n      embedding,\n      updatedAt: new Date()\n    })\n    .where(eq(products.id, product.id));\n  \n  log.info('Embedding generated successfully', { sku: product.sku });\n  \n  // Queue indexing\n  const indexQueue = createEtapa3Queue(ETAPA3_QUEUES.PRODUCT_INDEX);\n  await indexQueue.add('index-product', {\n    tenantId,\n    productId: product.id\n  });\n  \n  return { success: true, sku: product.sku };\n}\n\n// Batch embedding processor\nasync function processBatchEmbed(job: Job<BatchEmbedJob>): Promise<{ processed: number; errors: number }> {\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  const { tenantId, batchSize = 100, onlyMissing = true } = job.data;\n  \n  log.info('Starting batch embedding', { batchSize, onlyMissing });\n  \n  // Find products needing embeddings\n  const productsToEmbed = await db.query.products.findMany({\n    where: (p, { and, eq, isNull }) => and(\n      eq(p.tenantId, tenantId),\n      eq(p.status, 'active'),\n      onlyMissing ? isNull(p.embedding) : undefined\n    ),\n    limit: batchSize\n  });\n  \n  let processed = 0;\n  let errors = 0;\n  \n  // Process with rate limiting (OpenAI: 3000 RPM for embeddings)\n  for (const product of productsToEmbed) {\n    try {\n      const text = buildEmbeddingText(product);\n      const embedding = await generateEmbedding(text);\n      \n      await db.update(products)\n        .set({ embedding, updatedAt: new Date() })\n        .where(eq(products.id, product.id));\n      \n      processed++;\n      await job.updateProgress(Math.round((processed / productsToEmbed.length) * 100));\n      \n      // Rate limit: ~50/sec to stay under 3000 RPM\n      await new Promise(resolve => setTimeout(resolve, 20));\n      \n    } catch (error) {\n      log.error('Failed to embed product', { sku: product.sku, error });\n      errors++;\n    }\n  }\n  \n  log.info('Batch embedding completed', { processed, errors });\n  return { processed, errors };\n}\n\n// Single product worker\nexport const productEmbedWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.PRODUCT_EMBED,\n  processProductEmbed,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 50,\n      duration: 1000 // 50 req/sec\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-a",
  "restrictii_antihalucinatie": [
    "LIMITEAZĂ text la 8000 chars pentru OpenAI",
    "NU depăși rate limit OpenAI (3000 RPM pentru embeddings)",
    "FOLOSEȘTE text-embedding-3-small cu 1536 dimensiuni",
    "SKIP dacă embedding există și !reembed",
    "QUEUE indexare după embedding success"
  ],
  "validare_task": "1. Embedding generat cu OpenAI text-embedding-3-small\n2. Rate limiting implementat (50 req/sec)\n3. Batch processing suportat\n4. Index job queued după succes",
  "outcome": "Worker product:embed funcțional pentru generare embeddings cu OpenAI"
}
```

---

# FAZA F3.4: AI AGENT CORE WORKERS (CATEGORIA C)

## F3.4.1 AI Orchestration Worker (#13)

```json
{
  "taskID": "F3.4.1.T001",
  "denumire_task": "Implementare worker ai:orchestrate - orchestratorul principal AI Agent",
  "context_anterior": "Product knowledge și search workers complete. Acum implementăm nucleul AI Agent - orchestratorul care coordonează toate componentele.",
  "descriere_task": "Ești un expert în AI agents și orchestrare LLM. Task-ul tău este să creezi orchestratorul principal care coordonează conversațiile AI.\n\nCreează fișierul /packages/workers/src/etapa3/category-c/ai-orchestrate.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiations, negotiationMessages } from '@cerniq/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { MCPClient } from '@cerniq/mcp-client';\nimport { metrics } from '@cerniq/metrics';\n\n// Job payload\nconst AIOrchestatePayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  messageId: z.string().uuid(), // Incoming message ID\n  userMessage: z.string(),\n  channelType: z.enum(['whatsapp', 'email', 'web_chat']),\n  options: z.object({\n    maxTokens: z.number().default(2048),\n    temperature: z.number().min(0).max(2).default(0.7),\n    forceRegenerate: z.boolean().default(false),\n    streamResponse: z.boolean().default(false)\n  }).optional()\n});\n\ntype AIOrchestratJob = z.infer<typeof AIOrchestatePayload>;\n\n// Orchestration steps\nenum OrchestrationStep {\n  CONTEXT_BUILD = 'context_build',\n  INTENT_DETECT = 'intent_detect',\n  RAG_SEARCH = 'rag_search',\n  LLM_GENERATE = 'llm_generate',\n  GUARDRAIL_CHECK = 'guardrail_check',\n  TOOL_EXECUTE = 'tool_execute',\n  RESPONSE_DELIVER = 'response_deliver'\n}\n\ninterface OrchestrationResult {\n  success: boolean;\n  responseMessageId?: string;\n  responseContent?: string;\n  toolsExecuted?: string[];\n  guardrailsPassed?: boolean;\n  regenerationCount?: number;\n  tokensUsed?: number;\n  latencyMs?: number;\n  error?: string;\n}\n\nasync function processAIOrchestrate(job: Job<AIOrchestratJob>): Promise<OrchestrationResult> {\n  const startTime = Date.now();\n  const log = logger.child({\n    jobId: job.id,\n    tenantId: job.data.tenantId,\n    negotiationId: job.data.negotiationId\n  });\n  \n  log.info('Starting AI orchestration', { userMessage: job.data.userMessage.slice(0, 100) });\n  \n  const { tenantId, negotiationId, messageId, userMessage, channelType, options } = job.data;\n  \n  try {\n    // Step 1: Load negotiation context\n    await job.updateProgress(10);\n    const negotiation = await db.query.negotiations.findFirst({\n      where: eq(negotiations.id, negotiationId),\n      with: {\n        contact: true,\n        messages: {\n          limit: 20,\n          orderBy: (m, { desc }) => desc(m.createdAt)\n        }\n      }\n    });\n    \n    if (!negotiation) {\n      throw new Error(`Negotiation not found: ${negotiationId}`);\n    }\n    \n    if (!negotiation.aiEnabled) {\n      log.info('AI disabled for negotiation, skipping');\n      return { success: true, responseContent: null };\n    }\n    \n    // Step 2: Detect intent and sentiment\n    await job.updateProgress(20);\n    const intentQueue = createEtapa3Queue(ETAPA3_QUEUES.INTENT_DETECT);\n    const intentJob = await intentQueue.add('detect', {\n      tenantId,\n      text: userMessage,\n      context: { negotiationState: negotiation.currentState }\n    }, { priority: 1 });\n    const intentResult = await intentJob.waitUntilFinished(intentQueue);\n    \n    log.info('Intent detected', { intent: intentResult.intent, confidence: intentResult.confidence });\n    \n    // Step 3: RAG search for relevant products\n    await job.updateProgress(30);\n    const ragQueue = createEtapa3Queue(ETAPA3_QUEUES.RAG_HYBRID_MERGE);\n    const ragJob = await ragQueue.add('search', {\n      tenantId,\n      query: userMessage,\n      intent: intentResult.intent,\n      topK: 5\n    }, { priority: 1 });\n    const ragResults = await ragJob.waitUntilFinished(ragQueue);\n    \n    // Step 4: Build MCP context\n    await job.updateProgress(40);\n    const mcpClient = new MCPClient({\n      tenantId,\n      negotiationId,\n      tools: [\n        'get_product_info',\n        'check_stock',\n        'calculate_price',\n        'apply_discount',\n        'create_proposal',\n        'schedule_callback'\n      ]\n    });\n    \n    // Build conversation history\n    const conversationHistory = negotiation.messages\n      .reverse()\n      .map(m => ({\n        role: m.role as 'user' | 'assistant',\n        content: m.content\n      }));\n    \n    // Build system prompt with context\n    const systemPrompt = buildSystemPrompt({\n      negotiation,\n      contact: negotiation.contact,\n      intent: intentResult,\n      ragContext: ragResults.documents,\n      tools: mcpClient.getToolDefinitions()\n    });\n    \n    // Step 5: Generate LLM response\n    await job.updateProgress(50);\n    let response: LLMResponse;\n    let regenerationCount = 0;\n    const MAX_REGENERATIONS = 3;\n    \n    do {\n      log.info('Generating LLM response', { attempt: regenerationCount + 1 });\n      \n      response = await mcpClient.chat({\n        model: negotiation.aiModel || 'grok-4',\n        systemPrompt,\n        messages: [...conversationHistory, { role: 'user', content: userMessage }],\n        maxTokens: options?.maxTokens || 2048,\n        temperature: options?.temperature || 0.7\n      });\n      \n      // Step 6: Execute tool calls if any\n      if (response.toolCalls?.length > 0) {\n        await job.updateProgress(60);\n        log.info('Executing tool calls', { tools: response.toolCalls.map(t => t.name) });\n        \n        for (const toolCall of response.toolCalls) {\n          const toolQueue = createEtapa3Queue(ETAPA3_QUEUES.MCP_TOOL_EXECUTE);\n          const toolJob = await toolQueue.add('execute', {\n            tenantId,\n            negotiationId,\n            toolName: toolCall.name,\n            toolInput: toolCall.input\n          }, { priority: 1 });\n          \n          const toolResult = await toolJob.waitUntilFinished(toolQueue);\n          response = await mcpClient.continueWithToolResult(toolCall.id, toolResult);\n        }\n      }\n      \n      // Step 7: Run guardrails\n      await job.updateProgress(70);\n      const guardrailResults = await runGuardrails({\n        tenantId,\n        negotiationId,\n        response: response.content,\n        toolCalls: response.toolCalls,\n        intent: intentResult.intent\n      });\n      \n      if (!guardrailResults.passed) {\n        log.warn('Guardrails failed, regenerating', {\n          failures: guardrailResults.failures,\n          attempt: regenerationCount + 1\n        });\n        \n        // Add guardrail feedback to prompt\n        systemPrompt += `\\n\\n[GUARDRAIL CORRECTION]: ${guardrailResults.correctionPrompt}`;\n        regenerationCount++;\n        continue;\n      }\n      \n      break; // Guardrails passed\n      \n    } while (regenerationCount < MAX_REGENERATIONS);\n    \n    if (regenerationCount >= MAX_REGENERATIONS) {\n      log.error('Max regenerations reached, escalating to HITL');\n      await escalateToHITL(tenantId, negotiationId, 'guardrail_max_regenerations');\n      return {\n        success: false,\n        error: 'Max guardrail regenerations reached',\n        regenerationCount\n      };\n    }\n    \n    // Step 8: Save response message\n    await job.updateProgress(80);\n    const responseMessage = await db.insert(negotiationMessages).values({\n      tenantId,\n      negotiationId,\n      role: 'assistant',\n      content: response.content,\n      contentType: 'text',\n      modelUsed: response.model,\n      promptTokens: response.usage?.promptTokens,\n      completionTokens: response.usage?.completionTokens,\n      totalTokens: response.usage?.totalTokens,\n      costEstimate: calculateCost(response.usage, response.model),\n      latencyMs: Date.now() - startTime,\n      toolCalls: response.toolCalls,\n      guardrailChecks: guardrailResults.checks,\n      guardrailPassed: true,\n      regenerationCount,\n      detectedIntent: intentResult.intent,\n      sentimentScore: intentResult.sentiment?.score,\n      sentimentLabel: intentResult.sentiment?.label,\n      channelType\n    }).returning();\n    \n    // Step 9: Update negotiation\n    await db.update(negotiations)\n      .set({\n        lastAiResponseAt: new Date(),\n        aiMessageCount: sql`ai_message_count + 1`,\n        aiTokensUsed: sql`ai_tokens_used + ${response.usage?.totalTokens || 0}`,\n        aiCostEstimate: sql`ai_cost_estimate + ${calculateCost(response.usage, response.model)}`,\n        updatedAt: new Date()\n      })\n      .where(eq(negotiations.id, negotiationId));\n    \n    // Step 10: Queue response delivery\n    await job.updateProgress(90);\n    const deliverQueue = createEtapa3Queue(ETAPA3_QUEUES.CHANNEL_DELIVER);\n    await deliverQueue.add('deliver', {\n      tenantId,\n      negotiationId,\n      messageId: responseMessage[0].id,\n      channelType,\n      content: response.content\n    });\n    \n    // Step 11: Check for state transition\n    if (intentResult.suggestedTransition) {\n      const transitionQueue = createEtapa3Queue(ETAPA3_QUEUES.NEG_TRANSITION);\n      await transitionQueue.add('transition', {\n        tenantId,\n        negotiationId,\n        fromState: negotiation.currentState,\n        toState: intentResult.suggestedTransition,\n        reason: `AI detected intent: ${intentResult.intent}`,\n        triggeredBy: 'ai_agent'\n      });\n    }\n    \n    await job.updateProgress(100);\n    \n    const latencyMs = Date.now() - startTime;\n    metrics.aiOrchestrationLatency.observe(latencyMs);\n    metrics.aiOrchestrationSuccess.inc();\n    \n    log.info('AI orchestration completed', {\n      responseMessageId: responseMessage[0].id,\n      tokensUsed: response.usage?.totalTokens,\n      latencyMs,\n      regenerationCount\n    });\n    \n    return {\n      success: true,\n      responseMessageId: responseMessage[0].id,\n      responseContent: response.content,\n      toolsExecuted: response.toolCalls?.map(t => t.name),\n      guardrailsPassed: true,\n      regenerationCount,\n      tokensUsed: response.usage?.totalTokens,\n      latencyMs\n    };\n    \n  } catch (error) {\n    log.error('AI orchestration failed', { error });\n    metrics.aiOrchestrationErrors.inc();\n    \n    // Escalate critical errors\n    await escalateToHITL(tenantId, negotiationId, 'orchestration_error', error);\n    \n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      latencyMs: Date.now() - startTime\n    };\n  }\n}\n\n// Helper functions\nfunction buildSystemPrompt(context: any): string {\n  return `Ești un agent comercial AI pentru o companie agricolă din România.\n  \nCLIENT ACTUAL:\n- Nume: ${context.contact.companyName || context.contact.name}\n- CUI: ${context.contact.cui}\n- Istoric: ${context.negotiation.aiMessageCount} mesaje anterioare\n- Stare negociere: ${context.negotiation.currentState}\n\nRESTRICȚII ABSOLUTE (GUARDRAILS):\n1. NU inventa prețuri - folosește DOAR tool get_product_info pentru prețuri\n2. NU confirma stoc fără check_stock - stocul se schimbă în timp real\n3. NU oferi discount > ${context.negotiation.maxDiscountPercent || 10}% fără aprobare\n4. NU inventa coduri produs (SKU) - verifică existența\n5. Răspunde DOAR în limba română\n\nPRODUSE RELEVANTE:\n${context.ragContext.map(d => `- ${d.name}: ${d.description?.slice(0, 100)}`).join('\\n')}\n\nINSTRUCȚIUNI:\n- Fii profesionist dar prietenos\n- Răspunde concis și la obiect\n- Dacă nu știi ceva, întreabă sau folosește tools\n- Propune următorul pas logic în vânzare`;\n}\n\nasync function runGuardrails(params: any): Promise<GuardrailResult> {\n  const guardrailQueue = createEtapa3Queue(ETAPA3_QUEUES.GUARD_PRICE);\n  // Implementation details in guardrails worker\n  const results = await Promise.all([\n    guardrailQueue.add('check-price', params),\n    // Add other guardrail checks...\n  ]);\n  // Aggregate results...\n  return { passed: true, checks: [], failures: [] };\n}\n\nasync function escalateToHITL(tenantId: string, negotiationId: string, reason: string, error?: any): Promise<void> {\n  const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n  await hitlQueue.add('escalate', {\n    tenantId,\n    negotiationId,\n    reason,\n    errorDetails: error?.message,\n    priority: 'high'\n  });\n}\n\nfunction calculateCost(usage: any, model: string): number {\n  if (!usage) return 0;\n  // Grok-4 pricing estimate\n  const inputCost = (usage.promptTokens / 1000) * 0.01;\n  const outputCost = (usage.completionTokens / 1000) * 0.03;\n  return inputCost + outputCost;\n}\n\n// Export worker\nexport const aiOrchestrateWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.AI_ORCHESTRATE,\n  processAIOrchestrate,\n  {\n    concurrency: 5,\n    limiter: {\n      max: 20,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-c",
  "restrictii_antihalucinatie": [
    "MAX 3 regenerări pe guardrail failure - apoi escalează HITL",
    "OBLIGATORIU intent detection înainte de LLM call",
    "NU genera răspuns fără RAG context",
    "INCLUDE cost tracking pentru fiecare request",
    "QUEUE delivery separat - nu trimite direct"
  ],
  "validare_task": "1. Orchestrează corect toate cele 11 pași\n2. Guardrail loop cu max 3 regenerări\n3. HITL escalation pe erori critice\n4. Cost tracking implementat\n5. State transition detection",
  "outcome": "Worker ai:orchestrate funcțional ca nucleu al AI Agent cu coordonare completă"
}
```

---

# FAZA F3.5: NEGOTIATION FSM WORKERS (CATEGORIA D)

## F3.5.1 Negotiation Transition Worker (#19)

```json
{
  "taskID": "F3.5.1.T001",
  "denumire_task": "Implementare worker neg:transition pentru tranziții FSM validate",
  "context_anterior": "AI Orchestrator queue-uiește tranziții de stare. Acum implementăm workerul care validează și execută tranzițiile FSM.",
  "descriere_task": "Ești un expert în Finite State Machines. Task-ul tău este să creezi workerul pentru tranziții de stare validate.\n\nCreează fișierul /packages/workers/src/etapa3/category-d/neg-transition.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiations, negotiationStateTransitions } from '@cerniq/db/schema';\nimport { eq, sql } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { \n  NEGOTIATION_STATES, \n  NEGOTIATION_TRANSITIONS,\n  NegotiationState \n} from '@cerniq/shared/constants/negotiation-states';\nimport { z } from 'zod';\nimport { EventEmitter } from '@cerniq/events';\nimport { metrics } from '@cerniq/metrics';\n\nconst TransitionPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  fromState: z.string(),\n  toState: z.string(),\n  reason: z.string(),\n  triggeredBy: z.enum(['ai_agent', 'user', 'system', 'cron', 'human']),\n  triggeredByUserId: z.string().uuid().optional(),\n  triggerMessageId: z.string().uuid().optional(),\n  aiConfidence: z.number().min(0).max(1).optional(),\n  aiReasoning: z.string().optional(),\n  force: z.boolean().default(false), // Skip validation\n  metadata: z.record(z.any()).optional()\n});\n\ntype TransitionJob = z.infer<typeof TransitionPayload>;\n\ninterface TransitionResult {\n  success: boolean;\n  transitionId?: string;\n  previousState: string;\n  newState: string;\n  validationErrors?: string[];\n  sideEffectsTriggered?: string[];\n}\n\nasync function processNegTransition(job: Job<TransitionJob>): Promise<TransitionResult> {\n  const log = logger.child({\n    jobId: job.id,\n    negotiationId: job.data.negotiationId\n  });\n  \n  const { \n    tenantId, \n    negotiationId, \n    fromState, \n    toState, \n    reason,\n    triggeredBy,\n    triggeredByUserId,\n    triggerMessageId,\n    aiConfidence,\n    aiReasoning,\n    force,\n    metadata\n  } = job.data;\n  \n  log.info('Processing state transition', { fromState, toState, reason });\n  \n  // Load current negotiation\n  const negotiation = await db.query.negotiations.findFirst({\n    where: eq(negotiations.id, negotiationId)\n  });\n  \n  if (!negotiation) {\n    throw new Error(`Negotiation not found: ${negotiationId}`);\n  }\n  \n  // Validate current state matches\n  if (negotiation.currentState !== fromState && !force) {\n    log.warn('State mismatch', { \n      expected: fromState, \n      actual: negotiation.currentState \n    });\n    return {\n      success: false,\n      previousState: negotiation.currentState,\n      newState: negotiation.currentState,\n      validationErrors: [`State mismatch: expected ${fromState}, got ${negotiation.currentState}`]\n    };\n  }\n  \n  // Validate transition is allowed\n  const allowedTransitions = NEGOTIATION_TRANSITIONS[fromState as NegotiationState] || [];\n  if (!allowedTransitions.includes(toState as NegotiationState) && !force) {\n    log.warn('Invalid transition', { fromState, toState, allowedTransitions });\n    return {\n      success: false,\n      previousState: fromState,\n      newState: fromState,\n      validationErrors: [`Transition ${fromState} -> ${toState} not allowed. Valid: ${allowedTransitions.join(', ')}`]\n    };\n  }\n  \n  // Calculate time in previous state\n  const durationMs = negotiation.stateEnteredAt \n    ? Date.now() - new Date(negotiation.stateEnteredAt).getTime()\n    : null;\n  \n  // Capture context snapshot\n  const contextSnapshot = {\n    products: negotiation.products,\n    totalValue: negotiation.totalValue,\n    discountPercent: negotiation.discountPercent,\n    aiMessageCount: negotiation.aiMessageCount,\n    priority: negotiation.priority\n  };\n  \n  // Start transaction\n  const result = await db.transaction(async (tx) => {\n    // Update negotiation state\n    const updatedNegotiation = await tx.update(negotiations)\n      .set({\n        previousState: fromState,\n        currentState: toState,\n        stateEnteredAt: new Date(),\n        stateHistory: sql`state_history || ${JSON.stringify([{\n          state: toState,\n          enteredAt: new Date().toISOString(),\n          reason,\n          triggeredBy\n        }])}::jsonb`,\n        updatedAt: new Date(),\n        version: sql`version + 1`\n      })\n      .where(eq(negotiations.id, negotiationId))\n      .returning();\n    \n    // Log transition\n    const transition = await tx.insert(negotiationStateTransitions)\n      .values({\n        tenantId,\n        negotiationId,\n        fromState,\n        toState,\n        transitionReason: reason,\n        transitionType: triggeredBy === 'ai_agent' ? 'ai_suggested' : \n                        triggeredBy === 'human' ? 'manual' : 'automatic',\n        triggeredBy,\n        triggeredByUserId,\n        triggerMessageId,\n        contextSnapshot,\n        aiConfidence,\n        aiReasoning,\n        validationPassed: true,\n        durationInPreviousStateMs: durationMs,\n        metadata\n      })\n      .returning();\n    \n    return {\n      negotiation: updatedNegotiation[0],\n      transition: transition[0]\n    };\n  });\n  \n  // Emit event\n  await EventEmitter.emit('negotiation:state:changed', {\n    tenantId,\n    negotiationId,\n    fromState,\n    toState,\n    reason,\n    transitionId: result.transition.id\n  });\n  \n  // Trigger side effects based on new state\n  const sideEffects = await triggerStateSideEffects({\n    tenantId,\n    negotiationId,\n    newState: toState,\n    negotiation: result.negotiation\n  });\n  \n  // Update metrics\n  metrics.negotiationTransitions.inc({ from: fromState, to: toState });\n  if (durationMs) {\n    metrics.statesDuration.observe({ state: fromState }, durationMs / 1000);\n  }\n  \n  log.info('State transition completed', {\n    transitionId: result.transition.id,\n    fromState,\n    toState,\n    durationMs,\n    sideEffects\n  });\n  \n  return {\n    success: true,\n    transitionId: result.transition.id,\n    previousState: fromState,\n    newState: toState,\n    sideEffectsTriggered: sideEffects\n  };\n}\n\nasync function triggerStateSideEffects(params: {\n  tenantId: string;\n  negotiationId: string;\n  newState: string;\n  negotiation: any;\n}): Promise<string[]> {\n  const { tenantId, negotiationId, newState, negotiation } = params;\n  const sideEffects: string[] = [];\n  \n  switch (newState) {\n    case NEGOTIATION_STATES.VERBAL_AGREEMENT:\n      // Queue proforma generation\n      const proformaQueue = createEtapa3Queue(ETAPA3_QUEUES.OBLIO_PROFORMA);\n      await proformaQueue.add('generate', { tenantId, negotiationId });\n      sideEffects.push('proforma_generation');\n      break;\n      \n    case NEGOTIATION_STATES.CONTRACT_SIGNED:\n      // Queue invoice generation\n      const invoiceQueue = createEtapa3Queue(ETAPA3_QUEUES.OBLIO_INVOICE);\n      await invoiceQueue.add('generate', { tenantId, negotiationId });\n      sideEffects.push('invoice_generation');\n      break;\n      \n    case NEGOTIATION_STATES.INVOICE_GENERATED:\n      // Queue e-Factura submission\n      const efacturaQueue = createEtapa3Queue(ETAPA3_QUEUES.EFACTURA_SUBMIT);\n      await efacturaQueue.add('submit', { tenantId, negotiationId });\n      sideEffects.push('efactura_submission');\n      break;\n      \n    case NEGOTIATION_STATES.REQUIRES_HUMAN:\n      // Queue HITL escalation\n      const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n      await hitlQueue.add('escalate', {\n        tenantId,\n        negotiationId,\n        reason: 'manual_state_transition',\n        priority: 'high'\n      });\n      sideEffects.push('hitl_escalation');\n      break;\n      \n    case NEGOTIATION_STATES.WON:\n    case NEGOTIATION_STATES.LOST:\n    case NEGOTIATION_STATES.ABANDONED:\n      // Queue analytics and archival\n      const analyticsQueue = createEtapa3Queue(ETAPA3_QUEUES.NEG_ANALYTICS);\n      await analyticsQueue.add('calculate', { tenantId, negotiationId, outcome: newState });\n      sideEffects.push('analytics_calculation');\n      \n      // Archive after delay\n      const archiveQueue = createEtapa3Queue(ETAPA3_QUEUES.NEG_ARCHIVE);\n      await archiveQueue.add('archive', { tenantId, negotiationId }, {\n        delay: 7 * 24 * 60 * 60 * 1000 // 7 days\n      });\n      sideEffects.push('archive_scheduled');\n      break;\n      \n    case NEGOTIATION_STATES.PENDING_APPROVAL:\n      // Notify approvers\n      const notifyQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_NOTIFY);\n      await notifyQueue.add('notify-approvers', {\n        tenantId,\n        negotiationId,\n        approvalType: 'discount',\n        discountPercent: negotiation.discountPercent\n      });\n      sideEffects.push('approver_notification');\n      break;\n  }\n  \n  return sideEffects;\n}\n\nexport const negTransitionWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.NEG_TRANSITION,\n  processNegTransition,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-d",
  "restrictii_antihalucinatie": [
    "VALIDEAZĂ tranziția contra NEGOTIATION_TRANSITIONS - nu permite invalid",
    "LOGHEAZĂ fiecare tranziție în state_transitions pentru audit",
    "TRIGGER side effects automat pe stări specifice",
    "INCLUDE version pentru optimistic locking",
    "EMIT event pentru subscribers"
  ],
  "validare_task": "1. Validare tranziții contra FSM definition\n2. Atomic update cu transaction\n3. Audit log în state_transitions\n4. Side effects triggered corect\n5. Metrics pentru toate tranzițiile",
  "outcome": "Worker neg:transition funcțional pentru tranziții FSM validate cu side effects automate"
}
```

---

# FAZA F3.6: PRICING & DISCOUNT WORKERS (CATEGORIA E)

## F3.6.1 Price Calculate Worker (#27)

```json
{
  "taskID": "F3.6.1.T001",
  "denumire_task": "Implementare worker price:calculate pentru calcul prețuri validate",
  "context_anterior": "Negotiation FSM workers complete. Acum implementăm workerul pentru calculul prețurilor - critic pentru guardrail anti-halucinație.",
  "descriere_task": "Ești un expert în pricing engines B2B. Task-ul tău este să creezi workerul pentru calculul prețurilor cu toate regulile de business.\n\nCreează fișierul /packages/workers/src/etapa3/category-e/price-calculate.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products, priceHistory, discountRules } from '@cerniq/db/schema';\nimport { eq, and } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport Decimal from 'decimal.js';\n\nconst PriceCalculatePayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid().optional(),\n  contactId: z.string().uuid().optional(),\n  items: z.array(z.object({\n    productId: z.string().uuid().optional(),\n    sku: z.string().optional(),\n    quantity: z.number().positive(),\n    requestedDiscount: z.number().min(0).max(100).optional()\n  })),\n  options: z.object({\n    applyVolumeDiscounts: z.boolean().default(true),\n    applyCustomerDiscounts: z.boolean().default(true),\n    currency: z.string().default('RON'),\n    priceDate: z.string().datetime().optional() // For historical pricing\n  }).optional()\n});\n\ntype PriceCalculateJob = z.infer<typeof PriceCalculatePayload>;\n\ninterface LineItemPrice {\n  productId: string;\n  sku: string;\n  name: string;\n  quantity: number;\n  unitPrice: number;\n  unitPriceWithVat: number;\n  vatRate: number;\n  \n  // Discounts\n  volumeDiscountPercent: number;\n  volumeDiscountAmount: number;\n  customerDiscountPercent: number;\n  customerDiscountAmount: number;\n  requestedDiscountPercent: number;\n  requestedDiscountAmount: number;\n  totalDiscountPercent: number;\n  totalDiscountAmount: number;\n  \n  // Calculated\n  lineSubtotal: number;\n  lineVat: number;\n  lineTotal: number;\n  \n  // Guardrail info\n  minAllowedPrice: number;\n  maxAllowedDiscount: number;\n  marginPercent: number;\n  \n  // Validation\n  isValid: boolean;\n  validationErrors: string[];\n}\n\ninterface PriceCalculationResult {\n  success: boolean;\n  items: LineItemPrice[];\n  summary: {\n    subtotal: number;\n    totalVat: number;\n    totalDiscount: number;\n    grandTotal: number;\n    currency: string;\n    averageMargin: number;\n  };\n  guardrails: {\n    allPricesValid: boolean;\n    allDiscountsWithinLimits: boolean;\n    minimumMarginMet: boolean;\n    issues: string[];\n  };\n}\n\nasync function processPriceCalculate(job: Job<PriceCalculateJob>): Promise<PriceCalculationResult> {\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  const { tenantId, contactId, items, options } = job.data;\n  \n  log.info('Calculating prices', { itemCount: items.length });\n  \n  const calculatedItems: LineItemPrice[] = [];\n  const guardrailIssues: string[] = [];\n  \n  // Load customer-specific discounts if applicable\n  let customerDiscount = 0;\n  if (contactId && options?.applyCustomerDiscounts !== false) {\n    const customerRule = await db.query.discountRules.findFirst({\n      where: and(\n        eq(discountRules.tenantId, tenantId),\n        eq(discountRules.contactId, contactId),\n        eq(discountRules.isActive, true)\n      )\n    });\n    customerDiscount = customerRule ? parseFloat(customerRule.discountPercent) : 0;\n  }\n  \n  for (const item of items) {\n    // Load product\n    const product = await db.query.products.findFirst({\n      where: and(\n        eq(products.tenantId, tenantId),\n        item.productId ? eq(products.id, item.productId) : eq(products.sku, item.sku!)\n      )\n    });\n    \n    if (!product) {\n      calculatedItems.push({\n        productId: item.productId || '',\n        sku: item.sku || '',\n        name: 'PRODUCT NOT FOUND',\n        quantity: item.quantity,\n        unitPrice: 0,\n        unitPriceWithVat: 0,\n        vatRate: 0,\n        volumeDiscountPercent: 0,\n        volumeDiscountAmount: 0,\n        customerDiscountPercent: 0,\n        customerDiscountAmount: 0,\n        requestedDiscountPercent: 0,\n        requestedDiscountAmount: 0,\n        totalDiscountPercent: 0,\n        totalDiscountAmount: 0,\n        lineSubtotal: 0,\n        lineVat: 0,\n        lineTotal: 0,\n        minAllowedPrice: 0,\n        maxAllowedDiscount: 0,\n        marginPercent: 0,\n        isValid: false,\n        validationErrors: ['Product not found']\n      });\n      guardrailIssues.push(`SKU ${item.sku || item.productId}: Product not found`);\n      continue;\n    }\n    \n    // Use Decimal.js for precision\n    const basePrice = new Decimal(product.basePrice);\n    const vatRate = new Decimal(product.vatRate);\n    const costPrice = product.costPrice ? new Decimal(product.costPrice) : basePrice.mul(0.7);\n    const maxDiscountPercent = new Decimal(product.maxDiscountPercent || 0);\n    const quantity = new Decimal(item.quantity);\n    \n    // Calculate volume discount\n    let volumeDiscountPercent = new Decimal(0);\n    if (options?.applyVolumeDiscounts !== false && product.volumeDiscounts) {\n      const volumeDiscounts = product.volumeDiscounts as Array<{ minQty: number; discount: number }>;\n      const applicableDiscount = volumeDiscounts\n        .filter(vd => item.quantity >= vd.minQty)\n        .sort((a, b) => b.minQty - a.minQty)[0];\n      if (applicableDiscount) {\n        volumeDiscountPercent = new Decimal(applicableDiscount.discount);\n      }\n    }\n    \n    // Calculate total discount\n    const customerDiscountDec = new Decimal(customerDiscount);\n    const requestedDiscountDec = new Decimal(item.requestedDiscount || 0);\n    \n    // Combine discounts (not additive - applied sequentially)\n    // Total = base * (1 - volume) * (1 - customer) * (1 - requested)\n    const combinedFactor = new Decimal(1)\n      .minus(volumeDiscountPercent.div(100))\n      .mul(new Decimal(1).minus(customerDiscountDec.div(100)))\n      .mul(new Decimal(1).minus(requestedDiscountDec.div(100)));\n    \n    const effectiveDiscountPercent = new Decimal(1).minus(combinedFactor).mul(100);\n    \n    // Calculate unit price after discounts\n    const discountedPrice = basePrice.mul(combinedFactor);\n    const unitPriceWithVat = discountedPrice.mul(new Decimal(1).plus(vatRate.div(100)));\n    \n    // Calculate minimum allowed price (for guardrails)\n    const minAllowedPrice = basePrice.mul(new Decimal(1).minus(maxDiscountPercent.div(100)));\n    \n    // Calculate margin\n    const marginPercent = discountedPrice.minus(costPrice).div(discountedPrice).mul(100);\n    \n    // Validation\n    const validationErrors: string[] = [];\n    let isValid = true;\n    \n    if (discountedPrice.lt(minAllowedPrice)) {\n      validationErrors.push(`Price ${discountedPrice.toFixed(2)} below minimum ${minAllowedPrice.toFixed(2)}`);\n      guardrailIssues.push(`SKU ${product.sku}: Discount exceeds maximum allowed (${effectiveDiscountPercent.toFixed(1)}% > ${maxDiscountPercent.toFixed(1)}%)`);\n      isValid = false;\n    }\n    \n    if (marginPercent.lt(5)) { // Minimum 5% margin\n      validationErrors.push(`Margin ${marginPercent.toFixed(1)}% below minimum 5%`);\n      guardrailIssues.push(`SKU ${product.sku}: Margin too low (${marginPercent.toFixed(1)}%)`);\n      isValid = false;\n    }\n    \n    // Calculate line totals\n    const lineSubtotal = discountedPrice.mul(quantity);\n    const lineVat = lineSubtotal.mul(vatRate.div(100));\n    const lineTotal = lineSubtotal.plus(lineVat);\n    const totalDiscountAmount = basePrice.minus(discountedPrice).mul(quantity);\n    \n    calculatedItems.push({\n      productId: product.id,\n      sku: product.sku,\n      name: product.name,\n      quantity: item.quantity,\n      unitPrice: discountedPrice.toNumber(),\n      unitPriceWithVat: unitPriceWithVat.toNumber(),\n      vatRate: vatRate.toNumber(),\n      volumeDiscountPercent: volumeDiscountPercent.toNumber(),\n      volumeDiscountAmount: basePrice.mul(volumeDiscountPercent.div(100)).mul(quantity).toNumber(),\n      customerDiscountPercent: customerDiscount,\n      customerDiscountAmount: basePrice.mul(customerDiscountDec.div(100)).mul(quantity).toNumber(),\n      requestedDiscountPercent: item.requestedDiscount || 0,\n      requestedDiscountAmount: basePrice.mul(requestedDiscountDec.div(100)).mul(quantity).toNumber(),\n      totalDiscountPercent: effectiveDiscountPercent.toNumber(),\n      totalDiscountAmount: totalDiscountAmount.toNumber(),\n      lineSubtotal: lineSubtotal.toNumber(),\n      lineVat: lineVat.toNumber(),\n      lineTotal: lineTotal.toNumber(),\n      minAllowedPrice: minAllowedPrice.toNumber(),\n      maxAllowedDiscount: maxDiscountPercent.toNumber(),\n      marginPercent: marginPercent.toNumber(),\n      isValid,\n      validationErrors\n    });\n  }\n  \n  // Calculate summary\n  const subtotal = calculatedItems.reduce((sum, item) => sum + item.lineSubtotal, 0);\n  const totalVat = calculatedItems.reduce((sum, item) => sum + item.lineVat, 0);\n  const totalDiscount = calculatedItems.reduce((sum, item) => sum + item.totalDiscountAmount, 0);\n  const grandTotal = calculatedItems.reduce((sum, item) => sum + item.lineTotal, 0);\n  const averageMargin = calculatedItems.length > 0\n    ? calculatedItems.reduce((sum, item) => sum + item.marginPercent, 0) / calculatedItems.length\n    : 0;\n  \n  const result: PriceCalculationResult = {\n    success: guardrailIssues.length === 0,\n    items: calculatedItems,\n    summary: {\n      subtotal: Math.round(subtotal * 100) / 100,\n      totalVat: Math.round(totalVat * 100) / 100,\n      totalDiscount: Math.round(totalDiscount * 100) / 100,\n      grandTotal: Math.round(grandTotal * 100) / 100,\n      currency: options?.currency || 'RON',\n      averageMargin: Math.round(averageMargin * 100) / 100\n    },\n    guardrails: {\n      allPricesValid: calculatedItems.every(item => item.isValid),\n      allDiscountsWithinLimits: guardrailIssues.filter(i => i.includes('Discount')).length === 0,\n      minimumMarginMet: averageMargin >= 5,\n      issues: guardrailIssues\n    }\n  };\n  \n  log.info('Price calculation completed', {\n    itemCount: items.length,\n    grandTotal: result.summary.grandTotal,\n    guardrailsPassed: result.success\n  });\n  \n  return result;\n}\n\nexport const priceCalculateWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.PRICE_CALCULATE,\n  processPriceCalculate,\n  {\n    concurrency: 20,\n    limiter: {\n      max: 100,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-e",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE Decimal.js pentru precizie financiară",
    "NU permite preț sub minAllowedPrice",
    "VALIDEAZĂ marjă minimă 5%",
    "INCLUDE toate tipurile de discount (volume, customer, requested)",
    "RETURNEAZĂ detalii complete pentru audit"
  ],
  "validare_task": "1. Calcul cu Decimal.js pentru precizie\n2. Volume discounts aplicate corect\n3. Guardrail checks pentru preț minim și marjă\n4. Summary totalizat corect\n5. Validation errors detaliate",
  "outcome": "Worker price:calculate funcțional pentru calcul prețuri validate cu guardrails"
}
```

---

# FAZA F3.8: OBLIO INTEGRATION WORKERS (CATEGORIA G)

## F3.8.1 Oblio Invoice Worker (#41)

```json
{
  "taskID": "F3.8.1.T001",
  "denumire_task": "Implementare worker oblio:invoice pentru generare facturi via Oblio API",
  "context_anterior": "Pricing workers complete. Acum implementăm integrarea cu Oblio.eu pentru generare facturi.",
  "descriere_task": "Ești un expert în integrări API facturare. Task-ul tău este să creezi workerul pentru generare facturi prin Oblio API.\n\nCreează fișierul /packages/workers/src/etapa3/category-g/oblio-invoice.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { invoices, invoiceItems, negotiations, contactsGold, tenants } from '@cerniq/db/schema';\nimport { eq, and } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport axios from 'axios';\nimport { metrics } from '@cerniq/metrics';\n\n// Oblio API client\nclass OblioClient {\n  private baseUrl = 'https://www.oblio.eu/api';\n  private email: string;\n  private secret: string;\n  private accessToken?: string;\n  private tokenExpiry?: Date;\n  \n  constructor(email: string, secret: string) {\n    this.email = email;\n    this.secret = secret;\n  }\n  \n  async authenticate(): Promise<void> {\n    if (this.accessToken && this.tokenExpiry && this.tokenExpiry > new Date()) {\n      return;\n    }\n    \n    const response = await axios.post(`${this.baseUrl}/authorize/token`, {\n      email: this.email,\n      secret: this.secret\n    });\n    \n    this.accessToken = response.data.access_token;\n    this.tokenExpiry = new Date(Date.now() + 3600 * 1000); // 1 hour\n  }\n  \n  async createInvoice(data: OblioInvoiceData): Promise<OblioInvoiceResponse> {\n    await this.authenticate();\n    \n    const response = await axios.post(`${this.baseUrl}/docs/invoice`, data, {\n      headers: {\n        Authorization: `Bearer ${this.accessToken}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    return response.data;\n  }\n}\n\ninterface OblioInvoiceData {\n  cif: string;\n  client: {\n    cif: string;\n    name: string;\n    rc: string;\n    address: string;\n    city: string;\n    county: string;\n    country: string;\n    email?: string;\n    phone?: string;\n    contact?: string;\n    isTaxPayer: boolean;\n    bank?: string;\n    iban?: string;\n  };\n  seriesName: string;\n  issueDate: string;\n  dueDate?: string;\n  deliveryDate?: string;\n  products: Array<{\n    name: string;\n    code?: string;\n    description?: string;\n    unit: string;\n    quantity: number;\n    price: number;\n    vatName: string;\n    vatPercentage: number;\n    discount?: number;\n  }>;\n  paymentType?: string;\n  mentionClient?: string;\n  mentionIssuer?: string;\n}\n\ninterface OblioInvoiceResponse {\n  success: boolean;\n  statusCode: number;\n  data: {\n    seriesName: string;\n    number: string;\n    link: string;\n  };\n}\n\nconst OblioInvoicePayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  seriesName: z.string().optional(),\n  issueDate: z.string().datetime().optional(),\n  dueDate: z.string().datetime().optional(),\n  mentionClient: z.string().optional()\n});\n\ntype OblioInvoiceJob = z.infer<typeof OblioInvoicePayload>;\n\nasync function processOblioInvoice(job: Job<OblioInvoiceJob>): Promise<any> {\n  const log = logger.child({ jobId: job.id, negotiationId: job.data.negotiationId });\n  const { tenantId, negotiationId, seriesName, issueDate, dueDate, mentionClient } = job.data;\n  \n  log.info('Generating Oblio invoice');\n  \n  try {\n    // Load tenant configuration\n    const tenant = await db.query.tenants.findFirst({\n      where: eq(tenants.id, tenantId)\n    });\n    \n    if (!tenant?.oblioEmail || !tenant?.oblioSecret) {\n      throw new Error('Oblio credentials not configured for tenant');\n    }\n    \n    // Load negotiation with products\n    const negotiation = await db.query.negotiations.findFirst({\n      where: eq(negotiations.id, negotiationId),\n      with: {\n        contact: true\n      }\n    });\n    \n    if (!negotiation) {\n      throw new Error(`Negotiation not found: ${negotiationId}`);\n    }\n    \n    const contact = negotiation.contact;\n    \n    // Validate client has required fiscal data\n    if (!contact.cui || !contact.companyName) {\n      throw new Error('Contact missing required fiscal data (CUI, company name)');\n    }\n    \n    // Build Oblio client data\n    const clientData = {\n      cif: contact.cui,\n      name: contact.companyName,\n      rc: contact.regCom || '',\n      address: contact.address || 'N/A',\n      city: contact.city || 'N/A',\n      county: contact.county || 'N/A',\n      country: 'RO',\n      email: contact.email,\n      phone: contact.phone,\n      isTaxPayer: contact.vatPayer || false,\n      iban: contact.iban,\n      bank: contact.bank\n    };\n    \n    // Build products from negotiation\n    const products = (negotiation.products as any[]).map(p => ({\n      name: p.name,\n      code: p.sku,\n      description: p.description?.slice(0, 200),\n      unit: p.unitOfMeasure || 'BUC',\n      quantity: p.quantity,\n      price: p.unitPrice,\n      vatName: 'Normala',\n      vatPercentage: p.vatRate || 19,\n      discount: p.discountPercent || 0\n    }));\n    \n    // Initialize Oblio client\n    const oblioClient = new OblioClient(tenant.oblioEmail, tenant.oblioSecret);\n    \n    // Create invoice in Oblio\n    const oblioResponse = await oblioClient.createInvoice({\n      cif: tenant.cui,\n      client: clientData,\n      seriesName: seriesName || tenant.defaultInvoiceSeries || 'FACT',\n      issueDate: issueDate || new Date().toISOString().split('T')[0],\n      dueDate: dueDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n      deliveryDate: new Date().toISOString().split('T')[0],\n      products,\n      paymentType: 'OP', // Ordin de plata\n      mentionClient: mentionClient || 'Mulțumim pentru achiziție!'\n    });\n    \n    if (!oblioResponse.success) {\n      throw new Error(`Oblio API error: ${JSON.stringify(oblioResponse)}`);\n    }\n    \n    log.info('Oblio invoice created', { \n      series: oblioResponse.data.seriesName, \n      number: oblioResponse.data.number \n    });\n    \n    // Calculate totals\n    const subtotal = products.reduce((sum, p) => sum + (p.quantity * p.price * (1 - (p.discount || 0) / 100)), 0);\n    const vatAmount = products.reduce((sum, p) => {\n      const lineSubtotal = p.quantity * p.price * (1 - (p.discount || 0) / 100);\n      return sum + (lineSubtotal * p.vatPercentage / 100);\n    }, 0);\n    \n    // Create invoice record in our database\n    const invoice = await db.insert(invoices).values({\n      tenantId,\n      negotiationId,\n      contactId: contact.id,\n      documentType: 'invoice',\n      series: oblioResponse.data.seriesName,\n      number: parseInt(oblioResponse.data.number),\n      documentNumber: `${oblioResponse.data.seriesName}-${oblioResponse.data.number}`,\n      issueDate: new Date(issueDate || new Date()),\n      dueDate: dueDate ? new Date(dueDate) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n      supplierName: tenant.companyName,\n      supplierCui: tenant.cui,\n      supplierRegCom: tenant.regCom,\n      supplierAddress: tenant.address,\n      supplierCity: tenant.city,\n      supplierCounty: tenant.county,\n      supplierCountry: 'RO',\n      supplierIban: tenant.iban,\n      supplierBank: tenant.bank,\n      supplierVatPayer: true,\n      clientName: contact.companyName,\n      clientCui: contact.cui,\n      clientRegCom: contact.regCom,\n      clientAddress: contact.address || 'N/A',\n      clientCity: contact.city || 'N/A',\n      clientCounty: contact.county || 'N/A',\n      clientCountry: 'RO',\n      clientEmail: contact.email,\n      clientPhone: contact.phone,\n      clientVatPayer: contact.vatPayer || false,\n      subtotal: subtotal.toFixed(2),\n      vatAmount: vatAmount.toFixed(2),\n      totalAmount: (subtotal + vatAmount).toFixed(2),\n      currency: 'RON',\n      discountPercent: negotiation.discountPercent,\n      oblioId: `${oblioResponse.data.seriesName}-${oblioResponse.data.number}`,\n      oblioSeriesName: oblioResponse.data.seriesName,\n      oblioDocumentLink: oblioResponse.data.link,\n      oblioSyncedAt: new Date(),\n      status: 'issued',\n      efacturaRequired: parseFloat(subtotal.toFixed(2)) >= 5000, // Required for B2B > 5000 RON\n      createdBy: null // AI generated\n    }).returning();\n    \n    // Create invoice items\n    for (let i = 0; i < products.length; i++) {\n      const p = products[i];\n      const lineSubtotal = p.quantity * p.price * (1 - (p.discount || 0) / 100);\n      const lineVat = lineSubtotal * p.vatPercentage / 100;\n      \n      await db.insert(invoiceItems).values({\n        invoiceId: invoice[0].id,\n        productId: (negotiation.products as any[])[i].productId,\n        lineNumber: i + 1,\n        sku: p.code,\n        name: p.name,\n        description: p.description,\n        unitOfMeasure: p.unit,\n        quantity: p.quantity.toString(),\n        unitPrice: p.price.toString(),\n        unitPriceWithoutVat: p.price.toString(),\n        discountPercent: (p.discount || 0).toString(),\n        lineSubtotal: lineSubtotal.toFixed(2),\n        vatRate: p.vatPercentage.toString(),\n        vatAmount: lineVat.toFixed(2),\n        lineTotal: (lineSubtotal + lineVat).toFixed(2),\n        vatCategory: 'S',\n        sortOrder: i + 1\n      });\n    }\n    \n    // Update negotiation state\n    const transitionQueue = createEtapa3Queue(ETAPA3_QUEUES.NEG_TRANSITION);\n    await transitionQueue.add('transition', {\n      tenantId,\n      negotiationId,\n      fromState: negotiation.currentState,\n      toState: 'INVOICE_GENERATED',\n      reason: 'Oblio invoice created',\n      triggeredBy: 'system'\n    });\n    \n    // Queue e-Factura if required\n    if (invoice[0].efacturaRequired) {\n      const efacturaQueue = createEtapa3Queue(ETAPA3_QUEUES.EFACTURA_GENERATE);\n      await efacturaQueue.add('generate', {\n        tenantId,\n        invoiceId: invoice[0].id\n      }, { delay: 5000 }); // 5 second delay\n    }\n    \n    metrics.invoicesCreated.inc({ type: 'invoice', via: 'oblio' });\n    \n    return {\n      success: true,\n      invoiceId: invoice[0].id,\n      documentNumber: invoice[0].documentNumber,\n      oblioLink: oblioResponse.data.link,\n      efacturaRequired: invoice[0].efacturaRequired\n    };\n    \n  } catch (error) {\n    log.error('Failed to create Oblio invoice', { error });\n    metrics.invoiceErrors.inc({ type: 'invoice', via: 'oblio' });\n    \n    // Queue retry or HITL\n    if (job.attemptsMade < 3) {\n      throw error; // BullMQ will retry\n    }\n    \n    // Escalate to HITL\n    const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n    await hitlQueue.add('escalate', {\n      tenantId,\n      negotiationId,\n      reason: 'oblio_invoice_failed',\n      errorDetails: error instanceof Error ? error.message : 'Unknown error',\n      priority: 'high'\n    });\n    \n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\nexport const oblioInvoiceWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.OBLIO_INVOICE,\n  processOblioInvoice,\n  {\n    concurrency: 3,\n    limiter: {\n      max: 10,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-g",
  "restrictii_antihalucinatie": [
    "VALIDEAZĂ date fiscale client înainte de submit",
    "NU hardcoda credențiale Oblio - din tenant config",
    "SINCRONIZEAZĂ factură în DB local pentru audit",
    "QUEUE e-Factura automat dacă > 5000 RON B2B",
    "ESCALARE HITL după 3 retry failures"
  ],
  "validare_task": "1. Autentificare Oblio cu token refresh\n2. Validare date fiscale complete\n3. Creare factură în Oblio API\n4. Sincronizare în DB local\n5. Auto-queue e-Factura dacă necesar",
  "outcome": "Worker oblio:invoice funcțional pentru generare facturi via Oblio API"
}
```

---

# FAZA F3.3: HYBRID SEARCH RAG WORKERS (CATEGORIA B)

## F3.3.1 Semantic Search Worker (#7)

```json
{
  "taskID": "F3.3.1.T001",
  "denumire_task": "Implementare worker rag:semantic-search pentru căutare vectorială",
  "context_anterior": "Product knowledge workers finalizați cu embeddings generate. Acum implementăm căutarea semantică pentru RAG.",
  "descriere_task": "Ești un expert în vector search și RAG systems. Task-ul tău este să creezi workerul pentru căutare semantică folosind pgvector.\n\nCreează fișierul /packages/workers/src/etapa3/category-b/rag-semantic-search.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products } from '@cerniq/db/schema';\nimport { eq, sql, and, gt } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { openai } from '@cerniq/ai-providers';\nimport { metrics } from '@cerniq/metrics';\nimport { redis } from '@cerniq/cache';\n\nconst SemanticSearchPayload = z.object({\n  tenantId: z.string().uuid(),\n  query: z.string().min(1).max(1000),\n  topK: z.number().min(1).max(50).default(10),\n  minSimilarity: z.number().min(0).max(1).default(0.7),\n  filters: z.object({\n    categoryIds: z.array(z.string().uuid()).optional(),\n    brands: z.array(z.string()).optional(),\n    cropTypes: z.array(z.string()).optional(),\n    priceRange: z.object({\n      min: z.number().optional(),\n      max: z.number().optional()\n    }).optional(),\n    inStock: z.boolean().optional()\n  }).optional(),\n  options: z.object({\n    includeContent: z.boolean().default(true),\n    includeSimilarityScore: z.boolean().default(true),\n    useCache: z.boolean().default(true),\n    cacheTTL: z.number().default(300) // 5 minutes\n  }).optional()\n});\n\ntype SemanticSearchJob = z.infer<typeof SemanticSearchPayload>;\n\ninterface SemanticSearchResult {\n  success: boolean;\n  results: Array<{\n    productId: string;\n    sku: string;\n    name: string;\n    nameRo?: string;\n    description?: string;\n    similarity: number;\n    categoryPath?: string;\n    basePrice: number;\n    priceWithVat: number;\n    currentStock: number;\n    cropType?: string;\n    brand?: string;\n    aiSummary?: string;\n  }>;\n  query: string;\n  totalFound: number;\n  searchLatencyMs: number;\n  embeddingLatencyMs: number;\n  cacheHit: boolean;\n}\n\nasync function processSemanticSearch(job: Job<SemanticSearchJob>): Promise<SemanticSearchResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { tenantId, query, topK, minSimilarity, filters, options } = job.data;\n  \n  log.info('Starting semantic search', { query: query.slice(0, 100), topK });\n  \n  // Check cache first\n  const cacheKey = `semantic-search:${tenantId}:${hashQuery(query, filters)}`;\n  \n  if (options?.useCache !== false) {\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n      log.info('Cache hit', { cacheKey });\n      metrics.semanticSearchCacheHit.inc();\n      return { ...JSON.parse(cached), cacheHit: true };\n    }\n  }\n  \n  // Generate embedding for query\n  const embeddingStart = Date.now();\n  const embeddingResponse = await openai.embeddings.create({\n    model: 'text-embedding-3-small',\n    input: query,\n    dimensions: 1536\n  });\n  const embeddingLatencyMs = Date.now() - embeddingStart;\n  \n  const queryEmbedding = embeddingResponse.data[0].embedding;\n  \n  // Build dynamic WHERE conditions\n  const whereConditions = [eq(products.tenantId, tenantId)];\n  \n  if (filters?.categoryIds?.length) {\n    whereConditions.push(sql`${products.categoryId} = ANY(${filters.categoryIds})`);\n  }\n  if (filters?.brands?.length) {\n    whereConditions.push(sql`${products.brand} = ANY(${filters.brands})`);\n  }\n  if (filters?.cropTypes?.length) {\n    whereConditions.push(sql`${products.cropType} = ANY(${filters.cropTypes})`);\n  }\n  if (filters?.priceRange?.min !== undefined) {\n    whereConditions.push(gt(products.basePrice, filters.priceRange.min.toString()));\n  }\n  if (filters?.priceRange?.max !== undefined) {\n    whereConditions.push(sql`${products.basePrice} <= ${filters.priceRange.max}`);\n  }\n  if (filters?.inStock) {\n    whereConditions.push(gt(products.availableStock, 0));\n  }\n  \n  // Execute vector search with pgvector\n  const searchStart = Date.now();\n  const results = await db.execute(sql`\n    SELECT \n      id as \"productId\",\n      sku,\n      name,\n      name_ro as \"nameRo\",\n      description,\n      1 - (embedding <=> ${JSON.stringify(queryEmbedding)}::vector) as similarity,\n      base_price as \"basePrice\",\n      price_with_vat as \"priceWithVat\",\n      current_stock as \"currentStock\",\n      crop_type as \"cropType\",\n      brand,\n      ai_summary as \"aiSummary\"\n    FROM products\n    WHERE ${and(...whereConditions)}\n      AND embedding IS NOT NULL\n      AND 1 - (embedding <=> ${JSON.stringify(queryEmbedding)}::vector) >= ${minSimilarity}\n    ORDER BY embedding <=> ${JSON.stringify(queryEmbedding)}::vector\n    LIMIT ${topK}\n  `);\n  const searchLatencyMs = Date.now() - searchStart;\n  \n  const searchResults = (results.rows || []).map((row: any) => ({\n    productId: row.productId,\n    sku: row.sku,\n    name: row.name,\n    nameRo: row.nameRo,\n    description: options?.includeContent ? row.description : undefined,\n    similarity: options?.includeSimilarityScore ? parseFloat(row.similarity) : undefined,\n    basePrice: parseFloat(row.basePrice),\n    priceWithVat: parseFloat(row.priceWithVat),\n    currentStock: parseInt(row.currentStock),\n    cropType: row.cropType,\n    brand: row.brand,\n    aiSummary: row.aiSummary\n  }));\n  \n  const response: SemanticSearchResult = {\n    success: true,\n    results: searchResults,\n    query,\n    totalFound: searchResults.length,\n    searchLatencyMs,\n    embeddingLatencyMs,\n    cacheHit: false\n  };\n  \n  // Cache results\n  if (options?.useCache !== false && searchResults.length > 0) {\n    await redis.setex(cacheKey, options?.cacheTTL || 300, JSON.stringify(response));\n  }\n  \n  // Update metrics\n  metrics.semanticSearchLatency.observe(Date.now() - startTime);\n  metrics.semanticSearchResults.observe(searchResults.length);\n  \n  log.info('Semantic search completed', {\n    totalFound: searchResults.length,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return response;\n}\n\nfunction hashQuery(query: string, filters?: any): string {\n  const crypto = require('crypto');\n  const data = JSON.stringify({ query: query.toLowerCase().trim(), filters });\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\nexport const ragSemanticSearchWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.RAG_SEMANTIC_SEARCH,\n  processSemanticSearch,\n  {\n    concurrency: 15,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-b",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE pgvector cu operatorul <=> pentru cosine distance",
    "NU returnez embedding-uri în rezultate - doar similarity score",
    "CACHE cu TTL scurt (5 min) pentru queries frecvente",
    "VALIDEAZĂ minSimilarity pentru calitate rezultate",
    "INCLUDE latency tracking pentru optimizare"
  ],
  "validare_task": "1. Embedding generation cu OpenAI\n2. Vector search cu pgvector HNSW\n3. Filtre dinamice funcționale\n4. Caching cu Redis\n5. Metrics pentru latency și rezultate",
  "outcome": "Worker rag:semantic-search funcțional pentru căutare vectorială cu pgvector"
}
```

## F3.3.2 Keyword Search Worker (#8)

```json
{
  "taskID": "F3.3.2.T001",
  "denumire_task": "Implementare worker rag:keyword-search pentru full-text search",
  "context_anterior": "Semantic search worker implementat. Acum implementăm keyword search pentru complementare.",
  "descriere_task": "Ești un expert în PostgreSQL full-text search. Task-ul tău este să creezi workerul pentru căutare pe cuvinte cheie.\n\nCreează fișierul /packages/workers/src/etapa3/category-b/rag-keyword-search.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products } from '@cerniq/db/schema';\nimport { eq, sql, and, gt } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { redis } from '@cerniq/cache';\n\nconst KeywordSearchPayload = z.object({\n  tenantId: z.string().uuid(),\n  query: z.string().min(1).max(500),\n  topK: z.number().min(1).max(50).default(10),\n  searchFields: z.array(z.enum(['name', 'nameRo', 'description', 'sku', 'brand', 'searchKeywords']))\n    .default(['name', 'nameRo', 'searchKeywords']),\n  fuzzyMatch: z.boolean().default(true),\n  language: z.enum(['romanian', 'english', 'simple']).default('romanian'),\n  filters: z.object({\n    categoryIds: z.array(z.string().uuid()).optional(),\n    brands: z.array(z.string()).optional(),\n    priceRange: z.object({\n      min: z.number().optional(),\n      max: z.number().optional()\n    }).optional(),\n    inStock: z.boolean().optional()\n  }).optional(),\n  options: z.object({\n    highlightResults: z.boolean().default(false),\n    useCache: z.boolean().default(true),\n    cacheTTL: z.number().default(300)\n  }).optional()\n});\n\ntype KeywordSearchJob = z.infer<typeof KeywordSearchPayload>;\n\ninterface KeywordSearchResult {\n  success: boolean;\n  results: Array<{\n    productId: string;\n    sku: string;\n    name: string;\n    nameRo?: string;\n    description?: string;\n    rank: number;\n    headline?: string;\n    basePrice: number;\n    priceWithVat: number;\n    currentStock: number;\n    brand?: string;\n  }>;\n  query: string;\n  parsedQuery: string;\n  totalFound: number;\n  searchLatencyMs: number;\n  cacheHit: boolean;\n}\n\nasync function processKeywordSearch(job: Job<KeywordSearchJob>): Promise<KeywordSearchResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { tenantId, query, topK, searchFields, fuzzyMatch, language, filters, options } = job.data;\n  \n  log.info('Starting keyword search', { query, topK });\n  \n  // Check cache\n  const cacheKey = `keyword-search:${tenantId}:${hashQuery(query, filters, searchFields)}`;\n  \n  if (options?.useCache !== false) {\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n      log.info('Cache hit');\n      metrics.keywordSearchCacheHit.inc();\n      return { ...JSON.parse(cached), cacheHit: true };\n    }\n  }\n  \n  // Parse and normalize query for PostgreSQL ts_query\n  const parsedQuery = parseSearchQuery(query, fuzzyMatch);\n  \n  // Build search vector column expression\n  const searchVector = buildSearchVector(searchFields, language);\n  \n  // Build WHERE conditions\n  const whereConditions = [eq(products.tenantId, tenantId)];\n  \n  if (filters?.categoryIds?.length) {\n    whereConditions.push(sql`${products.categoryId} = ANY(${filters.categoryIds})`);\n  }\n  if (filters?.brands?.length) {\n    whereConditions.push(sql`${products.brand} = ANY(${filters.brands})`);\n  }\n  if (filters?.priceRange?.min !== undefined) {\n    whereConditions.push(gt(products.basePrice, filters.priceRange.min.toString()));\n  }\n  if (filters?.priceRange?.max !== undefined) {\n    whereConditions.push(sql`${products.basePrice} <= ${filters.priceRange.max}`);\n  }\n  if (filters?.inStock) {\n    whereConditions.push(gt(products.availableStock, 0));\n  }\n  \n  // Execute full-text search\n  const searchQuery = sql`\n    SELECT \n      id as \"productId\",\n      sku,\n      name,\n      name_ro as \"nameRo\",\n      description,\n      ts_rank_cd(${searchVector}, to_tsquery('${sql.raw(language)}', ${parsedQuery})) as rank,\n      ${options?.highlightResults ? sql`ts_headline('${sql.raw(language)}', name || ' ' || COALESCE(description, ''), to_tsquery('${sql.raw(language)}', ${parsedQuery}), 'MaxWords=35, MinWords=15, StartSel=<mark>, StopSel=</mark>') as headline,` : sql``}\n      base_price as \"basePrice\",\n      price_with_vat as \"priceWithVat\",\n      current_stock as \"currentStock\",\n      brand\n    FROM products\n    WHERE ${and(...whereConditions)}\n      AND ${searchVector} @@ to_tsquery('${sql.raw(language)}', ${parsedQuery})\n    ORDER BY rank DESC\n    LIMIT ${topK}\n  `;\n  \n  const results = await db.execute(searchQuery);\n  const searchLatencyMs = Date.now() - startTime;\n  \n  const searchResults = (results.rows || []).map((row: any) => ({\n    productId: row.productId,\n    sku: row.sku,\n    name: row.name,\n    nameRo: row.nameRo,\n    description: row.description,\n    rank: parseFloat(row.rank),\n    headline: row.headline,\n    basePrice: parseFloat(row.basePrice),\n    priceWithVat: parseFloat(row.priceWithVat),\n    currentStock: parseInt(row.currentStock),\n    brand: row.brand\n  }));\n  \n  const response: KeywordSearchResult = {\n    success: true,\n    results: searchResults,\n    query,\n    parsedQuery,\n    totalFound: searchResults.length,\n    searchLatencyMs,\n    cacheHit: false\n  };\n  \n  // Cache results\n  if (options?.useCache !== false && searchResults.length > 0) {\n    await redis.setex(cacheKey, options?.cacheTTL || 300, JSON.stringify(response));\n  }\n  \n  metrics.keywordSearchLatency.observe(searchLatencyMs);\n  metrics.keywordSearchResults.observe(searchResults.length);\n  \n  log.info('Keyword search completed', {\n    totalFound: searchResults.length,\n    latencyMs: searchLatencyMs\n  });\n  \n  return response;\n}\n\nfunction parseSearchQuery(query: string, fuzzyMatch: boolean): string {\n  // Normalize and split into tokens\n  const tokens = query\n    .toLowerCase()\n    .replace(/[^a-zA-Z0-9ăâîșțĂÂÎȘȚ\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter(t => t.length >= 2);\n  \n  if (fuzzyMatch) {\n    // Use prefix matching with :*\n    return tokens.map(t => `${t}:*`).join(' & ');\n  }\n  \n  return tokens.join(' & ');\n}\n\nfunction buildSearchVector(fields: string[], language: string): any {\n  const fieldMap: Record<string, string> = {\n    name: 'name',\n    nameRo: 'name_ro',\n    description: 'description',\n    sku: 'sku',\n    brand: 'brand',\n    searchKeywords: 'search_keywords'\n  };\n  \n  const vectors = fields.map(f => {\n    const column = fieldMap[f] || f;\n    const weight = f === 'name' || f === 'nameRo' ? 'A' : f === 'sku' ? 'B' : 'C';\n    return sql`setweight(to_tsvector('${sql.raw(language)}', COALESCE(${sql.raw(column)}, '')), '${sql.raw(weight)}')`;\n  });\n  \n  return sql`(${sql.join(vectors, sql` || `)})`;\n}\n\nfunction hashQuery(query: string, filters?: any, fields?: string[]): string {\n  const crypto = require('crypto');\n  const data = JSON.stringify({ query: query.toLowerCase().trim(), filters, fields });\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\nexport const ragKeywordSearchWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.RAG_KEYWORD_SEARCH,\n  processKeywordSearch,\n  {\n    concurrency: 20,\n    limiter: {\n      max: 100,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-b",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE configurație 'romanian' pentru FTS - nu 'simple'",
    "INCLUDE weights pentru ranking - A pentru nume, C pentru descriere",
    "ESCAPEAZĂ caractere speciale din query",
    "CACHE rezultate pentru queries frecvente",
    "SUPORTĂ fuzzy matching cu prefix :*"
  ],
  "validare_task": "1. FTS cu ts_vector și ts_query\n2. Ranking cu ts_rank_cd\n3. Fuzzy matching cu prefix\n4. Headline highlighting opțional\n5. Filtre combinate funcționale",
  "outcome": "Worker rag:keyword-search funcțional pentru full-text search PostgreSQL"
}
```

## F3.3.3 Hybrid Merge Worker (#9)

```json
{
  "taskID": "F3.3.3.T001",
  "denumire_task": "Implementare worker rag:hybrid-merge pentru combinare rezultate semantic + keyword",
  "context_anterior": "Semantic și keyword search implementate. Acum implementăm merge-ul pentru rezultate hibride optimale.",
  "descriere_task": "Ești un expert în hybrid search și Reciprocal Rank Fusion. Task-ul tău este să creezi workerul pentru combinarea rezultatelor.\n\nCreează fișierul /packages/workers/src/etapa3/category-b/rag-hybrid-merge.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\n\nconst HybridMergePayload = z.object({\n  tenantId: z.string().uuid(),\n  query: z.string().min(1).max(1000),\n  intent: z.string().optional(), // From intent detection\n  topK: z.number().min(1).max(30).default(10),\n  weights: z.object({\n    semantic: z.number().min(0).max(1).default(0.6),\n    keyword: z.number().min(0).max(1).default(0.4)\n  }).optional(),\n  filters: z.record(z.any()).optional(),\n  options: z.object({\n    semanticTopK: z.number().default(20),\n    keywordTopK: z.number().default(20),\n    minSemanticSimilarity: z.number().default(0.65),\n    rerankResults: z.boolean().default(false),\n    includeScoreBreakdown: z.boolean().default(true)\n  }).optional()\n});\n\ntype HybridMergeJob = z.infer<typeof HybridMergePayload>;\n\ninterface HybridResult {\n  productId: string;\n  sku: string;\n  name: string;\n  nameRo?: string;\n  description?: string;\n  finalScore: number;\n  semanticScore?: number;\n  keywordScore?: number;\n  semanticRank?: number;\n  keywordRank?: number;\n  basePrice: number;\n  priceWithVat: number;\n  currentStock: number;\n  brand?: string;\n  aiSummary?: string;\n}\n\ninterface HybridMergeResult {\n  success: boolean;\n  results: HybridResult[];\n  query: string;\n  intent?: string;\n  weights: { semantic: number; keyword: number };\n  searchStats: {\n    semanticCount: number;\n    keywordCount: number;\n    mergedCount: number;\n    uniqueCount: number;\n    overlapCount: number;\n  };\n  totalLatencyMs: number;\n}\n\nasync function processHybridMerge(job: Job<HybridMergeJob>): Promise<HybridMergeResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { tenantId, query, intent, topK, weights, filters, options } = job.data;\n  \n  log.info('Starting hybrid merge search', { query: query.slice(0, 100), intent });\n  \n  // Adjust weights based on intent\n  const adjustedWeights = adjustWeightsByIntent(intent, weights);\n  \n  // Execute both searches in parallel\n  const [semanticResults, keywordResults] = await Promise.all([\n    executeSemanticSearch(tenantId, query, options?.semanticTopK || 20, options?.minSemanticSimilarity || 0.65, filters),\n    executeKeywordSearch(tenantId, query, options?.keywordTopK || 20, filters)\n  ]);\n  \n  log.info('Individual searches completed', {\n    semanticCount: semanticResults.length,\n    keywordCount: keywordResults.length\n  });\n  \n  // Apply Reciprocal Rank Fusion (RRF)\n  const mergedResults = reciprocalRankFusion(\n    semanticResults,\n    keywordResults,\n    adjustedWeights,\n    options?.includeScoreBreakdown !== false\n  );\n  \n  // Sort by final score and take topK\n  const sortedResults = mergedResults\n    .sort((a, b) => b.finalScore - a.finalScore)\n    .slice(0, topK);\n  \n  // Optional: Rerank with cross-encoder\n  let finalResults = sortedResults;\n  if (options?.rerankResults) {\n    finalResults = await rerankWithCrossEncoder(query, sortedResults);\n  }\n  \n  // Calculate stats\n  const semanticIds = new Set(semanticResults.map(r => r.productId));\n  const keywordIds = new Set(keywordResults.map(r => r.productId));\n  const overlapCount = [...semanticIds].filter(id => keywordIds.has(id)).length;\n  \n  const response: HybridMergeResult = {\n    success: true,\n    results: finalResults,\n    query,\n    intent,\n    weights: adjustedWeights,\n    searchStats: {\n      semanticCount: semanticResults.length,\n      keywordCount: keywordResults.length,\n      mergedCount: mergedResults.length,\n      uniqueCount: mergedResults.length,\n      overlapCount\n    },\n    totalLatencyMs: Date.now() - startTime\n  };\n  \n  metrics.hybridSearchLatency.observe(response.totalLatencyMs);\n  metrics.hybridSearchResults.observe(finalResults.length);\n  \n  log.info('Hybrid merge completed', {\n    finalCount: finalResults.length,\n    overlapCount,\n    latencyMs: response.totalLatencyMs\n  });\n  \n  return response;\n}\n\nfunction adjustWeightsByIntent(intent?: string, baseWeights?: { semantic: number; keyword: number }) {\n  const defaults = { semantic: 0.6, keyword: 0.4 };\n  const weights = { ...defaults, ...baseWeights };\n  \n  // Adjust based on detected intent\n  if (intent) {\n    switch (intent) {\n      case 'PRODUCT_INQUIRY':\n        // More semantic for understanding product questions\n        weights.semantic = 0.7;\n        weights.keyword = 0.3;\n        break;\n      case 'SKU_LOOKUP':\n        // More keyword for exact SKU matching\n        weights.semantic = 0.3;\n        weights.keyword = 0.7;\n        break;\n      case 'PRICE_INQUIRY':\n      case 'STOCK_CHECK':\n        // Balanced\n        weights.semantic = 0.5;\n        weights.keyword = 0.5;\n        break;\n      case 'RECOMMENDATION':\n        // Heavy semantic for understanding needs\n        weights.semantic = 0.8;\n        weights.keyword = 0.2;\n        break;\n    }\n  }\n  \n  return weights;\n}\n\nasync function executeSemanticSearch(\n  tenantId: string,\n  query: string,\n  topK: number,\n  minSimilarity: number,\n  filters?: any\n): Promise<any[]> {\n  const queue = createEtapa3Queue(ETAPA3_QUEUES.RAG_SEMANTIC_SEARCH);\n  const job = await queue.add('search', {\n    tenantId,\n    query,\n    topK,\n    minSimilarity,\n    filters,\n    options: { useCache: true }\n  }, { priority: 1 });\n  \n  const result = await job.waitUntilFinished(queue);\n  return result.results || [];\n}\n\nasync function executeKeywordSearch(\n  tenantId: string,\n  query: string,\n  topK: number,\n  filters?: any\n): Promise<any[]> {\n  const queue = createEtapa3Queue(ETAPA3_QUEUES.RAG_KEYWORD_SEARCH);\n  const job = await queue.add('search', {\n    tenantId,\n    query,\n    topK,\n    fuzzyMatch: true,\n    language: 'romanian',\n    filters,\n    options: { useCache: true }\n  }, { priority: 1 });\n  \n  const result = await job.waitUntilFinished(queue);\n  return result.results || [];\n}\n\nfunction reciprocalRankFusion(\n  semanticResults: any[],\n  keywordResults: any[],\n  weights: { semantic: number; keyword: number },\n  includeBreakdown: boolean\n): HybridResult[] {\n  const k = 60; // RRF constant\n  const scoreMap = new Map<string, HybridResult>();\n  \n  // Process semantic results\n  semanticResults.forEach((result, index) => {\n    const rrf = 1 / (k + index + 1);\n    const existing = scoreMap.get(result.productId);\n    \n    if (existing) {\n      existing.finalScore += weights.semantic * rrf;\n      existing.semanticScore = result.similarity;\n      existing.semanticRank = index + 1;\n    } else {\n      scoreMap.set(result.productId, {\n        ...result,\n        finalScore: weights.semantic * rrf,\n        semanticScore: includeBreakdown ? result.similarity : undefined,\n        semanticRank: includeBreakdown ? index + 1 : undefined,\n        keywordScore: undefined,\n        keywordRank: undefined\n      });\n    }\n  });\n  \n  // Process keyword results\n  keywordResults.forEach((result, index) => {\n    const rrf = 1 / (k + index + 1);\n    const existing = scoreMap.get(result.productId);\n    \n    if (existing) {\n      existing.finalScore += weights.keyword * rrf;\n      existing.keywordScore = result.rank;\n      existing.keywordRank = index + 1;\n    } else {\n      scoreMap.set(result.productId, {\n        ...result,\n        finalScore: weights.keyword * rrf,\n        semanticScore: undefined,\n        semanticRank: undefined,\n        keywordScore: includeBreakdown ? result.rank : undefined,\n        keywordRank: includeBreakdown ? index + 1 : undefined\n      });\n    }\n  });\n  \n  return Array.from(scoreMap.values());\n}\n\nasync function rerankWithCrossEncoder(query: string, results: HybridResult[]): Promise<HybridResult[]> {\n  // Queue to rerank worker\n  const rerankQueue = createEtapa3Queue(ETAPA3_QUEUES.RAG_RERANK);\n  const job = await rerankQueue.add('rerank', {\n    query,\n    documents: results.map(r => ({\n      id: r.productId,\n      text: `${r.name} ${r.nameRo || ''} ${r.description || ''}`\n    }))\n  }, { priority: 1 });\n  \n  const reranked = await job.waitUntilFinished(rerankQueue);\n  \n  // Merge rerank scores\n  const rerankMap = new Map(reranked.results.map((r: any) => [r.id, r.score]));\n  \n  return results.map(r => ({\n    ...r,\n    finalScore: rerankMap.get(r.productId) || r.finalScore\n  })).sort((a, b) => b.finalScore - a.finalScore);\n}\n\nexport const ragHybridMergeWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.RAG_HYBRID_MERGE,\n  processHybridMerge,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 30,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-b",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE Reciprocal Rank Fusion (k=60) pentru combinare",
    "AJUSTEAZĂ weights dinamic pe baza intent-ului detectat",
    "EXECUTĂ căutările în paralel pentru latency minim",
    "INCLUDE score breakdown pentru debugging și analytics",
    "SUPORTĂ reranking opțional cu cross-encoder"
  ],
  "validare_task": "1. Execuție paralelă semantic + keyword\n2. RRF scoring corect implementat\n3. Weight adjustment pe intent\n4. Stats pentru overlap și merge\n5. Reranking opțional funcțional",
  "outcome": "Worker rag:hybrid-merge funcțional pentru combinare optimală semantic + keyword"
}
```

## F3.3.4 Context Builder Worker (#10)

```json
{
  "taskID": "F3.3.4.T001",
  "denumire_task": "Implementare worker rag:context-build pentru construirea contextului LLM",
  "context_anterior": "Hybrid merge finalizat. Acum implementăm construirea contextului optimizat pentru LLM.",
  "descriere_task": "Ești un expert în prompt engineering și context window management. Task-ul tău este să creezi workerul pentru construirea contextului.\n\nCreează fișierul /packages/workers/src/etapa3/category-b/rag-context-build.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiations, contactsGold, products, priceHistory } from '@cerniq/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { tokenize, countTokens } from '@cerniq/tokenizer';\nimport { metrics } from '@cerniq/metrics';\n\nconst ContextBuildPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid().optional(),\n  contactId: z.string().uuid().optional(),\n  query: z.string(),\n  intent: z.string().optional(),\n  ragResults: z.array(z.object({\n    productId: z.string(),\n    sku: z.string(),\n    name: z.string(),\n    nameRo: z.string().optional(),\n    description: z.string().optional(),\n    basePrice: z.number(),\n    priceWithVat: z.number(),\n    currentStock: z.number(),\n    brand: z.string().optional(),\n    aiSummary: z.string().optional(),\n    finalScore: z.number()\n  })),\n  options: z.object({\n    maxContextTokens: z.number().default(4000),\n    includeConversationHistory: z.boolean().default(true),\n    maxHistoryMessages: z.number().default(10),\n    includeClientProfile: z.boolean().default(true),\n    includePriceHistory: z.boolean().default(false),\n    prioritizeRecentProducts: z.boolean().default(true)\n  }).optional()\n});\n\ntype ContextBuildJob = z.infer<typeof ContextBuildPayload>;\n\ninterface BuiltContext {\n  systemContext: string;\n  productContext: string;\n  conversationContext: string;\n  clientContext: string;\n  combinedContext: string;\n  tokenCounts: {\n    system: number;\n    products: number;\n    conversation: number;\n    client: number;\n    total: number;\n    available: number;\n  };\n  includedProducts: string[];\n  truncated: boolean;\n}\n\nasync function processContextBuild(job: Job<ContextBuildJob>): Promise<BuiltContext> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { tenantId, negotiationId, contactId, query, intent, ragResults, options } = job.data;\n  const maxTokens = options?.maxContextTokens || 4000;\n  \n  log.info('Building LLM context', { ragResultCount: ragResults.length, maxTokens });\n  \n  // Build system context (always included)\n  const systemContext = buildSystemContext(intent);\n  const systemTokens = countTokens(systemContext);\n  \n  let remainingTokens = maxTokens - systemTokens;\n  \n  // Build client context if available\n  let clientContext = '';\n  let clientTokens = 0;\n  \n  if (options?.includeClientProfile !== false && (negotiationId || contactId)) {\n    clientContext = await buildClientContext(tenantId, negotiationId, contactId);\n    clientTokens = countTokens(clientContext);\n    \n    if (clientTokens > remainingTokens * 0.2) {\n      clientContext = truncateToTokens(clientContext, Math.floor(remainingTokens * 0.2));\n      clientTokens = countTokens(clientContext);\n    }\n    remainingTokens -= clientTokens;\n  }\n  \n  // Build conversation history if available\n  let conversationContext = '';\n  let conversationTokens = 0;\n  \n  if (options?.includeConversationHistory !== false && negotiationId) {\n    conversationContext = await buildConversationHistory(\n      negotiationId,\n      options?.maxHistoryMessages || 10\n    );\n    conversationTokens = countTokens(conversationContext);\n    \n    if (conversationTokens > remainingTokens * 0.3) {\n      conversationContext = truncateConversation(conversationContext, Math.floor(remainingTokens * 0.3));\n      conversationTokens = countTokens(conversationContext);\n    }\n    remainingTokens -= conversationTokens;\n  }\n  \n  // Build product context with remaining tokens\n  const { productContext, includedProducts, truncated } = buildProductContext(\n    ragResults,\n    remainingTokens,\n    options?.prioritizeRecentProducts !== false\n  );\n  const productTokens = countTokens(productContext);\n  \n  // Combine all contexts\n  const combinedContext = [\n    systemContext,\n    clientContext ? `\\n### PROFIL CLIENT\\n${clientContext}` : '',\n    conversationContext ? `\\n### ISTORIC CONVERSAȚIE\\n${conversationContext}` : '',\n    `\\n### PRODUSE RELEVANTE\\n${productContext}`\n  ].filter(Boolean).join('\\n');\n  \n  const totalTokens = systemTokens + clientTokens + conversationTokens + productTokens;\n  \n  const result: BuiltContext = {\n    systemContext,\n    productContext,\n    conversationContext,\n    clientContext,\n    combinedContext,\n    tokenCounts: {\n      system: systemTokens,\n      products: productTokens,\n      conversation: conversationTokens,\n      client: clientTokens,\n      total: totalTokens,\n      available: maxTokens - totalTokens\n    },\n    includedProducts,\n    truncated\n  };\n  \n  metrics.contextBuildTokens.observe(totalTokens);\n  metrics.contextBuildLatency.observe(Date.now() - startTime);\n  \n  log.info('Context built', {\n    totalTokens,\n    productCount: includedProducts.length,\n    truncated,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return result;\n}\n\nfunction buildSystemContext(intent?: string): string {\n  let context = `Ești un agent comercial AI pentru o companie agricolă din România.\n\nREGULI STRICTE:\n1. Răspunde DOAR în limba română\n2. NU inventa prețuri - folosește DOAR informațiile din PRODUSE RELEVANTE\n3. NU confirma stoc fără verificare - stocul se schimbă în timp real\n4. Fii profesionist și concis\n5. Dacă nu știi ceva, întreabă sau spune că vei verifica`;\n\n  if (intent) {\n    context += `\\n\\nINTENT DETECTAT: ${intent}`;\n    \n    const intentGuidance: Record<string, string> = {\n      'PRODUCT_INQUIRY': 'Clientul întreabă despre produse. Oferă detalii din catalog.',\n      'PRICE_INQUIRY': 'Clientul întreabă de preț. Prezintă prețurile din catalog, menționează că pot exista discount-uri.',\n      'STOCK_CHECK': 'Clientul verifică stocul. Confirmă disponibilitatea din informațiile furnizate.',\n      'DISCOUNT_REQUEST': 'Clientul cere discount. Poți oferi max 10% standard, peste necesită aprobare.',\n      'ORDER_INTENT': 'Clientul vrea să comande. Ghidează spre finalizare, confirmă detalii.',\n      'COMPLAINT': 'Clientul are o problemă. Ascultă empatic, oferă soluții.',\n      'GENERAL_CHAT': 'Conversație generală. Menține tonul profesional dar prietenos.'\n    };\n    \n    if (intentGuidance[intent]) {\n      context += `\\nGHID: ${intentGuidance[intent]}`;\n    }\n  }\n  \n  return context;\n}\n\nasync function buildClientContext(\n  tenantId: string,\n  negotiationId?: string,\n  contactId?: string\n): Promise<string> {\n  let contact: any = null;\n  let negotiation: any = null;\n  \n  if (negotiationId) {\n    negotiation = await db.query.negotiations.findFirst({\n      where: eq(negotiations.id, negotiationId),\n      with: { contact: true }\n    });\n    contact = negotiation?.contact;\n  } else if (contactId) {\n    contact = await db.query.contactsGold.findFirst({\n      where: eq(contactsGold.id, contactId)\n    });\n  }\n  \n  if (!contact) return '';\n  \n  const lines = [\n    `Companie: ${contact.companyName || contact.name}`,\n    contact.cui ? `CUI: ${contact.cui}` : null,\n    contact.city ? `Locație: ${contact.city}, ${contact.county}` : null,\n    contact.phone ? `Tel: ${contact.phone}` : null,\n    contact.email ? `Email: ${contact.email}` : null\n  ].filter(Boolean);\n  \n  if (negotiation) {\n    lines.push(`Stare negociere: ${negotiation.currentState}`);\n    lines.push(`Mesaje anterioare: ${negotiation.aiMessageCount}`);\n    if (negotiation.totalValue) {\n      lines.push(`Valoare estimată: ${negotiation.totalValue} RON`);\n    }\n  }\n  \n  return lines.join('\\n');\n}\n\nasync function buildConversationHistory(\n  negotiationId: string,\n  maxMessages: number\n): Promise<string> {\n  const messages = await db.query.negotiationMessages.findMany({\n    where: eq(negotiations.id, negotiationId),\n    limit: maxMessages,\n    orderBy: (m, { desc }) => desc(m.createdAt)\n  });\n  \n  if (!messages.length) return '';\n  \n  return messages\n    .reverse()\n    .map(m => `${m.role.toUpperCase()}: ${m.content}`)\n    .join('\\n');\n}\n\nfunction buildProductContext(\n  ragResults: any[],\n  maxTokens: number,\n  prioritizeRecent: boolean\n): { productContext: string; includedProducts: string[]; truncated: boolean } {\n  const includedProducts: string[] = [];\n  const productLines: string[] = [];\n  let currentTokens = 0;\n  let truncated = false;\n  \n  for (const product of ragResults) {\n    const productText = formatProductForContext(product);\n    const productTokens = countTokens(productText);\n    \n    if (currentTokens + productTokens > maxTokens) {\n      truncated = true;\n      break;\n    }\n    \n    productLines.push(productText);\n    includedProducts.push(product.productId);\n    currentTokens += productTokens;\n  }\n  \n  return {\n    productContext: productLines.join('\\n\\n'),\n    includedProducts,\n    truncated\n  };\n}\n\nfunction formatProductForContext(product: any): string {\n  return `**${product.name}** (SKU: ${product.sku})\n- Preț: ${product.priceWithVat} RON (cu TVA)\n- Stoc: ${product.currentStock > 0 ? `${product.currentStock} buc disponibil` : 'Indisponibil temporar'}\n${product.brand ? `- Brand: ${product.brand}` : ''}\n${product.aiSummary ? `- ${product.aiSummary}` : product.description?.slice(0, 150) || ''}`;\n}\n\nfunction truncateToTokens(text: string, maxTokens: number): string {\n  const tokens = tokenize(text);\n  if (tokens.length <= maxTokens) return text;\n  return tokens.slice(0, maxTokens).join('');\n}\n\nfunction truncateConversation(text: string, maxTokens: number): string {\n  const lines = text.split('\\n');\n  const result: string[] = [];\n  let tokens = 0;\n  \n  // Keep most recent messages\n  for (let i = lines.length - 1; i >= 0; i--) {\n    const lineTokens = countTokens(lines[i]);\n    if (tokens + lineTokens > maxTokens) break;\n    result.unshift(lines[i]);\n    tokens += lineTokens;\n  }\n  \n  return result.join('\\n');\n}\n\nexport const ragContextBuildWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.RAG_CONTEXT_BUILD,\n  processContextBuild,\n  {\n    concurrency: 15,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-b",
  "restrictii_antihalucinatie": [
    "RESPECTĂ token budget strict - maxContextTokens",
    "PRIORITIZEAZĂ produse relevante când trebuie să trunchiezi",
    "INCLUDE intent guidance în system context",
    "NU include date irelevante care consumă tokens",
    "FORMATEAZĂ produse consistent pentru LLM parsing"
  ],
  "validare_task": "1. Token counting și budgeting corect\n2. Prioritizare context pe importanță\n3. Client și conversation history incluse\n4. Truncare graceful când depășește limita\n5. Metrics pentru token usage",
  "outcome": "Worker rag:context-build funcțional pentru construirea contextului LLM optimizat"
}
```

---

# FAZA F3.7: STOCK & INVENTORY WORKERS (CATEGORIA F)

## F3.7.1 Stock Check Worker (#33)

```json
{
  "taskID": "F3.7.1.T001",
  "denumire_task": "Implementare worker stock:check pentru verificare disponibilitate",
  "context_anterior": "Pricing workers complete. Acum implementăm verificarea stocurilor - critic pentru guardrail anti-halucinație.",
  "descriere_task": "Ești un expert în inventory management. Task-ul tău este să creezi workerul pentru verificare stoc real-time.\n\nCreează fișierul /packages/workers/src/etapa3/category-f/stock-check.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products, stockReservations, stockMovements } from '@cerniq/db/schema';\nimport { eq, and, gt, sql, inArray } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { redis } from '@cerniq/cache';\n\nconst StockCheckPayload = z.object({\n  tenantId: z.string().uuid(),\n  items: z.array(z.object({\n    productId: z.string().uuid().optional(),\n    sku: z.string().optional(),\n    requestedQuantity: z.number().positive()\n  })).min(1),\n  negotiationId: z.string().uuid().optional(),\n  options: z.object({\n    checkReservations: z.boolean().default(true),\n    includeLowStockWarning: z.boolean().default(true),\n    lowStockThreshold: z.number().default(10),\n    useCache: z.boolean().default(true),\n    cacheTTL: z.number().default(30) // 30 seconds - stock changes frequently\n  }).optional()\n});\n\ntype StockCheckJob = z.infer<typeof StockCheckPayload>;\n\ninterface StockCheckResult {\n  productId: string;\n  sku: string;\n  name: string;\n  requestedQuantity: number;\n  currentStock: number;\n  reservedStock: number;\n  availableStock: number;\n  isAvailable: boolean;\n  shortfall: number;\n  lowStockWarning: boolean;\n  reorderLevel?: number;\n  expectedRestockDate?: string;\n  alternativeSku?: string;\n}\n\ninterface StockCheckResponse {\n  success: boolean;\n  allAvailable: boolean;\n  results: StockCheckResult[];\n  summary: {\n    totalItems: number;\n    availableItems: number;\n    unavailableItems: number;\n    lowStockItems: number;\n  };\n  timestamp: string;\n  cacheHit: boolean;\n}\n\nasync function processStockCheck(job: Job<StockCheckJob>): Promise<StockCheckResponse> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { tenantId, items, negotiationId, options } = job.data;\n  \n  log.info('Checking stock availability', { itemCount: items.length });\n  \n  const results: StockCheckResult[] = [];\n  let cacheHit = false;\n  \n  // Collect all product IDs/SKUs for batch query\n  const productIds = items.filter(i => i.productId).map(i => i.productId!);\n  const skus = items.filter(i => i.sku && !i.productId).map(i => i.sku!);\n  \n  // Load all products in one query\n  let productsData: any[] = [];\n  \n  if (productIds.length > 0) {\n    const byId = await db.query.products.findMany({\n      where: and(\n        eq(products.tenantId, tenantId),\n        inArray(products.id, productIds)\n      )\n    });\n    productsData.push(...byId);\n  }\n  \n  if (skus.length > 0) {\n    const bySku = await db.query.products.findMany({\n      where: and(\n        eq(products.tenantId, tenantId),\n        inArray(products.sku, skus)\n      )\n    });\n    productsData.push(...bySku);\n  }\n  \n  // Create lookup map\n  const productMap = new Map<string, any>();\n  productsData.forEach(p => {\n    productMap.set(p.id, p);\n    productMap.set(p.sku, p);\n  });\n  \n  // Load active reservations if needed\n  let reservationMap = new Map<string, number>();\n  \n  if (options?.checkReservations !== false) {\n    const reservations = await db.query.stockReservations.findMany({\n      where: and(\n        eq(stockReservations.tenantId, tenantId),\n        inArray(stockReservations.productId, productIds.length > 0 ? productIds : productsData.map(p => p.id)),\n        eq(stockReservations.status, 'active'),\n        gt(stockReservations.expiresAt, new Date())\n      )\n    });\n    \n    reservations.forEach(r => {\n      const current = reservationMap.get(r.productId) || 0;\n      reservationMap.set(r.productId, current + parseInt(r.quantity));\n    });\n  }\n  \n  // Check each item\n  for (const item of items) {\n    const product = productMap.get(item.productId || item.sku || '');\n    \n    if (!product) {\n      results.push({\n        productId: item.productId || '',\n        sku: item.sku || '',\n        name: 'PRODUCT NOT FOUND',\n        requestedQuantity: item.requestedQuantity,\n        currentStock: 0,\n        reservedStock: 0,\n        availableStock: 0,\n        isAvailable: false,\n        shortfall: item.requestedQuantity,\n        lowStockWarning: false\n      });\n      continue;\n    }\n    \n    const currentStock = parseInt(product.currentStock) || 0;\n    const reservedStock = reservationMap.get(product.id) || 0;\n    const availableStock = currentStock - reservedStock;\n    const isAvailable = availableStock >= item.requestedQuantity;\n    const shortfall = isAvailable ? 0 : item.requestedQuantity - availableStock;\n    const lowStockThreshold = options?.lowStockThreshold || 10;\n    const lowStockWarning = availableStock > 0 && availableStock <= lowStockThreshold;\n    \n    results.push({\n      productId: product.id,\n      sku: product.sku,\n      name: product.name,\n      requestedQuantity: item.requestedQuantity,\n      currentStock,\n      reservedStock,\n      availableStock,\n      isAvailable,\n      shortfall,\n      lowStockWarning,\n      reorderLevel: product.reorderLevel ? parseInt(product.reorderLevel) : undefined,\n      expectedRestockDate: product.expectedRestockDate,\n      alternativeSku: !isAvailable ? await findAlternative(tenantId, product) : undefined\n    });\n    \n    // Queue low stock alert if needed\n    if (lowStockWarning || availableStock === 0) {\n      const alertQueue = createEtapa3Queue(ETAPA3_QUEUES.STOCK_ALERT);\n      await alertQueue.add('low-stock', {\n        tenantId,\n        productId: product.id,\n        sku: product.sku,\n        currentStock: availableStock,\n        reorderLevel: product.reorderLevel,\n        severity: availableStock === 0 ? 'critical' : 'warning'\n      }, { priority: availableStock === 0 ? 1 : 2 });\n    }\n  }\n  \n  const summary = {\n    totalItems: results.length,\n    availableItems: results.filter(r => r.isAvailable).length,\n    unavailableItems: results.filter(r => !r.isAvailable).length,\n    lowStockItems: results.filter(r => r.lowStockWarning).length\n  };\n  \n  const response: StockCheckResponse = {\n    success: true,\n    allAvailable: summary.unavailableItems === 0,\n    results,\n    summary,\n    timestamp: new Date().toISOString(),\n    cacheHit\n  };\n  \n  // Update metrics\n  metrics.stockCheckLatency.observe(Date.now() - startTime);\n  metrics.stockCheckItems.inc(items.length);\n  if (!response.allAvailable) {\n    metrics.stockCheckUnavailable.inc(summary.unavailableItems);\n  }\n  \n  log.info('Stock check completed', {\n    allAvailable: response.allAvailable,\n    summary,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return response;\n}\n\nasync function findAlternative(tenantId: string, product: any): Promise<string | undefined> {\n  // Find alternative product in same category with stock\n  const alternative = await db.query.products.findFirst({\n    where: and(\n      eq(products.tenantId, tenantId),\n      eq(products.categoryId, product.categoryId),\n      gt(products.availableStock, 0),\n      sql`${products.id} != ${product.id}`\n    ),\n    orderBy: (p, { desc }) => desc(p.availableStock)\n  });\n  \n  return alternative?.sku;\n}\n\nexport const stockCheckWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.STOCK_CHECK,\n  processStockCheck,\n  {\n    concurrency: 25,\n    limiter: {\n      max: 150,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-f",
  "restrictii_antihalucinatie": [
    "VERIFICĂ reserved stock activ - nu doar currentStock",
    "FOLOSEȘTE batch query pentru performance",
    "CACHE foarte scurt (30s) - stocul se schimbă frecvent",
    "QUEUE alert pentru low stock automat",
    "RETURNEAZĂ alternative când indisponibil"
  ],
  "validare_task": "1. Batch loading produse pentru performance\n2. Rezervări active considerate\n3. Available stock = current - reserved\n4. Low stock alerts automate\n5. Alternative products sugerate",
  "outcome": "Worker stock:check funcțional pentru verificare stoc real-time cu rezervări"
}
```

## F3.7.2 Stock Reserve Worker (#34)

```json
{
  "taskID": "F3.7.2.T001",
  "denumire_task": "Implementare worker stock:reserve pentru rezervare temporară stoc",
  "context_anterior": "Stock check implementat. Acum implementăm rezervarea temporară pentru negocieri în curs.",
  "descriere_task": "Ești un expert în inventory management și locking patterns. Task-ul tău este să creezi workerul pentru rezervare stoc.\n\nCreează fișierul /packages/workers/src/etapa3/category-f/stock-reserve.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products, stockReservations } from '@cerniq/db/schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { redis } from '@cerniq/cache';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst StockReservePayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  items: z.array(z.object({\n    productId: z.string().uuid(),\n    quantity: z.number().positive(),\n    unitPrice: z.number().optional()\n  })).min(1),\n  reservationType: z.enum(['soft', 'hard']).default('soft'),\n  expirationMinutes: z.number().min(5).max(1440).default(60), // 1 hour default\n  extendExisting: z.boolean().default(true),\n  metadata: z.record(z.any()).optional()\n});\n\ntype StockReserveJob = z.infer<typeof StockReservePayload>;\n\ninterface ReservationResult {\n  productId: string;\n  sku: string;\n  requestedQuantity: number;\n  reservedQuantity: number;\n  reservationId?: string;\n  success: boolean;\n  reason?: string;\n}\n\ninterface StockReserveResponse {\n  success: boolean;\n  reservations: ReservationResult[];\n  expiresAt: string;\n  totalReserved: number;\n  totalFailed: number;\n}\n\nasync function processStockReserve(job: Job<StockReserveJob>): Promise<StockReserveResponse> {\n  const startTime = Date.now();\n  const log = logger.child({ \n    jobId: job.id, \n    tenantId: job.data.tenantId,\n    negotiationId: job.data.negotiationId\n  });\n  \n  const { \n    tenantId, \n    negotiationId, \n    items, \n    reservationType, \n    expirationMinutes, \n    extendExisting,\n    metadata \n  } = job.data;\n  \n  log.info('Processing stock reservation', { \n    itemCount: items.length, \n    expirationMinutes,\n    reservationType\n  });\n  \n  const expiresAt = new Date(Date.now() + expirationMinutes * 60 * 1000);\n  const reservations: ReservationResult[] = [];\n  \n  // Use distributed lock for this negotiation\n  const lockKey = `stock-reserve:${tenantId}:${negotiationId}`;\n  const lockTTL = 30000; // 30 seconds\n  \n  const lock = await redis.set(lockKey, job.id!, 'NX', 'PX', lockTTL);\n  if (!lock) {\n    throw new Error('Could not acquire reservation lock - another reservation in progress');\n  }\n  \n  try {\n    // If extending existing, release old reservations first\n    if (extendExisting) {\n      await db.update(stockReservations)\n        .set({ status: 'released', releasedAt: new Date() })\n        .where(and(\n          eq(stockReservations.tenantId, tenantId),\n          eq(stockReservations.negotiationId, negotiationId),\n          eq(stockReservations.status, 'active')\n        ));\n    }\n    \n    // Process each item\n    for (const item of items) {\n      const result = await reserveItem({\n        tenantId,\n        negotiationId,\n        productId: item.productId,\n        quantity: item.quantity,\n        unitPrice: item.unitPrice,\n        expiresAt,\n        reservationType,\n        metadata\n      });\n      \n      reservations.push(result);\n    }\n    \n    // Schedule expiration check\n    const releaseQueue = createEtapa3Queue(ETAPA3_QUEUES.STOCK_RELEASE);\n    await releaseQueue.add('expire-check', {\n      tenantId,\n      negotiationId,\n      reservationIds: reservations\n        .filter(r => r.success && r.reservationId)\n        .map(r => r.reservationId!)\n    }, {\n      delay: expirationMinutes * 60 * 1000 + 1000, // Add 1 second buffer\n      jobId: `expire-${negotiationId}-${Date.now()}`,\n      removeOnComplete: true\n    });\n    \n  } finally {\n    // Release lock\n    await redis.del(lockKey);\n  }\n  \n  const totalReserved = reservations.filter(r => r.success).length;\n  const totalFailed = reservations.filter(r => !r.success).length;\n  \n  // Update metrics\n  metrics.stockReservations.inc({ type: reservationType }, totalReserved);\n  metrics.stockReservationFailures.inc(totalFailed);\n  \n  log.info('Stock reservation completed', {\n    totalReserved,\n    totalFailed,\n    expiresAt: expiresAt.toISOString(),\n    latencyMs: Date.now() - startTime\n  });\n  \n  return {\n    success: totalFailed === 0,\n    reservations,\n    expiresAt: expiresAt.toISOString(),\n    totalReserved,\n    totalFailed\n  };\n}\n\nasync function reserveItem(params: {\n  tenantId: string;\n  negotiationId: string;\n  productId: string;\n  quantity: number;\n  unitPrice?: number;\n  expiresAt: Date;\n  reservationType: string;\n  metadata?: Record<string, any>;\n}): Promise<ReservationResult> {\n  const { tenantId, negotiationId, productId, quantity, unitPrice, expiresAt, reservationType, metadata } = params;\n  \n  // Get product with FOR UPDATE lock\n  const product = await db.transaction(async (tx) => {\n    const [p] = await tx.execute(\n      sql`SELECT * FROM products WHERE id = ${productId} AND tenant_id = ${tenantId} FOR UPDATE`\n    );\n    return p;\n  });\n  \n  if (!product) {\n    return {\n      productId,\n      sku: '',\n      requestedQuantity: quantity,\n      reservedQuantity: 0,\n      success: false,\n      reason: 'Product not found'\n    };\n  }\n  \n  const currentStock = parseInt(product.current_stock) || 0;\n  const reservedStock = parseInt(product.reserved_stock) || 0;\n  const availableStock = currentStock - reservedStock;\n  \n  if (availableStock < quantity) {\n    return {\n      productId,\n      sku: product.sku,\n      requestedQuantity: quantity,\n      reservedQuantity: 0,\n      success: false,\n      reason: `Insufficient stock: available ${availableStock}, requested ${quantity}`\n    };\n  }\n  \n  // Create reservation record\n  const reservationId = uuidv4();\n  \n  await db.transaction(async (tx) => {\n    // Insert reservation\n    await tx.insert(stockReservations).values({\n      id: reservationId,\n      tenantId,\n      negotiationId,\n      productId,\n      quantity: quantity.toString(),\n      unitPrice: unitPrice?.toString(),\n      reservationType,\n      status: 'active',\n      expiresAt,\n      metadata,\n      createdAt: new Date()\n    });\n    \n    // Update product reserved stock\n    await tx.update(products)\n      .set({\n        reservedStock: sql`reserved_stock + ${quantity}`,\n        updatedAt: new Date()\n      })\n      .where(eq(products.id, productId));\n  });\n  \n  return {\n    productId,\n    sku: product.sku,\n    requestedQuantity: quantity,\n    reservedQuantity: quantity,\n    reservationId,\n    success: true\n  };\n}\n\nexport const stockReserveWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.STOCK_RESERVE,\n  processStockReserve,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 30,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-f",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE distributed lock pentru negociere - evită race conditions",
    "FOLOSEȘTE FOR UPDATE pentru row-level locking",
    "SCHEDULE expiration check automat",
    "ACTUALIZEAZĂ reserved_stock pe produs",
    "SUPORTĂ extend existing pentru refresh"
  ],
  "validare_task": "1. Distributed lock previne race conditions\n2. Row-level lock cu FOR UPDATE\n3. Reservation records cu TTL\n4. Product reserved_stock actualizat\n5. Automatic expiration scheduling",
  "outcome": "Worker stock:reserve funcțional pentru rezervare temporară stoc cu locking corect"
}
```

## F3.7.3 Stock Release Worker (#35)

```json
{
  "taskID": "F3.7.3.T001",
  "denumire_task": "Implementare worker stock:release pentru eliberare rezervări",
  "context_anterior": "Stock reserve implementat. Acum implementăm eliberarea rezervărilor expirate sau anulate.",
  "descriere_task": "Ești un expert în inventory management. Task-ul tău este să creezi workerul pentru eliberare rezervări.\n\nCreează fișierul /packages/workers/src/etapa3/category-f/stock-release.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products, stockReservations } from '@cerniq/db/schema';\nimport { eq, and, sql, lt, inArray } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\n\nconst StockReleasePayload = z.object({\n  tenantId: z.string().uuid(),\n  releaseType: z.enum(['negotiation', 'reservation_ids', 'expired', 'all_tenant']),\n  negotiationId: z.string().uuid().optional(),\n  reservationIds: z.array(z.string().uuid()).optional(),\n  reason: z.enum(['completed', 'cancelled', 'expired', 'manual']).default('manual')\n});\n\ntype StockReleaseJob = z.infer<typeof StockReleasePayload>;\n\ninterface StockReleaseResponse {\n  success: boolean;\n  releasedCount: number;\n  releasedQuantity: number;\n  productUpdates: number;\n  errors: string[];\n}\n\nasync function processStockRelease(job: Job<StockReleaseJob>): Promise<StockReleaseResponse> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { tenantId, releaseType, negotiationId, reservationIds, reason } = job.data;\n  \n  log.info('Processing stock release', { releaseType, reason });\n  \n  let releasedCount = 0;\n  let releasedQuantity = 0;\n  let productUpdates = 0;\n  const errors: string[] = [];\n  \n  try {\n    // Find reservations to release\n    let whereCondition;\n    \n    switch (releaseType) {\n      case 'negotiation':\n        if (!negotiationId) {\n          throw new Error('negotiationId required for negotiation release type');\n        }\n        whereCondition = and(\n          eq(stockReservations.tenantId, tenantId),\n          eq(stockReservations.negotiationId, negotiationId),\n          eq(stockReservations.status, 'active')\n        );\n        break;\n        \n      case 'reservation_ids':\n        if (!reservationIds?.length) {\n          throw new Error('reservationIds required for reservation_ids release type');\n        }\n        whereCondition = and(\n          eq(stockReservations.tenantId, tenantId),\n          inArray(stockReservations.id, reservationIds),\n          eq(stockReservations.status, 'active')\n        );\n        break;\n        \n      case 'expired':\n        whereCondition = and(\n          eq(stockReservations.tenantId, tenantId),\n          eq(stockReservations.status, 'active'),\n          lt(stockReservations.expiresAt, new Date())\n        );\n        break;\n        \n      case 'all_tenant':\n        whereCondition = and(\n          eq(stockReservations.tenantId, tenantId),\n          eq(stockReservations.status, 'active')\n        );\n        break;\n        \n      default:\n        throw new Error(`Unknown release type: ${releaseType}`);\n    }\n    \n    // Get reservations to release\n    const reservationsToRelease = await db.query.stockReservations.findMany({\n      where: whereCondition\n    });\n    \n    if (reservationsToRelease.length === 0) {\n      log.info('No reservations to release');\n      return {\n        success: true,\n        releasedCount: 0,\n        releasedQuantity: 0,\n        productUpdates: 0,\n        errors: []\n      };\n    }\n    \n    // Group by product for batch update\n    const productQuantities = new Map<string, number>();\n    \n    for (const reservation of reservationsToRelease) {\n      const quantity = parseInt(reservation.quantity);\n      const current = productQuantities.get(reservation.productId) || 0;\n      productQuantities.set(reservation.productId, current + quantity);\n      releasedQuantity += quantity;\n    }\n    \n    // Execute release in transaction\n    await db.transaction(async (tx) => {\n      // Update reservations to released\n      await tx.update(stockReservations)\n        .set({\n          status: 'released',\n          releaseReason: reason,\n          releasedAt: new Date()\n        })\n        .where(whereCondition);\n      \n      releasedCount = reservationsToRelease.length;\n      \n      // Update product reserved_stock for each product\n      for (const [productId, quantity] of productQuantities) {\n        await tx.update(products)\n          .set({\n            reservedStock: sql`GREATEST(reserved_stock - ${quantity}, 0)`,\n            updatedAt: new Date()\n          })\n          .where(eq(products.id, productId));\n        \n        productUpdates++;\n      }\n    });\n    \n    // Log stock movement for audit\n    for (const [productId, quantity] of productQuantities) {\n      await db.insert(stockMovements).values({\n        tenantId,\n        productId,\n        movementType: 'reservation_release',\n        quantity: quantity.toString(),\n        reason: `Released: ${reason}`,\n        referenceType: negotiationId ? 'negotiation' : 'manual',\n        referenceId: negotiationId,\n        createdAt: new Date()\n      });\n    }\n    \n  } catch (error) {\n    log.error('Stock release failed', { error });\n    errors.push(error instanceof Error ? error.message : 'Unknown error');\n  }\n  \n  // Update metrics\n  metrics.stockReleases.inc({ type: releaseType, reason }, releasedCount);\n  metrics.stockReleasedQuantity.inc(releasedQuantity);\n  \n  log.info('Stock release completed', {\n    releasedCount,\n    releasedQuantity,\n    productUpdates,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return {\n    success: errors.length === 0,\n    releasedCount,\n    releasedQuantity,\n    productUpdates,\n    errors\n  };\n}\n\nexport const stockReleaseWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.STOCK_RELEASE,\n  processStockRelease,\n  {\n    concurrency: 15,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-f",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE transaction pentru atomicitate",
    "FOLOSEȘTE GREATEST pentru a evita negative reserved_stock",
    "LOGHEAZĂ stock_movements pentru audit",
    "SUPORTĂ multiple release types",
    "GRUPEAZĂ updates per produs pentru eficiență"
  ],
  "validare_task": "1. Multiple release types suportate\n2. Transaction atomic pentru release\n3. Reserved_stock decrementat corect\n4. Stock movements logged pentru audit\n5. Batch update per produs",
  "outcome": "Worker stock:release funcțional pentru eliberare rezervări cu audit complet"
}
```

---

# FAZA F3.9: E-FACTURA SPV WORKERS (CATEGORIA H)

## F3.9.1 e-Factura Generate Worker (#46)

```json
{
  "taskID": "F3.9.1.T001",
  "denumire_task": "Implementare worker efactura:generate pentru generare XML UBL 2.1",
  "context_anterior": "Oblio integration complete. Acum implementăm generarea XML e-Factura conform standardului UBL 2.1 CIUS-RO.",
  "descriere_task": "Ești un expert în e-Factura România și UBL 2.1. Task-ul tău este să creezi workerul pentru generare XML conform CIUS-RO.\n\nCreează fișierul /packages/workers/src/etapa3/category-h/efactura-generate.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { invoices, invoiceItems, efacturaSubmissions } from '@cerniq/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { createHash } from 'crypto';\nimport { XMLBuilder } from 'fast-xml-parser';\n\nconst EfacturaGeneratePayload = z.object({\n  tenantId: z.string().uuid(),\n  invoiceId: z.string().uuid(),\n  submissionType: z.enum(['upload', 'storno']).default('upload'),\n  options: z.object({\n    validateBeforeSubmit: z.boolean().default(true),\n    saveXmlLocally: z.boolean().default(true)\n  }).optional()\n});\n\ntype EfacturaGenerateJob = z.infer<typeof EfacturaGeneratePayload>;\n\ninterface EfacturaGenerateResult {\n  success: boolean;\n  invoiceId: string;\n  xmlContent?: string;\n  xmlHash?: string;\n  xmlSize?: number;\n  validationErrors?: string[];\n  submissionId?: string;\n}\n\nasync function processEfacturaGenerate(job: Job<EfacturaGenerateJob>): Promise<EfacturaGenerateResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, invoiceId: job.data.invoiceId });\n  \n  const { tenantId, invoiceId, submissionType, options } = job.data;\n  \n  log.info('Generating e-Factura XML', { submissionType });\n  \n  try {\n    // Load invoice with items\n    const invoice = await db.query.invoices.findFirst({\n      where: eq(invoices.id, invoiceId),\n      with: {\n        items: true\n      }\n    });\n    \n    if (!invoice) {\n      throw new Error(`Invoice not found: ${invoiceId}`);\n    }\n    \n    if (invoice.tenantId !== tenantId) {\n      throw new Error('Tenant mismatch');\n    }\n    \n    // Build UBL 2.1 XML structure\n    const ublInvoice = buildUBLInvoice(invoice, submissionType);\n    \n    // Convert to XML string\n    const builder = new XMLBuilder({\n      ignoreAttributes: false,\n      format: true,\n      indentBy: '  ',\n      suppressEmptyNode: true,\n      attributeNamePrefix: '@_'\n    });\n    \n    const xmlContent = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + builder.build(ublInvoice);\n    \n    // Calculate hash for integrity\n    const xmlHash = createHash('sha256').update(xmlContent).digest('hex');\n    const xmlSize = Buffer.byteLength(xmlContent, 'utf8');\n    \n    // Validate if requested\n    let validationErrors: string[] = [];\n    if (options?.validateBeforeSubmit !== false) {\n      validationErrors = validateEfacturaXML(xmlContent, invoice);\n      \n      if (validationErrors.length > 0) {\n        log.warn('e-Factura validation errors', { errors: validationErrors });\n        \n        // Queue HITL for validation issues\n        const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n        await hitlQueue.add('escalate', {\n          tenantId,\n          entityType: 'invoice',\n          entityId: invoiceId,\n          reason: 'efactura_validation_failed',\n          errorDetails: validationErrors,\n          priority: 'high'\n        });\n        \n        return {\n          success: false,\n          invoiceId,\n          validationErrors\n        };\n      }\n    }\n    \n    // Create submission record\n    const submission = await db.insert(efacturaSubmissions).values({\n      tenantId,\n      invoiceId,\n      submissionType,\n      xmlContent,\n      xmlHash,\n      xmlSize,\n      status: 'pending',\n      createdAt: new Date()\n    }).returning();\n    \n    // Update invoice with XML\n    await db.update(invoices)\n      .set({\n        efacturaXml: xmlContent,\n        efacturaStatus: 'pending',\n        updatedAt: new Date()\n      })\n      .where(eq(invoices.id, invoiceId));\n    \n    // Queue validation worker\n    const validateQueue = createEtapa3Queue(ETAPA3_QUEUES.EFACTURA_VALIDATE);\n    await validateQueue.add('validate', {\n      tenantId,\n      submissionId: submission[0].id\n    }, { delay: 1000 });\n    \n    metrics.efacturaGenerated.inc({ type: submissionType });\n    \n    log.info('e-Factura XML generated', {\n      submissionId: submission[0].id,\n      xmlSize,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      invoiceId,\n      xmlContent: options?.saveXmlLocally ? xmlContent : undefined,\n      xmlHash,\n      xmlSize,\n      submissionId: submission[0].id\n    };\n    \n  } catch (error) {\n    log.error('e-Factura generation failed', { error });\n    metrics.efacturaErrors.inc({ stage: 'generate' });\n    throw error;\n  }\n}\n\nfunction buildUBLInvoice(invoice: any, submissionType: string): any {\n  const isStorno = submissionType === 'storno';\n  const invoiceTypeCode = isStorno ? '381' : '380'; // 381 = Credit Note, 380 = Invoice\n  \n  return {\n    'Invoice': {\n      '@_xmlns': 'urn:oasis:names:specification:ubl:schema:xsd:Invoice-2',\n      '@_xmlns:cac': 'urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2',\n      '@_xmlns:cbc': 'urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2',\n      \n      'cbc:CustomizationID': 'urn:cen.eu:en16931:2017#compliant#urn:efactura.mfinante.ro:CIUS-RO:1.0.1',\n      'cbc:ID': invoice.documentNumber,\n      'cbc:IssueDate': formatDate(invoice.issueDate),\n      'cbc:DueDate': formatDate(invoice.dueDate),\n      'cbc:InvoiceTypeCode': invoiceTypeCode,\n      'cbc:DocumentCurrencyCode': invoice.currency || 'RON',\n      \n      // Supplier (AccountingSupplierParty)\n      'cac:AccountingSupplierParty': {\n        'cac:Party': {\n          'cac:PartyIdentification': {\n            'cbc:ID': { '@_schemeID': 'RO:CUI', '#text': invoice.supplierCui }\n          },\n          'cac:PartyName': {\n            'cbc:Name': invoice.supplierName\n          },\n          'cac:PostalAddress': {\n            'cbc:StreetName': invoice.supplierAddress,\n            'cbc:CityName': invoice.supplierCity,\n            'cbc:CountrySubentity': invoice.supplierCounty,\n            'cac:Country': {\n              'cbc:IdentificationCode': invoice.supplierCountry || 'RO'\n            }\n          },\n          'cac:PartyTaxScheme': {\n            'cbc:CompanyID': `RO${invoice.supplierCui}`,\n            'cac:TaxScheme': {\n              'cbc:ID': 'VAT'\n            }\n          },\n          'cac:PartyLegalEntity': {\n            'cbc:RegistrationName': invoice.supplierName,\n            'cbc:CompanyID': invoice.supplierRegCom\n          }\n        }\n      },\n      \n      // Client (AccountingCustomerParty)\n      'cac:AccountingCustomerParty': {\n        'cac:Party': {\n          'cac:PartyIdentification': {\n            'cbc:ID': { '@_schemeID': 'RO:CUI', '#text': invoice.clientCui }\n          },\n          'cac:PartyName': {\n            'cbc:Name': invoice.clientName\n          },\n          'cac:PostalAddress': {\n            'cbc:StreetName': invoice.clientAddress,\n            'cbc:CityName': invoice.clientCity,\n            'cbc:CountrySubentity': invoice.clientCounty,\n            'cac:Country': {\n              'cbc:IdentificationCode': invoice.clientCountry || 'RO'\n            }\n          },\n          'cac:PartyTaxScheme': {\n            'cbc:CompanyID': invoice.clientVatPayer ? `RO${invoice.clientCui}` : invoice.clientCui,\n            'cac:TaxScheme': {\n              'cbc:ID': 'VAT'\n            }\n          },\n          'cac:PartyLegalEntity': {\n            'cbc:RegistrationName': invoice.clientName,\n            'cbc:CompanyID': invoice.clientRegCom || invoice.clientCui\n          }\n        }\n      },\n      \n      // Payment means\n      'cac:PaymentMeans': {\n        'cbc:PaymentMeansCode': invoice.paymentMethod === 'transfer' ? '30' : '10',\n        'cac:PayeeFinancialAccount': invoice.supplierIban ? {\n          'cbc:ID': invoice.supplierIban,\n          'cbc:Name': invoice.supplierBank\n        } : undefined\n      },\n      \n      // Tax total\n      'cac:TaxTotal': {\n        'cbc:TaxAmount': {\n          '@_currencyID': invoice.currency || 'RON',\n          '#text': parseFloat(invoice.vatAmount).toFixed(2)\n        },\n        'cac:TaxSubtotal': {\n          'cbc:TaxableAmount': {\n            '@_currencyID': invoice.currency || 'RON',\n            '#text': parseFloat(invoice.subtotal).toFixed(2)\n          },\n          'cbc:TaxAmount': {\n            '@_currencyID': invoice.currency || 'RON',\n            '#text': parseFloat(invoice.vatAmount).toFixed(2)\n          },\n          'cac:TaxCategory': {\n            'cbc:ID': 'S',\n            'cbc:Percent': '19',\n            'cac:TaxScheme': {\n              'cbc:ID': 'VAT'\n            }\n          }\n        }\n      },\n      \n      // Monetary total\n      'cac:LegalMonetaryTotal': {\n        'cbc:LineExtensionAmount': {\n          '@_currencyID': invoice.currency || 'RON',\n          '#text': parseFloat(invoice.subtotal).toFixed(2)\n        },\n        'cbc:TaxExclusiveAmount': {\n          '@_currencyID': invoice.currency || 'RON',\n          '#text': parseFloat(invoice.subtotal).toFixed(2)\n        },\n        'cbc:TaxInclusiveAmount': {\n          '@_currencyID': invoice.currency || 'RON',\n          '#text': parseFloat(invoice.totalAmount).toFixed(2)\n        },\n        'cbc:PayableAmount': {\n          '@_currencyID': invoice.currency || 'RON',\n          '#text': parseFloat(invoice.totalAmount).toFixed(2)\n        }\n      },\n      \n      // Invoice lines\n      'cac:InvoiceLine': invoice.items.map((item: any, index: number) => ({\n        'cbc:ID': item.lineNumber || index + 1,\n        'cbc:InvoicedQuantity': {\n          '@_unitCode': mapUnitCode(item.unitOfMeasure),\n          '#text': parseFloat(item.quantity).toFixed(4)\n        },\n        'cbc:LineExtensionAmount': {\n          '@_currencyID': invoice.currency || 'RON',\n          '#text': parseFloat(item.lineSubtotal).toFixed(2)\n        },\n        'cac:Item': {\n          'cbc:Name': item.name,\n          'cbc:Description': item.description || item.name,\n          'cac:SellersItemIdentification': {\n            'cbc:ID': item.sku\n          },\n          'cac:CommodityClassification': item.ncCode ? {\n            'cbc:ItemClassificationCode': {\n              '@_listID': 'STI',\n              '#text': item.ncCode\n            }\n          } : undefined,\n          'cac:ClassifiedTaxCategory': {\n            'cbc:ID': item.vatCategory || 'S',\n            'cbc:Percent': parseFloat(item.vatRate).toFixed(0),\n            'cac:TaxScheme': {\n              'cbc:ID': 'VAT'\n            }\n          }\n        },\n        'cac:Price': {\n          'cbc:PriceAmount': {\n            '@_currencyID': invoice.currency || 'RON',\n            '#text': parseFloat(item.unitPriceWithoutVat || item.unitPrice).toFixed(4)\n          }\n        }\n      }))\n    }\n  };\n}\n\nfunction formatDate(date: Date | string): string {\n  const d = new Date(date);\n  return d.toISOString().split('T')[0];\n}\n\nfunction mapUnitCode(unit: string): string {\n  const unitMap: Record<string, string> = {\n    'BUC': 'C62',\n    'KG': 'KGM',\n    'L': 'LTR',\n    'M': 'MTR',\n    'M2': 'MTK',\n    'M3': 'MTQ',\n    'T': 'TNE',\n    'ORA': 'HUR',\n    'ZI': 'DAY'\n  };\n  return unitMap[unit?.toUpperCase()] || 'C62';\n}\n\nfunction validateEfacturaXML(xml: string, invoice: any): string[] {\n  const errors: string[] = [];\n  \n  // Basic validations\n  if (!invoice.supplierCui) errors.push('Lipsește CUI furnizor');\n  if (!invoice.clientCui) errors.push('Lipsește CUI client');\n  if (!invoice.documentNumber) errors.push('Lipsește număr document');\n  if (!invoice.issueDate) errors.push('Lipsește data emiterii');\n  if (!invoice.items?.length) errors.push('Factura nu are linii');\n  \n  // Validate CUI format\n  if (invoice.supplierCui && !/^\\d{2,10}$/.test(invoice.supplierCui.replace('RO', ''))) {\n    errors.push('CUI furnizor invalid');\n  }\n  if (invoice.clientCui && !/^\\d{2,10}$/.test(invoice.clientCui.replace('RO', ''))) {\n    errors.push('CUI client invalid');\n  }\n  \n  // Validate amounts\n  const calculatedSubtotal = invoice.items?.reduce((sum: number, item: any) => \n    sum + parseFloat(item.lineSubtotal || 0), 0) || 0;\n    \n  if (Math.abs(calculatedSubtotal - parseFloat(invoice.subtotal)) > 0.01) {\n    errors.push(`Subtotal incorect: calculat ${calculatedSubtotal}, declarat ${invoice.subtotal}`);\n  }\n  \n  return errors;\n}\n\nexport const efacturaGenerateWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.EFACTURA_GENERATE,\n  processEfacturaGenerate,\n  {\n    concurrency: 5,\n    limiter: {\n      max: 20,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-h",
  "restrictii_antihalucinatie": [
    "RESPECTĂ format UBL 2.1 CIUS-RO strict",
    "VALIDEAZĂ CUI format și totaluri înainte de submit",
    "MAPEAZĂ unit codes conform UN/ECE Rec 20",
    "CALCULEAZĂ hash SHA256 pentru integritate XML",
    "ESCALARE HITL pe validation errors"
  ],
  "validare_task": "1. XML UBL 2.1 generat corect\n2. Toate câmpurile obligatorii populate\n3. Validări pre-submit\n4. Hash și size calculate\n5. Submission record creat",
  "outcome": "Worker efactura:generate funcțional pentru generare XML UBL 2.1 CIUS-RO"
}
```

## F3.9.2 e-Factura Submit Worker (#48)

```json
{
  "taskID": "F3.9.2.T001",
  "denumire_task": "Implementare worker efactura:submit pentru trimitere la ANAF SPV",
  "context_anterior": "e-Factura XML generat. Acum implementăm submiterea către ANAF SPV.",
  "descriere_task": "Ești un expert în integrări ANAF și OAuth2. Task-ul tău este să creezi workerul pentru submit la SPV.\n\nCreează fișierul /packages/workers/src/etapa3/category-h/efactura-submit.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { invoices, efacturaSubmissions, tenants } from '@cerniq/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport axios from 'axios';\nimport { redis } from '@cerniq/cache';\n\n// ANAF SPV Configuration\nconst ANAF_CONFIG = {\n  production: {\n    authUrl: 'https://logincert.anaf.ro/anaf-oauth2/v1/authorize',\n    tokenUrl: 'https://logincert.anaf.ro/anaf-oauth2/v1/token',\n    apiUrl: 'https://api.anaf.ro/prod/FCTEL/rest'\n  },\n  test: {\n    authUrl: 'https://logincert.anaf.ro/anaf-oauth2/v1/authorize',\n    tokenUrl: 'https://logincert.anaf.ro/anaf-oauth2/v1/token',\n    apiUrl: 'https://api.anaf.ro/test/FCTEL/rest'\n  }\n};\n\nconst EfacturaSubmitPayload = z.object({\n  tenantId: z.string().uuid(),\n  submissionId: z.string().uuid(),\n  environment: z.enum(['production', 'test']).default('production')\n});\n\ntype EfacturaSubmitJob = z.infer<typeof EfacturaSubmitPayload>;\n\ninterface EfacturaSubmitResult {\n  success: boolean;\n  submissionId: string;\n  uploadIndex?: string;\n  executionStatus?: string;\n  error?: string;\n}\n\nasync function processEfacturaSubmit(job: Job<EfacturaSubmitJob>): Promise<EfacturaSubmitResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, submissionId: job.data.submissionId });\n  \n  const { tenantId, submissionId, environment } = job.data;\n  const config = ANAF_CONFIG[environment];\n  \n  log.info('Submitting e-Factura to ANAF SPV', { environment });\n  \n  try {\n    // Load submission\n    const submission = await db.query.efacturaSubmissions.findFirst({\n      where: eq(efacturaSubmissions.id, submissionId)\n    });\n    \n    if (!submission) {\n      throw new Error(`Submission not found: ${submissionId}`);\n    }\n    \n    // Load tenant for ANAF credentials\n    const tenant = await db.query.tenants.findFirst({\n      where: eq(tenants.id, tenantId)\n    });\n    \n    if (!tenant?.anafAccessToken) {\n      throw new Error('ANAF credentials not configured for tenant');\n    }\n    \n    // Check/refresh token\n    const accessToken = await getValidToken(tenant, config);\n    \n    // Load invoice for CUI\n    const invoice = await db.query.invoices.findFirst({\n      where: eq(invoices.id, submission.invoiceId)\n    });\n    \n    if (!invoice) {\n      throw new Error('Invoice not found');\n    }\n    \n    // Submit to ANAF\n    const uploadResponse = await axios.post(\n      `${config.apiUrl}/upload`,\n      submission.xmlContent,\n      {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Content-Type': 'application/xml',\n          'Accept': 'application/json'\n        },\n        params: {\n          cif: invoice.supplierCui,\n          standard: 'UBL'\n        },\n        timeout: 30000\n      }\n    );\n    \n    const responseData = uploadResponse.data;\n    \n    log.info('ANAF upload response', { \n      status: uploadResponse.status,\n      data: responseData \n    });\n    \n    // Extract upload index\n    const uploadIndex = responseData?.index_incarcare || responseData?.uploadIndex;\n    const executionStatus = responseData?.ExecutionStatus || 0;\n    \n    if (!uploadIndex) {\n      throw new Error('No upload index received from ANAF');\n    }\n    \n    // Update submission\n    await db.update(efacturaSubmissions)\n      .set({\n        uploadIndex,\n        executionStatus: executionStatus.toString(),\n        status: 'submitted',\n        submittedAt: new Date(),\n        lastCheckedAt: new Date(),\n        nextCheckAt: new Date(Date.now() + 60000), // Check in 1 minute\n        checkAttempts: 0\n      })\n      .where(eq(efacturaSubmissions.id, submissionId));\n    \n    // Update invoice\n    await db.update(invoices)\n      .set({\n        efacturaUploadIndex: uploadIndex,\n        efacturaStatus: 'submitted',\n        efacturaSubmittedAt: new Date(),\n        updatedAt: new Date()\n      })\n      .where(eq(invoices.id, submission.invoiceId));\n    \n    // Queue polling job\n    const pollQueue = createEtapa3Queue(ETAPA3_QUEUES.EFACTURA_POLL);\n    await pollQueue.add('poll', {\n      tenantId,\n      submissionId,\n      uploadIndex,\n      environment\n    }, { \n      delay: 60000, // 1 minute\n      jobId: `poll-${submissionId}`\n    });\n    \n    metrics.efacturaSubmitted.inc();\n    \n    log.info('e-Factura submitted successfully', {\n      uploadIndex,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      submissionId,\n      uploadIndex,\n      executionStatus: executionStatus.toString()\n    };\n    \n  } catch (error: any) {\n    log.error('e-Factura submission failed', { error: error.message });\n    metrics.efacturaErrors.inc({ stage: 'submit' });\n    \n    // Handle specific ANAF errors\n    const errorMessage = error.response?.data?.message || error.message;\n    \n    // Update submission with error\n    await db.update(efacturaSubmissions)\n      .set({\n        status: 'error',\n        errorMessage,\n        retryCount: sql`retry_count + 1`,\n        lastRetryAt: new Date()\n      })\n      .where(eq(efacturaSubmissions.id, submissionId));\n    \n    // Retry if under limit\n    if (job.attemptsMade < 3) {\n      throw error;\n    }\n    \n    // Escalate to HITL\n    const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n    await hitlQueue.add('escalate', {\n      tenantId,\n      entityType: 'efactura_submission',\n      entityId: submissionId,\n      reason: 'efactura_submit_failed',\n      errorDetails: errorMessage,\n      priority: 'critical'\n    });\n    \n    return {\n      success: false,\n      submissionId,\n      error: errorMessage\n    };\n  }\n}\n\nasync function getValidToken(tenant: any, config: any): Promise<string> {\n  const cacheKey = `anaf-token:${tenant.id}`;\n  \n  // Check cache\n  const cachedToken = await redis.get(cacheKey);\n  if (cachedToken) {\n    return cachedToken;\n  }\n  \n  // Check if token is still valid\n  if (tenant.anafTokenExpiry && new Date(tenant.anafTokenExpiry) > new Date()) {\n    await redis.setex(cacheKey, 3500, tenant.anafAccessToken); // Cache for ~1h\n    return tenant.anafAccessToken;\n  }\n  \n  // Refresh token\n  const refreshResponse = await axios.post(\n    config.tokenUrl,\n    new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token: tenant.anafRefreshToken,\n      client_id: process.env.ANAF_CLIENT_ID!,\n      client_secret: process.env.ANAF_CLIENT_SECRET!\n    }),\n    {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }\n  );\n  \n  const { access_token, refresh_token, expires_in } = refreshResponse.data;\n  \n  // Update tenant\n  await db.update(tenants)\n    .set({\n      anafAccessToken: access_token,\n      anafRefreshToken: refresh_token || tenant.anafRefreshToken,\n      anafTokenExpiry: new Date(Date.now() + expires_in * 1000),\n      updatedAt: new Date()\n    })\n    .where(eq(tenants.id, tenant.id));\n  \n  // Cache token\n  await redis.setex(cacheKey, expires_in - 100, access_token);\n  \n  return access_token;\n}\n\nexport const efacturaSubmitWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.EFACTURA_SUBMIT,\n  processEfacturaSubmit,\n  {\n    concurrency: 3,\n    limiter: {\n      max: 10,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-h",
  "restrictii_antihalucinatie": [
    "REFRESH token automat când expirat",
    "FOLOSEȘTE URL-uri ANAF corecte pentru production/test",
    "NU hardcoda credentials - din env și tenant config",
    "QUEUE polling automat după submit",
    "ESCALARE HITL după 3 retry failures"
  ],
  "validare_task": "1. OAuth2 token refresh funcțional\n2. Upload la ANAF API corect\n3. Upload index extras din răspuns\n4. Polling job scheduled automat\n5. Error handling cu HITL escalation",
  "outcome": "Worker efactura:submit funcțional pentru trimitere la ANAF SPV cu OAuth2"
}
```

## F3.9.3 e-Factura Poll Worker (#49)

```json
{
  "taskID": "F3.9.3.T001",
  "denumire_task": "Implementare worker efactura:poll pentru verificare status ANAF",
  "context_anterior": "e-Factura submit implementat. Acum implementăm polling-ul pentru status.",
  "descriere_task": "Ești un expert în polling patterns și ANAF API. Task-ul tău este să creezi workerul pentru verificare status periodic.\n\nCreează fișierul /packages/workers/src/etapa3/category-h/efactura-poll.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { invoices, efacturaSubmissions, tenants } from '@cerniq/db/schema';\nimport { eq, and, lt, isNotNull } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport axios from 'axios';\nimport { redis } from '@cerniq/cache';\n\nconst ANAF_API_URL = {\n  production: 'https://api.anaf.ro/prod/FCTEL/rest',\n  test: 'https://api.anaf.ro/test/FCTEL/rest'\n};\n\nconst EfacturaPollPayload = z.object({\n  tenantId: z.string().uuid(),\n  submissionId: z.string().uuid(),\n  uploadIndex: z.string(),\n  environment: z.enum(['production', 'test']).default('production')\n});\n\ntype EfacturaPollJob = z.infer<typeof EfacturaPollPayload>;\n\ninterface EfacturaPollResult {\n  success: boolean;\n  submissionId: string;\n  status: 'processing' | 'accepted' | 'rejected' | 'error';\n  downloadId?: string;\n  stare?: string;\n  errorCode?: string;\n  errorMessage?: string;\n  needsRetry: boolean;\n}\n\nasync function processEfacturaPoll(job: Job<EfacturaPollJob>): Promise<EfacturaPollResult> {\n  const log = logger.child({ jobId: job.id, submissionId: job.data.submissionId });\n  \n  const { tenantId, submissionId, uploadIndex, environment } = job.data;\n  const apiUrl = ANAF_API_URL[environment];\n  \n  log.info('Polling e-Factura status', { uploadIndex });\n  \n  try {\n    // Load submission\n    const submission = await db.query.efacturaSubmissions.findFirst({\n      where: eq(efacturaSubmissions.id, submissionId)\n    });\n    \n    if (!submission) {\n      throw new Error(`Submission not found: ${submissionId}`);\n    }\n    \n    // Check max attempts\n    const MAX_POLL_ATTEMPTS = 20; // ~20 minutes with exponential backoff\n    if ((submission.checkAttempts || 0) >= MAX_POLL_ATTEMPTS) {\n      log.error('Max poll attempts reached');\n      \n      await db.update(efacturaSubmissions)\n        .set({ status: 'error', errorMessage: 'Max poll attempts exceeded' })\n        .where(eq(efacturaSubmissions.id, submissionId));\n      \n      // Escalate\n      const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n      await hitlQueue.add('escalate', {\n        tenantId,\n        entityType: 'efactura_submission',\n        entityId: submissionId,\n        reason: 'efactura_poll_timeout',\n        priority: 'high'\n      });\n      \n      return {\n        success: false,\n        submissionId,\n        status: 'error',\n        errorMessage: 'Max poll attempts exceeded',\n        needsRetry: false\n      };\n    }\n    \n    // Get valid token\n    const tenant = await db.query.tenants.findFirst({\n      where: eq(tenants.id, tenantId)\n    });\n    \n    const accessToken = await getValidToken(tenant!);\n    \n    // Poll ANAF API\n    const statusResponse = await axios.get(\n      `${apiUrl}/stareMesaj`,\n      {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Accept': 'application/json'\n        },\n        params: {\n          id_incarcare: uploadIndex\n        },\n        timeout: 30000\n      }\n    );\n    \n    const statusData = statusResponse.data;\n    log.info('ANAF status response', { data: statusData });\n    \n    const stare = statusData?.stare || statusData?.Stare;\n    const downloadId = statusData?.id_descarcare || statusData?.downloadId;\n    const errorCode = statusData?.Errors?.[0]?.errorCode;\n    const errorMessage = statusData?.Errors?.[0]?.errorMessage;\n    \n    // Update submission\n    await db.update(efacturaSubmissions)\n      .set({\n        stare,\n        downloadId,\n        errorCode,\n        errorMessage,\n        checkAttempts: (submission.checkAttempts || 0) + 1,\n        lastCheckedAt: new Date()\n      })\n      .where(eq(efacturaSubmissions.id, submissionId));\n    \n    // Process based on status\n    if (stare === 'in prelucrare' || stare === 'in_processing') {\n      // Still processing - schedule next poll with exponential backoff\n      const attempt = (submission.checkAttempts || 0) + 1;\n      const delay = Math.min(60000 * Math.pow(1.5, attempt), 600000); // Max 10 minutes\n      \n      const pollQueue = createEtapa3Queue(ETAPA3_QUEUES.EFACTURA_POLL);\n      await pollQueue.add('poll', {\n        tenantId,\n        submissionId,\n        uploadIndex,\n        environment\n      }, { \n        delay,\n        jobId: `poll-${submissionId}-${attempt}`\n      });\n      \n      return {\n        success: true,\n        submissionId,\n        status: 'processing',\n        stare,\n        needsRetry: true\n      };\n    }\n    \n    if (stare === 'ok' || stare === 'accepted') {\n      // Accepted - download response\n      await db.update(efacturaSubmissions)\n        .set({\n          status: 'accepted',\n          completedAt: new Date()\n        })\n        .where(eq(efacturaSubmissions.id, submissionId));\n      \n      await db.update(invoices)\n        .set({\n          efacturaStatus: 'accepted',\n          efacturaDownloadId: downloadId,\n          efacturaResponseAt: new Date(),\n          updatedAt: new Date()\n        })\n        .where(eq(invoices.id, submission.invoiceId));\n      \n      // Queue download\n      if (downloadId) {\n        const downloadQueue = createEtapa3Queue(ETAPA3_QUEUES.EFACTURA_DOWNLOAD);\n        await downloadQueue.add('download', {\n          tenantId,\n          submissionId,\n          downloadId,\n          environment\n        });\n      }\n      \n      metrics.efacturaAccepted.inc();\n      \n      return {\n        success: true,\n        submissionId,\n        status: 'accepted',\n        downloadId,\n        stare,\n        needsRetry: false\n      };\n    }\n    \n    if (stare === 'nok' || stare === 'rejected') {\n      // Rejected\n      await db.update(efacturaSubmissions)\n        .set({\n          status: 'rejected',\n          errorCode,\n          errorMessage,\n          completedAt: new Date()\n        })\n        .where(eq(efacturaSubmissions.id, submissionId));\n      \n      await db.update(invoices)\n        .set({\n          efacturaStatus: 'rejected',\n          efacturaErrors: statusData.Errors,\n          efacturaResponseAt: new Date(),\n          updatedAt: new Date()\n        })\n        .where(eq(invoices.id, submission.invoiceId));\n      \n      // Escalate\n      const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_ESCALATE);\n      await hitlQueue.add('escalate', {\n        tenantId,\n        entityType: 'efactura_submission',\n        entityId: submissionId,\n        reason: 'efactura_rejected',\n        errorDetails: { errorCode, errorMessage, errors: statusData.Errors },\n        priority: 'critical'\n      });\n      \n      metrics.efacturaRejected.inc();\n      \n      return {\n        success: false,\n        submissionId,\n        status: 'rejected',\n        errorCode,\n        errorMessage,\n        needsRetry: false\n      };\n    }\n    \n    // Unknown status\n    log.warn('Unknown ANAF status', { stare });\n    return {\n      success: true,\n      submissionId,\n      status: 'processing',\n      stare,\n      needsRetry: true\n    };\n    \n  } catch (error: any) {\n    log.error('e-Factura poll failed', { error: error.message });\n    metrics.efacturaErrors.inc({ stage: 'poll' });\n    \n    // Retry with backoff\n    throw error;\n  }\n}\n\nasync function getValidToken(tenant: any): Promise<string> {\n  // Same implementation as in submit worker\n  const cacheKey = `anaf-token:${tenant.id}`;\n  const cachedToken = await redis.get(cacheKey);\n  if (cachedToken) return cachedToken;\n  \n  // ... token refresh logic\n  return tenant.anafAccessToken;\n}\n\nexport const efacturaPollWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.EFACTURA_POLL,\n  processEfacturaPoll,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 30,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-h",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE exponential backoff pentru polling - nu fixed interval",
    "MAX 20 poll attempts - apoi escalare HITL",
    "PROCESEAZĂ corect toate stările ANAF: in_prelucrare, ok, nok",
    "QUEUE download automat pe accept",
    "ESCALARE HITL pe rejection cu detalii eroare"
  ],
  "validare_task": "1. Polling cu exponential backoff\n2. Max attempts limit cu escalare\n3. Handling pentru toate stările ANAF\n4. Download queued pe accepted\n5. HITL escalation pe rejected",
  "outcome": "Worker efactura:poll funcțional pentru verificare status ANAF cu backoff"
}
```

---

# FAZA F3.10: DOCUMENT GENERATION WORKERS (CATEGORIA I)

## F3.10.1 Proposal Generator Worker (#51)

```json
{
  "taskID": "F3.10.1.T001",
  "denumire_task": "Implementare worker doc:proposal pentru generare oferte PDF",
  "context_anterior": "e-Factura workers finalizați. Acum implementăm generarea documentelor comerciale - oferte profesionale.",
  "descriere_task": "Ești un expert în generare documente PDF și template engines. Task-ul tău este să creezi workerul pentru generare oferte.\n\nCreează fișierul /packages/workers/src/etapa3/category-i/doc-proposal.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiations, contactsGold, products, documents, tenants } from '@cerniq/db/schema';\nimport { eq, inArray } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport PDFDocument from 'pdfkit';\nimport { v4 as uuidv4 } from 'uuid';\nimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';\nimport Handlebars from 'handlebars';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nconst ProposalGeneratorPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  templateId: z.string().optional(), // Custom template\n  options: z.object({\n    includeTerms: z.boolean().default(true),\n    includeBankDetails: z.boolean().default(true),\n    validityDays: z.number().default(30),\n    language: z.enum(['ro', 'en']).default('ro'),\n    format: z.enum(['pdf', 'docx']).default('pdf')\n  }).optional()\n});\n\ntype ProposalGeneratorJob = z.infer<typeof ProposalGeneratorPayload>;\n\ninterface ProposalResult {\n  success: boolean;\n  documentId: string;\n  documentNumber: string;\n  pdfUrl?: string;\n  pdfSize?: number;\n  pageCount?: number;\n}\n\nasync function processProposalGenerator(job: Job<ProposalGeneratorJob>): Promise<ProposalResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, negotiationId: job.data.negotiationId });\n  \n  const { tenantId, negotiationId, templateId, options } = job.data;\n  \n  log.info('Generating proposal document');\n  \n  try {\n    // Load all required data\n    const [negotiation, tenant] = await Promise.all([\n      db.query.negotiations.findFirst({\n        where: eq(negotiations.id, negotiationId),\n        with: { contact: true }\n      }),\n      db.query.tenants.findFirst({\n        where: eq(tenants.id, tenantId)\n      })\n    ]);\n    \n    if (!negotiation || !tenant) {\n      throw new Error('Negotiation or tenant not found');\n    }\n    \n    // Load products\n    const productIds = (negotiation.products as any[]).map(p => p.productId);\n    const productsData = await db.query.products.findMany({\n      where: inArray(products.id, productIds)\n    });\n    \n    // Create product lookup\n    const productMap = new Map(productsData.map(p => [p.id, p]));\n    \n    // Generate document number\n    const documentNumber = `OF-${new Date().getFullYear()}-${String(await getNextSequence(tenantId, 'proposal')).padStart(5, '0')}`;\n    \n    // Build proposal data\n    const proposalData = {\n      documentNumber,\n      date: new Date().toLocaleDateString('ro-RO'),\n      validUntil: new Date(Date.now() + (options?.validityDays || 30) * 24 * 60 * 60 * 1000).toLocaleDateString('ro-RO'),\n      \n      // Supplier (tenant)\n      supplier: {\n        name: tenant.companyName,\n        cui: tenant.cui,\n        regCom: tenant.regCom,\n        address: `${tenant.address}, ${tenant.city}, ${tenant.county}`,\n        phone: tenant.phone,\n        email: tenant.email,\n        iban: options?.includeBankDetails ? tenant.iban : undefined,\n        bank: options?.includeBankDetails ? tenant.bank : undefined,\n        logo: tenant.logoUrl\n      },\n      \n      // Client\n      client: {\n        name: negotiation.contact.companyName || negotiation.contact.name,\n        cui: negotiation.contact.cui,\n        address: `${negotiation.contact.address || ''}, ${negotiation.contact.city || ''}, ${negotiation.contact.county || ''}`,\n        email: negotiation.contact.email,\n        phone: negotiation.contact.phone,\n        contactPerson: negotiation.contact.contactPerson || negotiation.contact.name\n      },\n      \n      // Products\n      items: (negotiation.products as any[]).map((item, index) => {\n        const product = productMap.get(item.productId);\n        return {\n          nr: index + 1,\n          sku: item.sku || product?.sku,\n          name: item.name || product?.name,\n          description: product?.shortDescription || product?.description?.slice(0, 200),\n          unit: item.unitOfMeasure || product?.unitOfMeasure || 'BUC',\n          quantity: item.quantity,\n          unitPrice: item.unitPrice,\n          vatRate: item.vatRate || product?.vatRate || 19,\n          discount: item.discountPercent || 0,\n          lineTotal: item.quantity * item.unitPrice * (1 - (item.discountPercent || 0) / 100)\n        };\n      }),\n      \n      // Totals\n      subtotal: negotiation.totalValue || (negotiation.products as any[]).reduce((sum, p) => \n        sum + p.quantity * p.unitPrice * (1 - (p.discountPercent || 0) / 100), 0),\n      vatAmount: 0, // Calculate below\n      discount: negotiation.discountPercent || 0,\n      total: 0, // Calculate below\n      currency: 'RON',\n      \n      // Terms\n      terms: options?.includeTerms ? tenant.proposalTerms || getDefaultTerms(options?.language || 'ro') : undefined,\n      paymentTerms: tenant.paymentTerms || 'Plată în avans sau la livrare',\n      deliveryTerms: tenant.deliveryTerms || 'Livrare în 3-5 zile lucrătoare'\n    };\n    \n    // Calculate totals\n    proposalData.vatAmount = proposalData.items.reduce((sum, item) => \n      sum + item.lineTotal * item.vatRate / 100, 0);\n    proposalData.total = proposalData.subtotal + proposalData.vatAmount;\n    \n    // Generate PDF\n    const pdfBuffer = await generatePDF(proposalData, tenant);\n    \n    // Upload to S3\n    const s3Key = `documents/${tenantId}/proposals/${documentNumber}.pdf`;\n    const pdfUrl = await uploadToS3(s3Key, pdfBuffer);\n    \n    // Create document record\n    const document = await db.insert(documents).values({\n      id: uuidv4(),\n      tenantId,\n      negotiationId,\n      contactId: negotiation.contact.id,\n      documentType: 'proposal',\n      documentNumber,\n      title: `Ofertă ${documentNumber}`,\n      description: `Ofertă pentru ${negotiation.contact.companyName || negotiation.contact.name}`,\n      filePath: s3Key,\n      fileUrl: pdfUrl,\n      fileSize: pdfBuffer.length,\n      mimeType: 'application/pdf',\n      status: 'generated',\n      validUntil: new Date(Date.now() + (options?.validityDays || 30) * 24 * 60 * 60 * 1000),\n      metadata: {\n        items: proposalData.items.length,\n        total: proposalData.total,\n        currency: proposalData.currency\n      },\n      createdAt: new Date()\n    }).returning();\n    \n    metrics.documentsGenerated.inc({ type: 'proposal' });\n    \n    log.info('Proposal generated', {\n      documentId: document[0].id,\n      documentNumber,\n      size: pdfBuffer.length,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      documentId: document[0].id,\n      documentNumber,\n      pdfUrl,\n      pdfSize: pdfBuffer.length\n    };\n    \n  } catch (error) {\n    log.error('Proposal generation failed', { error });\n    metrics.documentErrors.inc({ type: 'proposal' });\n    throw error;\n  }\n}\n\nasync function generatePDF(data: any, tenant: any): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    const doc = new PDFDocument({ size: 'A4', margin: 50 });\n    \n    doc.on('data', chunks.push.bind(chunks));\n    doc.on('end', () => resolve(Buffer.concat(chunks)));\n    doc.on('error', reject);\n    \n    // Header with logo\n    if (tenant.logoUrl) {\n      // doc.image(logoBuffer, 50, 45, { width: 150 });\n    }\n    \n    doc.fontSize(20).font('Helvetica-Bold')\n       .text('OFERTĂ COMERCIALĂ', { align: 'center' });\n    doc.moveDown();\n    \n    doc.fontSize(12).font('Helvetica')\n       .text(`Nr: ${data.documentNumber}`, { align: 'right' })\n       .text(`Data: ${data.date}`, { align: 'right' })\n       .text(`Valabilă până: ${data.validUntil}`, { align: 'right' });\n    \n    doc.moveDown(2);\n    \n    // Two columns: Supplier and Client\n    const startY = doc.y;\n    \n    doc.fontSize(10).font('Helvetica-Bold').text('FURNIZOR:', 50);\n    doc.font('Helvetica')\n       .text(data.supplier.name)\n       .text(`CUI: ${data.supplier.cui}`)\n       .text(`Reg.Com: ${data.supplier.regCom || '-'}`)\n       .text(data.supplier.address)\n       .text(`Tel: ${data.supplier.phone || '-'}`)\n       .text(`Email: ${data.supplier.email || '-'}`);\n    \n    if (data.supplier.iban) {\n      doc.text(`IBAN: ${data.supplier.iban}`)\n         .text(`Banca: ${data.supplier.bank || '-'}`);\n    }\n    \n    doc.fontSize(10).font('Helvetica-Bold').text('CLIENT:', 300, startY);\n    doc.font('Helvetica')\n       .text(data.client.name, 300)\n       .text(`CUI: ${data.client.cui || '-'}`, 300)\n       .text(data.client.address, 300)\n       .text(`Contact: ${data.client.contactPerson || '-'}`, 300)\n       .text(`Tel: ${data.client.phone || '-'}`, 300)\n       .text(`Email: ${data.client.email || '-'}`, 300);\n    \n    doc.moveDown(3);\n    \n    // Products table\n    const tableTop = doc.y;\n    const tableHeaders = ['Nr', 'Cod', 'Denumire', 'UM', 'Cant', 'Preț', 'Disc%', 'Total'];\n    const colWidths = [25, 60, 150, 35, 40, 60, 40, 70];\n    let xPos = 50;\n    \n    doc.font('Helvetica-Bold').fontSize(9);\n    tableHeaders.forEach((header, i) => {\n      doc.text(header, xPos, tableTop, { width: colWidths[i], align: 'center' });\n      xPos += colWidths[i];\n    });\n    \n    doc.moveTo(50, tableTop + 15).lineTo(545, tableTop + 15).stroke();\n    \n    let yPos = tableTop + 20;\n    doc.font('Helvetica').fontSize(8);\n    \n    for (const item of data.items) {\n      xPos = 50;\n      doc.text(item.nr.toString(), xPos, yPos, { width: colWidths[0], align: 'center' });\n      xPos += colWidths[0];\n      doc.text(item.sku || '-', xPos, yPos, { width: colWidths[1] });\n      xPos += colWidths[1];\n      doc.text(item.name.slice(0, 40), xPos, yPos, { width: colWidths[2] });\n      xPos += colWidths[2];\n      doc.text(item.unit, xPos, yPos, { width: colWidths[3], align: 'center' });\n      xPos += colWidths[3];\n      doc.text(item.quantity.toString(), xPos, yPos, { width: colWidths[4], align: 'right' });\n      xPos += colWidths[4];\n      doc.text(item.unitPrice.toFixed(2), xPos, yPos, { width: colWidths[5], align: 'right' });\n      xPos += colWidths[5];\n      doc.text(item.discount ? `${item.discount}%` : '-', xPos, yPos, { width: colWidths[6], align: 'center' });\n      xPos += colWidths[6];\n      doc.text(item.lineTotal.toFixed(2), xPos, yPos, { width: colWidths[7], align: 'right' });\n      \n      yPos += 15;\n      if (yPos > 700) {\n        doc.addPage();\n        yPos = 50;\n      }\n    }\n    \n    doc.moveTo(50, yPos).lineTo(545, yPos).stroke();\n    yPos += 10;\n    \n    // Totals\n    doc.font('Helvetica').fontSize(10);\n    doc.text(`Subtotal: ${data.subtotal.toFixed(2)} ${data.currency}`, 400, yPos, { align: 'right' });\n    yPos += 15;\n    doc.text(`TVA (19%): ${data.vatAmount.toFixed(2)} ${data.currency}`, 400, yPos, { align: 'right' });\n    yPos += 15;\n    doc.font('Helvetica-Bold')\n       .text(`TOTAL: ${data.total.toFixed(2)} ${data.currency}`, 400, yPos, { align: 'right' });\n    \n    // Terms\n    if (data.terms) {\n      doc.moveDown(3);\n      doc.font('Helvetica-Bold').fontSize(10).text('TERMENI ȘI CONDIȚII:');\n      doc.font('Helvetica').fontSize(9).text(data.terms);\n    }\n    \n    // Footer\n    doc.fontSize(8)\n       .text('Document generat automat. Nu necesită semnătură.', 50, 780, { align: 'center' });\n    \n    doc.end();\n  });\n}\n\nasync function getNextSequence(tenantId: string, type: string): Promise<number> {\n  const result = await db.execute(\n    sql`SELECT nextval('${sql.raw(tenantId)}_${sql.raw(type)}_seq') as seq`\n  );\n  return parseInt(result.rows[0]?.seq || '1');\n}\n\nasync function uploadToS3(key: string, buffer: Buffer): Promise<string> {\n  const s3 = new S3Client({ region: process.env.AWS_REGION });\n  await s3.send(new PutObjectCommand({\n    Bucket: process.env.S3_DOCUMENTS_BUCKET!,\n    Key: key,\n    Body: buffer,\n    ContentType: 'application/pdf'\n  }));\n  return `https://${process.env.S3_DOCUMENTS_BUCKET}.s3.${process.env.AWS_REGION}.amazonaws.com/${key}`;\n}\n\nfunction getDefaultTerms(language: string): string {\n  if (language === 'ro') {\n    return `1. Prețurile sunt exprimate în RON și includ TVA 19%.\n2. Oferta este valabilă conform datei specificate.\n3. Livrarea se efectuează la adresa clientului.\n4. Plata se efectuează conform condițiilor agreate.\n5. Produsele beneficiază de garanție conform legislației în vigoare.`;\n  }\n  return `1. Prices are expressed in RON and include 19% VAT.\n2. The offer is valid according to the specified date.\n3. Delivery is made to the customer's address.\n4. Payment is made according to agreed terms.\n5. Products are covered by warranty according to applicable legislation.`;\n}\n\nexport const docProposalWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.DOC_PROPOSAL,\n  processProposalGenerator,\n  {\n    concurrency: 5,\n    limiter: {\n      max: 20,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-i",
  "restrictii_antihalucinatie": [
    "GENEREAZĂ PDF profesional cu layout consistent",
    "INCLUDE toate datele fiscale obligatorii",
    "UPLOAD la S3 și salvează URL în DB",
    "CREEAZĂ document record pentru tracking",
    "CALCULEAZĂ totaluri corect cu TVA"
  ],
  "validare_task": "1. PDF generat cu layout profesional\n2. Toate datele supplier/client incluse\n3. Tabel produse formatat corect\n4. Totaluri calculate corect\n5. Upload S3 și document record creat",
  "outcome": "Worker doc:proposal funcțional pentru generare oferte PDF profesionale"
}
```

---

# FAZA F3.12: SENTIMENT & INTENT WORKERS (CATEGORIA K)

## F3.12.1 Intent Detection Worker (#56)

```json
{
  "taskID": "F3.12.1.T001",
  "denumire_task": "Implementare worker intent:detect pentru detectare intent conversațional",
  "context_anterior": "Document generation workers finalizați. Acum implementăm detectarea intent-ului pentru orchestrarea AI.",
  "descriere_task": "Ești un expert în NLU și intent classification. Task-ul tău este să creezi workerul pentru detectare intent.\n\nCreează fișierul /packages/workers/src/etapa3/category-k/intent-detect.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { openai } from '@cerniq/ai-providers';\nimport { redis } from '@cerniq/cache';\n\nconst IntentDetectPayload = z.object({\n  tenantId: z.string().uuid(),\n  text: z.string().min(1).max(5000),\n  context: z.object({\n    negotiationState: z.string().optional(),\n    previousIntent: z.string().optional(),\n    previousMessages: z.array(z.string()).optional(),\n    contactType: z.string().optional()\n  }).optional(),\n  options: z.object({\n    detectSentiment: z.boolean().default(true),\n    detectUrgency: z.boolean().default(true),\n    suggestTransition: z.boolean().default(true),\n    useCache: z.boolean().default(true)\n  }).optional()\n});\n\ntype IntentDetectJob = z.infer<typeof IntentDetectPayload>;\n\n// Intent taxonomy for agricultural B2B sales\nconst INTENT_TAXONOMY = [\n  'PRODUCT_INQUIRY',      // Întrebări despre produse\n  'PRICE_INQUIRY',        // Întrebări despre prețuri\n  'STOCK_CHECK',          // Verificare disponibilitate\n  'DISCOUNT_REQUEST',     // Cerere de discount\n  'ORDER_INTENT',         // Intenție de comandă\n  'DELIVERY_INQUIRY',     // Întrebări despre livrare\n  'PAYMENT_INQUIRY',      // Întrebări despre plată\n  'COMPLAINT',            // Reclamație\n  'TECHNICAL_SUPPORT',    // Suport tehnic\n  'RECOMMENDATION',       // Cerere de recomandare\n  'NEGOTIATION',          // Negociere activă\n  'CONFIRMATION',         // Confirmare/Acceptare\n  'REJECTION',            // Refuz/Anulare\n  'CALLBACK_REQUEST',     // Cerere de apel înapoi\n  'HUMAN_TRANSFER',       // Cerere agent uman\n  'GREETING',             // Salut\n  'FAREWELL',             // La revedere\n  'GENERAL_CHAT',         // Conversație generală\n  'UNKNOWN'               // Necunoscut\n] as const;\n\ntype Intent = typeof INTENT_TAXONOMY[number];\n\ninterface IntentResult {\n  intent: Intent;\n  confidence: number;\n  subIntent?: string;\n  entities: Array<{\n    type: string;\n    value: string;\n    confidence: number;\n  }>;\n  sentiment?: {\n    score: number;      // -1 to 1\n    label: 'negative' | 'neutral' | 'positive';\n    confidence: number;\n  };\n  urgency?: {\n    level: 'low' | 'medium' | 'high' | 'critical';\n    indicators: string[];\n  };\n  suggestedTransition?: string;\n  reasoning?: string;\n}\n\nasync function processIntentDetect(job: Job<IntentDetectJob>): Promise<IntentResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, tenantId: job.data.tenantId });\n  \n  const { text, context, options } = job.data;\n  \n  log.info('Detecting intent', { textLength: text.length });\n  \n  // Check cache\n  if (options?.useCache !== false) {\n    const cacheKey = `intent:${hashText(text, context)}`;\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n      log.info('Intent cache hit');\n      return JSON.parse(cached);\n    }\n  }\n  \n  // Build prompt for intent detection\n  const systemPrompt = buildIntentSystemPrompt(context);\n  const userPrompt = buildIntentUserPrompt(text, options);\n  \n  // Call LLM for intent detection\n  const response = await openai.chat.completions.create({\n    model: 'gpt-4o-mini', // Fast and cost-effective for classification\n    messages: [\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: userPrompt }\n    ],\n    temperature: 0.1, // Low temperature for consistency\n    max_tokens: 500,\n    response_format: { type: 'json_object' }\n  });\n  \n  const rawResult = JSON.parse(response.choices[0].message.content || '{}');\n  \n  // Parse and validate result\n  const result: IntentResult = {\n    intent: validateIntent(rawResult.intent),\n    confidence: Math.min(1, Math.max(0, rawResult.confidence || 0.5)),\n    subIntent: rawResult.subIntent,\n    entities: parseEntities(rawResult.entities),\n    sentiment: options?.detectSentiment ? parseSentiment(rawResult.sentiment) : undefined,\n    urgency: options?.detectUrgency ? parseUrgency(rawResult.urgency) : undefined,\n    suggestedTransition: options?.suggestTransition ? \n      mapIntentToTransition(rawResult.intent, context?.negotiationState) : undefined,\n    reasoning: rawResult.reasoning\n  };\n  \n  // Cache result\n  if (options?.useCache !== false && result.confidence > 0.7) {\n    const cacheKey = `intent:${hashText(text, context)}`;\n    await redis.setex(cacheKey, 3600, JSON.stringify(result)); // 1 hour cache\n  }\n  \n  // Update metrics\n  metrics.intentDetectionLatency.observe(Date.now() - startTime);\n  metrics.intentDetected.inc({ intent: result.intent });\n  if (result.sentiment) {\n    metrics.sentimentDetected.inc({ label: result.sentiment.label });\n  }\n  \n  log.info('Intent detected', {\n    intent: result.intent,\n    confidence: result.confidence,\n    sentiment: result.sentiment?.label,\n    urgency: result.urgency?.level,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return result;\n}\n\nfunction buildIntentSystemPrompt(context?: any): string {\n  return `Ești un expert în analiza conversațiilor de vânzări B2B pentru produse agricole în România.\n\nTask: Analizează mesajul clientului și detectează:\n1. INTENT principal (din lista: ${INTENT_TAXONOMY.join(', ')})\n2. Entități menționate (produse, cantități, prețuri, date)\n3. Sentiment (pozitiv/neutru/negativ)\n4. Urgență (low/medium/high/critical)\n\nContext curent:\n- Stare negociere: ${context?.negotiationState || 'necunoscut'}\n- Intent anterior: ${context?.previousIntent || 'necunoscut'}\n\nRăspunde DOAR în JSON cu structura:\n{\n  \"intent\": \"<INTENT_NAME>\",\n  \"confidence\": <0.0-1.0>,\n  \"subIntent\": \"<detaliu optional>\",\n  \"entities\": [{\"type\": \"...\", \"value\": \"...\", \"confidence\": <0-1>}],\n  \"sentiment\": {\"score\": <-1 to 1>, \"label\": \"...\", \"confidence\": <0-1>},\n  \"urgency\": {\"level\": \"...\", \"indicators\": [\"...\"]},\n  \"reasoning\": \"<explicație scurtă>\"\n}`;\n}\n\nfunction buildIntentUserPrompt(text: string, options?: any): string {\n  let prompt = `Analizează acest mesaj de la un client:\\n\\n\"${text}\"\\n\\n`;\n  \n  if (!options?.detectSentiment) {\n    prompt += 'NU include analiza sentiment.\\n';\n  }\n  if (!options?.detectUrgency) {\n    prompt += 'NU include analiza urgență.\\n';\n  }\n  \n  return prompt;\n}\n\nfunction validateIntent(intent: string): Intent {\n  const normalized = intent?.toUpperCase().replace(/[^A-Z_]/g, '');\n  if (INTENT_TAXONOMY.includes(normalized as Intent)) {\n    return normalized as Intent;\n  }\n  return 'UNKNOWN';\n}\n\nfunction parseEntities(raw: any[]): Array<{ type: string; value: string; confidence: number }> {\n  if (!Array.isArray(raw)) return [];\n  \n  return raw.map(e => ({\n    type: e.type || 'unknown',\n    value: String(e.value || ''),\n    confidence: Math.min(1, Math.max(0, e.confidence || 0.5))\n  })).filter(e => e.value.length > 0);\n}\n\nfunction parseSentiment(raw: any): IntentResult['sentiment'] | undefined {\n  if (!raw) return undefined;\n  \n  const score = Math.min(1, Math.max(-1, raw.score || 0));\n  let label: 'negative' | 'neutral' | 'positive';\n  \n  if (score < -0.3) label = 'negative';\n  else if (score > 0.3) label = 'positive';\n  else label = 'neutral';\n  \n  return {\n    score,\n    label: raw.label || label,\n    confidence: Math.min(1, Math.max(0, raw.confidence || 0.7))\n  };\n}\n\nfunction parseUrgency(raw: any): IntentResult['urgency'] | undefined {\n  if (!raw) return undefined;\n  \n  const validLevels = ['low', 'medium', 'high', 'critical'];\n  const level = validLevels.includes(raw.level) ? raw.level : 'medium';\n  \n  return {\n    level,\n    indicators: Array.isArray(raw.indicators) ? raw.indicators : []\n  };\n}\n\nfunction mapIntentToTransition(intent: string, currentState?: string): string | undefined {\n  const transitionMap: Record<string, Record<string, string>> = {\n    'ORDER_INTENT': {\n      'NEEDS_DISCOVERY': 'PRODUCT_PRESENTATION',\n      'PRODUCT_PRESENTATION': 'PRICE_NEGOTIATION',\n      'PRICE_NEGOTIATION': 'PROPOSAL_SENT',\n      'PROPOSAL_SENT': 'VERBAL_AGREEMENT'\n    },\n    'CONFIRMATION': {\n      'PROPOSAL_SENT': 'VERBAL_AGREEMENT',\n      'AWAITING_DECISION': 'VERBAL_AGREEMENT',\n      'CONTRACT_SENT': 'CONTRACT_SIGNED'\n    },\n    'REJECTION': {\n      '*': 'LOST'\n    },\n    'HUMAN_TRANSFER': {\n      '*': 'REQUIRES_HUMAN'\n    },\n    'COMPLAINT': {\n      '*': 'REQUIRES_HUMAN'\n    }\n  };\n  \n  const intentTransitions = transitionMap[intent];\n  if (!intentTransitions) return undefined;\n  \n  return intentTransitions[currentState || ''] || intentTransitions['*'];\n}\n\nfunction hashText(text: string, context?: any): string {\n  const crypto = require('crypto');\n  const data = JSON.stringify({ text: text.toLowerCase().trim(), state: context?.negotiationState });\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\nexport const intentDetectWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.INTENT_DETECT,\n  processIntentDetect,\n  {\n    concurrency: 20,\n    limiter: {\n      max: 100,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-k",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE taxonomy fixă de intents - nu inventa noi categorii",
    "VALIDEAZĂ output LLM contra schema definită",
    "CACHE results pentru queries similare",
    "MAPEAZĂ intent la transition doar pentru combinații valide",
    "INCLUDE reasoning pentru debugging"
  ],
  "validare_task": "1. Intent detectat din taxonomy fixă\n2. Confidence score normalized 0-1\n3. Entities extracted corect\n4. Sentiment și urgency opționale\n5. Transition suggestion bazată pe FSM",
  "outcome": "Worker intent:detect funcțional pentru clasificare intent conversațional"
}
```

---

# FAZA F3.14: GUARDRAILS WORKERS (CATEGORIA M)

## F3.14.1 Price Guardrail Worker (#66)

```json
{
  "taskID": "F3.14.1.T001",
  "denumire_task": "Implementare worker guard:price pentru validare prețuri în răspunsuri AI",
  "context_anterior": "Sentiment și intent workers finalizați. Acum implementăm guardrails - critice pentru prevenirea halucinațiilor.",
  "descriere_task": "Ești un expert în AI safety și guardrails. Task-ul tău este să creezi workerul pentru validare prețuri menționate în răspunsuri AI.\n\nCreează fișierul /packages/workers/src/etapa3/category-m/guard-price.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products } from '@cerniq/db/schema';\nimport { eq, and, inArray } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\n\nconst PriceGuardrailPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  responseContent: z.string(),\n  toolCalls: z.array(z.object({\n    name: z.string(),\n    input: z.any(),\n    result: z.any()\n  })).optional(),\n  ragContext: z.array(z.object({\n    sku: z.string(),\n    basePrice: z.number(),\n    priceWithVat: z.number()\n  })).optional()\n});\n\ntype PriceGuardrailJob = z.infer<typeof PriceGuardrailPayload>;\n\ninterface PriceValidation {\n  mentioned: string;           // Price mentioned in response\n  product?: string;            // Associated product\n  expectedPrice?: number;      // Correct price from DB\n  isValid: boolean;\n  variance?: number;           // Percentage variance\n  issue?: string;\n}\n\ninterface GuardrailResult {\n  passed: boolean;\n  checkType: 'price';\n  validations: PriceValidation[];\n  failures: string[];\n  correctionPrompt?: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n}\n\nasync function processPriceGuardrail(job: Job<PriceGuardrailJob>): Promise<GuardrailResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, negotiationId: job.data.negotiationId });\n  \n  const { tenantId, responseContent, toolCalls, ragContext } = job.data;\n  \n  log.info('Running price guardrail check');\n  \n  const validations: PriceValidation[] = [];\n  const failures: string[] = [];\n  \n  // Extract prices mentioned in response\n  const mentionedPrices = extractPrices(responseContent);\n  \n  log.info('Prices found in response', { count: mentionedPrices.length });\n  \n  // Get valid prices from tool results first\n  const toolPrices = new Map<string, number>();\n  if (toolCalls) {\n    for (const call of toolCalls) {\n      if (call.name === 'get_product_info' || call.name === 'calculate_price') {\n        const result = call.result;\n        if (result?.price) toolPrices.set(result.sku, result.price);\n        if (result?.priceWithVat) toolPrices.set(result.sku, result.priceWithVat);\n        if (result?.items) {\n          for (const item of result.items) {\n            if (item.sku && item.unitPriceWithVat) {\n              toolPrices.set(item.sku, item.unitPriceWithVat);\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Get valid prices from RAG context\n  const ragPrices = new Map<string, number>();\n  if (ragContext) {\n    for (const product of ragContext) {\n      ragPrices.set(product.sku, product.priceWithVat);\n    }\n  }\n  \n  // Validate each mentioned price\n  for (const mentioned of mentionedPrices) {\n    const validation: PriceValidation = {\n      mentioned: mentioned.value,\n      product: mentioned.context,\n      isValid: false\n    };\n    \n    // Try to find matching product\n    const matchedSku = findMatchingSku(mentioned.context, toolPrices, ragPrices);\n    \n    if (matchedSku) {\n      const expectedPrice = toolPrices.get(matchedSku) || ragPrices.get(matchedSku);\n      validation.expectedPrice = expectedPrice;\n      \n      if (expectedPrice) {\n        const mentionedValue = parseFloat(mentioned.value.replace(/[^0-9.,]/g, '').replace(',', '.'));\n        const variance = Math.abs((mentionedValue - expectedPrice) / expectedPrice * 100);\n        validation.variance = variance;\n        \n        // Allow 1% variance for rounding differences\n        if (variance <= 1) {\n          validation.isValid = true;\n        } else {\n          validation.isValid = false;\n          validation.issue = `Price ${mentionedValue} differs from expected ${expectedPrice} by ${variance.toFixed(1)}%`;\n          failures.push(`PREȚ INCORECT: ${mentioned.context || 'produs'} - menționat ${mentionedValue}, corect ${expectedPrice}`);\n        }\n      }\n    } else {\n      // Price mentioned without tool verification\n      validation.isValid = false;\n      validation.issue = 'Price mentioned without tool verification';\n      failures.push(`PREȚ NEVERIFICAT: ${mentioned.value} menționat fără verificare prin tools`);\n    }\n    \n    validations.push(validation);\n  }\n  \n  // Check for suspicious patterns\n  const suspiciousPatterns = checkSuspiciousPatterns(responseContent);\n  failures.push(...suspiciousPatterns);\n  \n  const passed = failures.length === 0;\n  const severity = determineSeverity(failures, validations);\n  \n  // Build correction prompt if failed\n  let correctionPrompt: string | undefined;\n  if (!passed) {\n    correctionPrompt = buildCorrectionPrompt(failures, toolPrices, ragPrices);\n  }\n  \n  // Update metrics\n  metrics.guardrailChecks.inc({ type: 'price', result: passed ? 'pass' : 'fail' });\n  metrics.guardrailLatency.observe({ type: 'price' }, Date.now() - startTime);\n  \n  log.info('Price guardrail completed', {\n    passed,\n    validationCount: validations.length,\n    failureCount: failures.length,\n    severity,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return {\n    passed,\n    checkType: 'price',\n    validations,\n    failures,\n    correctionPrompt,\n    severity\n  };\n}\n\nfunction extractPrices(text: string): Array<{ value: string; context?: string }> {\n  const results: Array<{ value: string; context?: string }> = [];\n  \n  // Match various price patterns\n  const patterns = [\n    // \"150 RON\", \"150 lei\", \"150 de lei\"\n    /(\\d+[.,]?\\d*)\\s*(?:RON|lei|de lei)/gi,\n    // \"preț: 150\", \"cost: 150\"\n    /(?:preț|pret|cost|valoare|suma)[:\\s]*(\\d+[.,]?\\d*)/gi,\n    // \"150 RON/buc\", \"150 lei/kg\"\n    /(\\d+[.,]?\\d*)\\s*(?:RON|lei)\\/\\w+/gi,\n    // Numbers followed by currency context\n    /(?:costă|costa|este|va fi)\\s*(\\d+[.,]?\\d*)/gi\n  ];\n  \n  for (const pattern of patterns) {\n    let match;\n    while ((match = pattern.exec(text)) !== null) {\n      // Extract surrounding context (50 chars before and after)\n      const start = Math.max(0, match.index - 50);\n      const end = Math.min(text.length, match.index + match[0].length + 50);\n      const context = text.slice(start, end);\n      \n      results.push({\n        value: match[1] || match[0],\n        context\n      });\n    }\n  }\n  \n  return results;\n}\n\nfunction findMatchingSku(\n  context: string | undefined,\n  toolPrices: Map<string, number>,\n  ragPrices: Map<string, number>\n): string | undefined {\n  if (!context) return undefined;\n  \n  const contextLower = context.toLowerCase();\n  \n  // Check tool prices first (more authoritative)\n  for (const sku of toolPrices.keys()) {\n    if (contextLower.includes(sku.toLowerCase())) {\n      return sku;\n    }\n  }\n  \n  // Check RAG prices\n  for (const sku of ragPrices.keys()) {\n    if (contextLower.includes(sku.toLowerCase())) {\n      return sku;\n    }\n  }\n  \n  return undefined;\n}\n\nfunction checkSuspiciousPatterns(text: string): string[] {\n  const issues: string[] = [];\n  \n  // Check for round numbers that might be hallucinated\n  const roundPricePattern = /(?:preț|cost|valoare)\\s*(?:de\\s*)?(?:doar\\s*)?(\\d{3,})(?:00)?\\s*(?:RON|lei)/gi;\n  let match;\n  while ((match = roundPricePattern.exec(text)) !== null) {\n    const price = parseInt(match[1]);\n    if (price % 100 === 0 && price >= 1000) {\n      issues.push(`PREȚ SUSPECT: ${price} pare prea rotund - verifică sursă`);\n    }\n  }\n  \n  // Check for \"aproximativ\", \"în jur de\" - uncertainty indicators\n  if (/aproximativ|în jur de|cam|poate fi|ar fi/i.test(text)) {\n    issues.push('LIMBAJ INCERT: Folosește prețuri exacte, nu aproximări');\n  }\n  \n  return issues;\n}\n\nfunction determineSeverity(\n  failures: string[],\n  validations: PriceValidation[]\n): 'info' | 'warning' | 'error' | 'critical' {\n  if (failures.length === 0) return 'info';\n  \n  // Check for large variances\n  const hasLargeVariance = validations.some(v => v.variance && v.variance > 10);\n  const hasUnverified = failures.some(f => f.includes('NEVERIFICAT'));\n  \n  if (hasLargeVariance) return 'critical';\n  if (hasUnverified) return 'error';\n  if (failures.length > 2) return 'error';\n  return 'warning';\n}\n\nfunction buildCorrectionPrompt(\n  failures: string[],\n  toolPrices: Map<string, number>,\n  ragPrices: Map<string, number>\n): string {\n  let prompt = '[CORECȚIE GUARDRAIL PREȚURI]\\n';\n  prompt += 'Răspunsul anterior conține erori de preț. TE ROG:\\n';\n  prompt += '1. NU inventa prețuri - folosește DOAR valorile din tools sau RAG\\n';\n  prompt += '2. Dacă nu știi prețul, spune că vei verifica\\n\\n';\n  prompt += 'Probleme detectate:\\n';\n  \n  for (const failure of failures) {\n    prompt += `- ${failure}\\n`;\n  }\n  \n  if (toolPrices.size > 0) {\n    prompt += '\\nPrețuri verificate prin tools:\\n';\n    for (const [sku, price] of toolPrices) {\n      prompt += `- ${sku}: ${price} RON\\n`;\n    }\n  }\n  \n  prompt += '\\nREGENEREAZĂ răspunsul folosind DOAR prețurile corecte de mai sus.';\n  \n  return prompt;\n}\n\nexport const guardPriceWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.GUARD_PRICE,\n  processPriceGuardrail,\n  {\n    concurrency: 25,\n    limiter: {\n      max: 150,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-m",
  "restrictii_antihalucinatie": [
    "VERIFICĂ prețuri contra tool results și RAG context",
    "NU permite prețuri neverificate în răspuns",
    "DETECTEAZĂ patterns suspecte (numere prea rotunde)",
    "GENEREAZĂ correction prompt specific pentru regenerare",
    "SEVERITY escalare pe baza variance"
  ],
  "validare_task": "1. Extragere prețuri din răspuns\n2. Matching cu SKU din context\n3. Variance calculation corect\n4. Suspicious pattern detection\n5. Correction prompt clar pentru LLM",
  "outcome": "Worker guard:price funcțional pentru validare prețuri cu anti-halucinație"
}
```

## F3.14.2 Stock Guardrail Worker (#67)

```json
{
  "taskID": "F3.14.2.T001",
  "denumire_task": "Implementare worker guard:stock pentru validare stoc în răspunsuri AI",
  "context_anterior": "Price guardrail implementat. Acum implementăm validare stoc - la fel de critică.",
  "descriere_task": "Ești un expert în AI guardrails. Task-ul tău este să creezi workerul pentru validare disponibilitate stoc.\n\nCreează fișierul /packages/workers/src/etapa3/category-m/guard-stock.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { products } from '@cerniq/db/schema';\nimport { eq, and, inArray } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\n\nconst StockGuardrailPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  responseContent: z.string(),\n  toolCalls: z.array(z.object({\n    name: z.string(),\n    input: z.any(),\n    result: z.any()\n  })).optional()\n});\n\ntype StockGuardrailJob = z.infer<typeof StockGuardrailPayload>;\n\ninterface StockValidation {\n  claim: string;\n  productContext?: string;\n  verifiedByTool: boolean;\n  actualStock?: number;\n  isValid: boolean;\n  issue?: string;\n}\n\ninterface GuardrailResult {\n  passed: boolean;\n  checkType: 'stock';\n  validations: StockValidation[];\n  failures: string[];\n  correctionPrompt?: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n}\n\nasync function processStockGuardrail(job: Job<StockGuardrailJob>): Promise<GuardrailResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, negotiationId: job.data.negotiationId });\n  \n  const { tenantId, responseContent, toolCalls } = job.data;\n  \n  log.info('Running stock guardrail check');\n  \n  const validations: StockValidation[] = [];\n  const failures: string[] = [];\n  \n  // Get verified stock from tool calls\n  const verifiedStock = new Map<string, { available: number; checked: boolean }>();\n  if (toolCalls) {\n    for (const call of toolCalls) {\n      if (call.name === 'check_stock') {\n        const result = call.result;\n        if (result?.results) {\n          for (const item of result.results) {\n            verifiedStock.set(item.sku, {\n              available: item.availableStock,\n              checked: true\n            });\n          }\n        }\n      }\n    }\n  }\n  \n  // Extract availability claims from response\n  const stockClaims = extractStockClaims(responseContent);\n  \n  for (const claim of stockClaims) {\n    const validation: StockValidation = {\n      claim: claim.text,\n      productContext: claim.product,\n      verifiedByTool: false,\n      isValid: false\n    };\n    \n    // Check if this claim was verified by a tool\n    if (claim.product) {\n      const verified = findVerifiedStock(claim.product, verifiedStock);\n      if (verified) {\n        validation.verifiedByTool = true;\n        validation.actualStock = verified.available;\n        \n        // Validate the claim against actual stock\n        if (claim.claimType === 'available' && verified.available > 0) {\n          validation.isValid = true;\n        } else if (claim.claimType === 'unavailable' && verified.available === 0) {\n          validation.isValid = true;\n        } else if (claim.claimType === 'quantity' && claim.quantity !== undefined) {\n          validation.isValid = claim.quantity <= verified.available;\n          if (!validation.isValid) {\n            validation.issue = `Claimed ${claim.quantity} available, actual ${verified.available}`;\n            failures.push(`STOC INSUFICIENT: ${claim.product} - cerut ${claim.quantity}, disponibil ${verified.available}`);\n          }\n        } else if (!validation.isValid) {\n          validation.issue = 'Claim contradicts verified stock';\n          failures.push(`STOC INCORECT: ${claim.product} - claim \"${claim.text}\" contrazice verificarea`);\n        }\n      } else {\n        // Availability claim without tool verification\n        validation.verifiedByTool = false;\n        validation.issue = 'Stock claim without tool verification';\n        failures.push(`STOC NEVERIFICAT: \"${claim.text}\" - folosește check_stock tool`);\n      }\n    }\n    \n    validations.push(validation);\n  }\n  \n  // Check for dangerous patterns\n  const dangerousPatterns = checkDangerousPatterns(responseContent);\n  failures.push(...dangerousPatterns);\n  \n  const passed = failures.length === 0;\n  const severity = determineSeverity(failures);\n  \n  let correctionPrompt: string | undefined;\n  if (!passed) {\n    correctionPrompt = buildCorrectionPrompt(failures, verifiedStock);\n  }\n  \n  metrics.guardrailChecks.inc({ type: 'stock', result: passed ? 'pass' : 'fail' });\n  metrics.guardrailLatency.observe({ type: 'stock' }, Date.now() - startTime);\n  \n  log.info('Stock guardrail completed', {\n    passed,\n    validationCount: validations.length,\n    failureCount: failures.length,\n    latencyMs: Date.now() - startTime\n  });\n  \n  return {\n    passed,\n    checkType: 'stock',\n    validations,\n    failures,\n    correctionPrompt,\n    severity\n  };\n}\n\ninterface StockClaim {\n  text: string;\n  product?: string;\n  claimType: 'available' | 'unavailable' | 'quantity';\n  quantity?: number;\n}\n\nfunction extractStockClaims(text: string): StockClaim[] {\n  const claims: StockClaim[] = [];\n  \n  // \"avem în stoc\", \"este disponibil\", \"avem X bucăți\"\n  const availablePatterns = [\n    /(?:avem|există|este|sunt)\\s+(?:în stoc|disponibil[eă]?|pe stoc)/gi,\n    /(?:disponibil[eă]?|în stoc)\\s+(?:\\d+)?\\s*(?:bucăți|buc|kg|l|unități)?/gi,\n    /(\\d+)\\s*(?:bucăți|buc|kg|l|unități)?\\s+(?:disponibil|în stoc|pe stoc)/gi\n  ];\n  \n  // \"nu avem\", \"indisponibil\", \"epuizat\", \"stoc zero\"\n  const unavailablePatterns = [\n    /(?:nu avem|nu este|nu sunt|indisponibil|epuizat|lipsă|stoc zero)/gi\n  ];\n  \n  // Check for quantity claims\n  const quantityPattern = /(\\d+)\\s*(?:bucăți|buc|kg|l|unități)?\\s+(?:disponibil|în stoc)/gi;\n  let match;\n  \n  while ((match = quantityPattern.exec(text)) !== null) {\n    const context = extractContext(text, match.index);\n    claims.push({\n      text: match[0],\n      product: extractProductFromContext(context),\n      claimType: 'quantity',\n      quantity: parseInt(match[1])\n    });\n  }\n  \n  for (const pattern of availablePatterns) {\n    while ((match = pattern.exec(text)) !== null) {\n      const context = extractContext(text, match.index);\n      // Avoid duplicates from quantity pattern\n      if (!claims.some(c => c.text === match[0])) {\n        claims.push({\n          text: match[0],\n          product: extractProductFromContext(context),\n          claimType: 'available'\n        });\n      }\n    }\n  }\n  \n  for (const pattern of unavailablePatterns) {\n    while ((match = pattern.exec(text)) !== null) {\n      const context = extractContext(text, match.index);\n      claims.push({\n        text: match[0],\n        product: extractProductFromContext(context),\n        claimType: 'unavailable'\n      });\n    }\n  }\n  \n  return claims;\n}\n\nfunction extractContext(text: string, index: number): string {\n  const start = Math.max(0, index - 100);\n  const end = Math.min(text.length, index + 100);\n  return text.slice(start, end);\n}\n\nfunction extractProductFromContext(context: string): string | undefined {\n  // Look for SKU patterns\n  const skuMatch = context.match(/([A-Z]{2,4}-?\\d{3,6})/i);\n  if (skuMatch) return skuMatch[1];\n  \n  // Look for quoted product names\n  const quotedMatch = context.match(/[\"„]([^\"\"]+)[\"\"]/); \n  if (quotedMatch) return quotedMatch[1];\n  \n  return undefined;\n}\n\nfunction findVerifiedStock(\n  product: string,\n  verifiedStock: Map<string, { available: number; checked: boolean }>\n): { available: number; checked: boolean } | undefined {\n  const productLower = product.toLowerCase();\n  \n  for (const [sku, stock] of verifiedStock) {\n    if (productLower.includes(sku.toLowerCase()) || sku.toLowerCase().includes(productLower)) {\n      return stock;\n    }\n  }\n  \n  return undefined;\n}\n\nfunction checkDangerousPatterns(text: string): string[] {\n  const issues: string[] = [];\n  \n  // Unconditional availability promises\n  if (/sigur\\s+(?:avem|este disponibil)|garantat\\s+în stoc/i.test(text)) {\n    issues.push('PROMISIUNE NECONDIȚIONALĂ: Nu garanta disponibilitatea fără verificare');\n  }\n  \n  // Future tense promises about current stock\n  if (/va fi disponibil|vom avea|o să avem/i.test(text)) {\n    issues.push('PROMISIUNE VIITOR: Evită promisiuni despre stoc viitor');\n  }\n  \n  return issues;\n}\n\nfunction determineSeverity(failures: string[]): 'info' | 'warning' | 'error' | 'critical' {\n  if (failures.length === 0) return 'info';\n  if (failures.some(f => f.includes('INSUFICIENT'))) return 'critical';\n  if (failures.some(f => f.includes('NEVERIFICAT'))) return 'error';\n  return 'warning';\n}\n\nfunction buildCorrectionPrompt(\n  failures: string[],\n  verifiedStock: Map<string, { available: number; checked: boolean }>\n): string {\n  let prompt = '[CORECȚIE GUARDRAIL STOC]\\n';\n  prompt += 'Răspunsul anterior conține afirmații neverificate despre stoc. TE ROG:\\n';\n  prompt += '1. NU confirma disponibilitatea fără check_stock tool\\n';\n  prompt += '2. Dacă nu ai verificat, spune că vei verifica\\n\\n';\n  prompt += 'Probleme detectate:\\n';\n  \n  for (const failure of failures) {\n    prompt += `- ${failure}\\n`;\n  }\n  \n  if (verifiedStock.size > 0) {\n    prompt += '\\nStoc verificat prin tools:\\n';\n    for (const [sku, stock] of verifiedStock) {\n      prompt += `- ${sku}: ${stock.available} disponibil\\n`;\n    }\n  }\n  \n  prompt += '\\nREGENEREAZĂ răspunsul folosind DOAR informațiile verificate.';\n  \n  return prompt;\n}\n\nexport const guardStockWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.GUARD_STOCK,\n  processStockGuardrail,\n  {\n    concurrency: 25,\n    limiter: {\n      max: 150,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-m",
  "restrictii_antihalucinatie": [
    "NU permite claim de disponibilitate fără check_stock tool",
    "VERIFICĂ cantități contra stoc real",
    "DETECTEAZĂ promisiuni necondiționate",
    "MATCH SKU din context cu verified stock",
    "SEVERITY critical pentru stoc insuficient promis"
  ],
  "validare_task": "1. Extragere claims disponibilitate\n2. Matching cu tool verification\n3. Quantity validation\n4. Dangerous pattern detection\n5. Correction prompt specific",
  "outcome": "Worker guard:stock funcțional pentru validare stoc cu anti-halucinație"
}
```

---

# FAZA F3.11: HANDOVER & CHANNEL WORKERS (CATEGORIA J)

## F3.11.1 Channel Orchestrator Worker (#57)

```json
{
  "taskID": "F3.11.1.T001",
  "denumire_task": "Implementare worker channel:orchestrate pentru orchestrare multi-canal",
  "context_anterior": "Guardrails workers finalizați. Acum implementăm gestionarea canalelor de comunicare - WhatsApp, Email, Web Chat.",
  "descriere_task": "Ești un expert în arhitecturi multi-canal. Task-ul tău este să creezi orchestratorul pentru canale de comunicare.\n\nCreează fișierul /packages/workers/src/etapa3/category-j/channel-orchestrate.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiations, negotiationMessages, channelSessions } from '@cerniq/db/schema';\nimport { eq, and } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst ChannelOrchestratePayload = z.object({\n  tenantId: z.string().uuid(),\n  channelType: z.enum(['whatsapp', 'email', 'web_chat', 'sms']),\n  direction: z.enum(['inbound', 'outbound']),\n  sessionId: z.string().optional(),\n  \n  // Inbound message\n  inbound: z.object({\n    externalId: z.string(),\n    senderPhone: z.string().optional(),\n    senderEmail: z.string().optional(),\n    senderName: z.string().optional(),\n    content: z.string(),\n    contentType: z.enum(['text', 'image', 'document', 'audio', 'template']),\n    mediaUrl: z.string().optional(),\n    timestamp: z.string().datetime()\n  }).optional(),\n  \n  // Outbound message\n  outbound: z.object({\n    negotiationId: z.string().uuid(),\n    messageId: z.string().uuid(),\n    content: z.string(),\n    recipientPhone: z.string().optional(),\n    recipientEmail: z.string().optional(),\n    templateId: z.string().optional(),\n    templateParams: z.record(z.string()).optional()\n  }).optional()\n});\n\ntype ChannelOrchestrateJob = z.infer<typeof ChannelOrchestratePayload>;\n\ninterface OrchestrationResult {\n  success: boolean;\n  sessionId: string;\n  negotiationId?: string;\n  messageId?: string;\n  queuedAction?: string;\n  error?: string;\n}\n\nasync function processChannelOrchestrate(job: Job<ChannelOrchestrateJob>): Promise<OrchestrationResult> {\n  const startTime = Date.now();\n  const log = logger.child({ jobId: job.id, channelType: job.data.channelType });\n  \n  const { tenantId, channelType, direction, sessionId, inbound, outbound } = job.data;\n  \n  log.info('Channel orchestration started', { direction, channelType });\n  \n  try {\n    if (direction === 'inbound' && inbound) {\n      return await handleInbound(tenantId, channelType, sessionId, inbound, log);\n    } else if (direction === 'outbound' && outbound) {\n      return await handleOutbound(tenantId, channelType, outbound, log);\n    } else {\n      throw new Error('Invalid direction/payload combination');\n    }\n  } catch (error) {\n    log.error('Channel orchestration failed', { error });\n    metrics.channelErrors.inc({ channel: channelType, direction });\n    throw error;\n  } finally {\n    metrics.channelLatency.observe({ channel: channelType }, Date.now() - startTime);\n  }\n}\n\nasync function handleInbound(\n  tenantId: string,\n  channelType: string,\n  existingSessionId: string | undefined,\n  inbound: any,\n  log: any\n): Promise<OrchestrationResult> {\n  \n  // Find or create session\n  let session = existingSessionId ? await db.query.channelSessions.findFirst({\n    where: eq(channelSessions.id, existingSessionId)\n  }) : null;\n  \n  if (!session) {\n    // Try to find by phone/email\n    const identifier = inbound.senderPhone || inbound.senderEmail;\n    session = await db.query.channelSessions.findFirst({\n      where: and(\n        eq(channelSessions.tenantId, tenantId),\n        eq(channelSessions.channelType, channelType),\n        eq(channelSessions.externalIdentifier, identifier),\n        eq(channelSessions.status, 'active')\n      )\n    });\n  }\n  \n  let negotiationId: string | undefined;\n  \n  if (session) {\n    negotiationId = session.negotiationId;\n    \n    // Update session activity\n    await db.update(channelSessions)\n      .set({ \n        lastActivityAt: new Date(),\n        messageCount: session.messageCount + 1\n      })\n      .where(eq(channelSessions.id, session.id));\n  } else {\n    // Create new session and potentially new negotiation\n    const newSessionId = uuidv4();\n    \n    // Try to find existing contact by phone/email\n    const identifier = inbound.senderPhone || inbound.senderEmail;\n    const contact = await findOrCreateContact(tenantId, identifier, inbound.senderName, channelType);\n    \n    // Create or find active negotiation for this contact\n    let negotiation = await db.query.negotiations.findFirst({\n      where: and(\n        eq(negotiations.tenantId, tenantId),\n        eq(negotiations.contactId, contact.id),\n        eq(negotiations.status, 'active')\n      )\n    });\n    \n    if (!negotiation) {\n      // Create new negotiation\n      const newNegotiation = await db.insert(negotiations).values({\n        id: uuidv4(),\n        tenantId,\n        contactId: contact.id,\n        source: `${channelType}_inbound`,\n        currentState: 'NEW',\n        priority: 'medium',\n        aiEnabled: true,\n        aiModel: 'grok-4',\n        status: 'active',\n        createdAt: new Date()\n      }).returning();\n      negotiation = newNegotiation[0];\n    }\n    \n    negotiationId = negotiation.id;\n    \n    // Create session\n    await db.insert(channelSessions).values({\n      id: newSessionId,\n      tenantId,\n      negotiationId,\n      contactId: contact.id,\n      channelType,\n      externalIdentifier: identifier,\n      externalSessionId: inbound.externalId,\n      status: 'active',\n      lastActivityAt: new Date(),\n      messageCount: 1,\n      metadata: {\n        senderName: inbound.senderName\n      }\n    });\n    \n    session = { id: newSessionId, negotiationId } as any;\n  }\n  \n  // Store inbound message\n  const message = await db.insert(negotiationMessages).values({\n    id: uuidv4(),\n    tenantId,\n    negotiationId: negotiationId!,\n    role: 'user',\n    content: inbound.content,\n    contentType: inbound.contentType,\n    channelType,\n    externalMessageId: inbound.externalId,\n    mediaUrl: inbound.mediaUrl,\n    receivedAt: new Date(inbound.timestamp),\n    createdAt: new Date()\n  }).returning();\n  \n  // Queue AI processing\n  const aiQueue = createEtapa3Queue(ETAPA3_QUEUES.AI_ORCHESTRATE);\n  await aiQueue.add('orchestrate', {\n    tenantId,\n    negotiationId: negotiationId!,\n    messageId: message[0].id,\n    userMessage: inbound.content,\n    channelType\n  }, { priority: channelType === 'whatsapp' ? 1 : 2 }); // WhatsApp higher priority\n  \n  metrics.channelMessages.inc({ channel: channelType, direction: 'inbound' });\n  \n  log.info('Inbound message processed', {\n    sessionId: session.id,\n    negotiationId,\n    messageId: message[0].id\n  });\n  \n  return {\n    success: true,\n    sessionId: session.id,\n    negotiationId,\n    messageId: message[0].id,\n    queuedAction: 'ai_orchestrate'\n  };\n}\n\nasync function handleOutbound(\n  tenantId: string,\n  channelType: string,\n  outbound: any,\n  log: any\n): Promise<OrchestrationResult> {\n  \n  // Route to appropriate channel delivery worker\n  let deliveryQueue: string;\n  \n  switch (channelType) {\n    case 'whatsapp':\n      deliveryQueue = ETAPA3_QUEUES.CHANNEL_WHATSAPP;\n      break;\n    case 'email':\n      deliveryQueue = ETAPA3_QUEUES.CHANNEL_EMAIL;\n      break;\n    case 'sms':\n      deliveryQueue = ETAPA3_QUEUES.CHANNEL_SMS;\n      break;\n    default:\n      deliveryQueue = ETAPA3_QUEUES.CHANNEL_WEBHOOK;\n  }\n  \n  const queue = createEtapa3Queue(deliveryQueue);\n  const deliveryJob = await queue.add('deliver', {\n    tenantId,\n    negotiationId: outbound.negotiationId,\n    messageId: outbound.messageId,\n    content: outbound.content,\n    recipient: outbound.recipientPhone || outbound.recipientEmail,\n    templateId: outbound.templateId,\n    templateParams: outbound.templateParams\n  });\n  \n  // Update message status\n  await db.update(negotiationMessages)\n    .set({ \n      status: 'queued',\n      deliveryJobId: deliveryJob.id\n    })\n    .where(eq(negotiationMessages.id, outbound.messageId));\n  \n  metrics.channelMessages.inc({ channel: channelType, direction: 'outbound' });\n  \n  log.info('Outbound message queued', {\n    negotiationId: outbound.negotiationId,\n    messageId: outbound.messageId,\n    deliveryQueue\n  });\n  \n  return {\n    success: true,\n    sessionId: '',\n    negotiationId: outbound.negotiationId,\n    messageId: outbound.messageId,\n    queuedAction: deliveryQueue\n  };\n}\n\nasync function findOrCreateContact(\n  tenantId: string,\n  identifier: string,\n  name: string | undefined,\n  channelType: string\n): Promise<any> {\n  // Implementation to find or create contact based on identifier\n  // This would check contacts_gold, contacts_silver tables\n  // For brevity, simplified here\n  const { contactsGold } = await import('@cerniq/db/schema');\n  \n  let contact = await db.query.contactsGold.findFirst({\n    where: and(\n      eq(contactsGold.tenantId, tenantId),\n      channelType === 'whatsapp' || channelType === 'sms'\n        ? eq(contactsGold.phone, identifier)\n        : eq(contactsGold.email, identifier)\n    )\n  });\n  \n  if (!contact) {\n    // Create minimal contact for new conversation\n    const newContact = await db.insert(contactsGold).values({\n      id: uuidv4(),\n      tenantId,\n      name: name || identifier,\n      phone: channelType === 'whatsapp' || channelType === 'sms' ? identifier : null,\n      email: channelType === 'email' ? identifier : null,\n      source: `${channelType}_inbound`,\n      tier: 'bronze', // Start at bronze, will be enriched\n      createdAt: new Date()\n    }).returning();\n    contact = newContact[0];\n  }\n  \n  return contact;\n}\n\nexport const channelOrchestrateWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.CHANNEL_ORCHESTRATE,\n  processChannelOrchestrate,\n  {\n    concurrency: 20,\n    limiter: {\n      max: 100,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-j",
  "restrictii_antihalucinatie": [
    "ROUTE corect pe baza channelType",
    "CREEAZĂ session și negotiation dacă nu există",
    "PRIORITY mai mare pentru WhatsApp (real-time)",
    "QUEUE AI orchestration pentru inbound",
    "TRACK message status pentru delivery"
  ],
  "validare_task": "1. Routing corect inbound/outbound\n2. Session management funcțional\n3. Contact creation pentru noi\n4. AI queue pentru procesare\n5. Delivery routing per channel",
  "outcome": "Worker channel:orchestrate funcțional pentru orchestrare multi-canal"
}
```

## F3.11.2 WhatsApp Delivery Worker (#58)

```json
{
  "taskID": "F3.11.2.T001",
  "denumire_task": "Implementare worker channel:whatsapp pentru livrare mesaje WhatsApp Business",
  "context_anterior": "Channel orchestrator implementat. Acum implementăm delivery pentru WhatsApp Business API.",
  "descriere_task": "Ești un expert în WhatsApp Business API. Task-ul tău este să creezi workerul pentru livrare mesaje.\n\nCreează fișierul /packages/workers/src/etapa3/category-j/channel-whatsapp.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiationMessages, tenants } from '@cerniq/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport axios from 'axios';\n\nconst WhatsAppDeliveryPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  messageId: z.string().uuid(),\n  content: z.string(),\n  recipient: z.string(), // Phone number\n  templateId: z.string().optional(),\n  templateParams: z.record(z.string()).optional(),\n  messageType: z.enum(['text', 'template', 'image', 'document']).default('text')\n});\n\ntype WhatsAppDeliveryJob = z.infer<typeof WhatsAppDeliveryPayload>;\n\ninterface WhatsAppResponse {\n  success: boolean;\n  messageId?: string;\n  waId?: string;\n  error?: string;\n  timestamp?: string;\n}\n\nclass WhatsAppBusinessClient {\n  private phoneNumberId: string;\n  private accessToken: string;\n  private baseUrl = 'https://graph.facebook.com/v18.0';\n  \n  constructor(phoneNumberId: string, accessToken: string) {\n    this.phoneNumberId = phoneNumberId;\n    this.accessToken = accessToken;\n  }\n  \n  async sendTextMessage(to: string, text: string): Promise<WhatsAppResponse> {\n    try {\n      const response = await axios.post(\n        `${this.baseUrl}/${this.phoneNumberId}/messages`,\n        {\n          messaging_product: 'whatsapp',\n          recipient_type: 'individual',\n          to: this.formatPhoneNumber(to),\n          type: 'text',\n          text: { body: text }\n        },\n        {\n          headers: {\n            'Authorization': `Bearer ${this.accessToken}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n      \n      return {\n        success: true,\n        messageId: response.data.messages[0]?.id,\n        waId: response.data.contacts[0]?.wa_id,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: error.response?.data?.error?.message || error.message\n      };\n    }\n  }\n  \n  async sendTemplateMessage(\n    to: string,\n    templateName: string,\n    languageCode: string,\n    components: any[]\n  ): Promise<WhatsAppResponse> {\n    try {\n      const response = await axios.post(\n        `${this.baseUrl}/${this.phoneNumberId}/messages`,\n        {\n          messaging_product: 'whatsapp',\n          recipient_type: 'individual',\n          to: this.formatPhoneNumber(to),\n          type: 'template',\n          template: {\n            name: templateName,\n            language: { code: languageCode },\n            components\n          }\n        },\n        {\n          headers: {\n            'Authorization': `Bearer ${this.accessToken}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n      \n      return {\n        success: true,\n        messageId: response.data.messages[0]?.id,\n        waId: response.data.contacts[0]?.wa_id\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: error.response?.data?.error?.message || error.message\n      };\n    }\n  }\n  \n  private formatPhoneNumber(phone: string): string {\n    // Ensure phone number is in E.164 format\n    let cleaned = phone.replace(/[^0-9]/g, '');\n    \n    // Add Romania country code if missing\n    if (cleaned.startsWith('0')) {\n      cleaned = '40' + cleaned.substring(1);\n    }\n    if (!cleaned.startsWith('40') && cleaned.length === 9) {\n      cleaned = '40' + cleaned;\n    }\n    \n    return cleaned;\n  }\n}\n\nasync function processWhatsAppDelivery(job: Job<WhatsAppDeliveryJob>): Promise<WhatsAppResponse> {\n  const startTime = Date.now();\n  const log = logger.child({ \n    jobId: job.id, \n    messageId: job.data.messageId,\n    recipient: job.data.recipient.slice(-4) // Last 4 digits for privacy\n  });\n  \n  const { tenantId, messageId, content, recipient, templateId, templateParams, messageType } = job.data;\n  \n  log.info('Delivering WhatsApp message', { messageType });\n  \n  try {\n    // Load tenant WhatsApp configuration\n    const tenant = await db.query.tenants.findFirst({\n      where: eq(tenants.id, tenantId)\n    });\n    \n    if (!tenant?.whatsappPhoneNumberId || !tenant?.whatsappAccessToken) {\n      throw new Error('WhatsApp not configured for tenant');\n    }\n    \n    const client = new WhatsAppBusinessClient(\n      tenant.whatsappPhoneNumberId,\n      tenant.whatsappAccessToken\n    );\n    \n    let result: WhatsAppResponse;\n    \n    if (messageType === 'template' && templateId) {\n      // Build template components from params\n      const components = templateParams ? [{\n        type: 'body',\n        parameters: Object.entries(templateParams).map(([_, value]) => ({\n          type: 'text',\n          text: value\n        }))\n      }] : [];\n      \n      result = await client.sendTemplateMessage(\n        recipient,\n        templateId,\n        'ro', // Romanian\n        components\n      );\n    } else {\n      result = await client.sendTextMessage(recipient, content);\n    }\n    \n    // Update message status\n    await db.update(negotiationMessages)\n      .set({\n        status: result.success ? 'delivered' : 'failed',\n        externalMessageId: result.messageId,\n        deliveredAt: result.success ? new Date() : null,\n        deliveryError: result.error,\n        metadata: {\n          waId: result.waId,\n          deliveryLatencyMs: Date.now() - startTime\n        }\n      })\n      .where(eq(negotiationMessages.id, messageId));\n    \n    // Update metrics\n    metrics.whatsappMessages.inc({ \n      status: result.success ? 'delivered' : 'failed',\n      type: messageType\n    });\n    metrics.whatsappLatency.observe(Date.now() - startTime);\n    \n    if (!result.success) {\n      log.error('WhatsApp delivery failed', { error: result.error });\n      throw new Error(result.error);\n    }\n    \n    log.info('WhatsApp message delivered', {\n      waMessageId: result.messageId,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return result;\n    \n  } catch (error) {\n    log.error('WhatsApp delivery error', { error });\n    \n    // Update message status\n    await db.update(negotiationMessages)\n      .set({\n        status: 'failed',\n        deliveryError: error instanceof Error ? error.message : 'Unknown error'\n      })\n      .where(eq(negotiationMessages.id, messageId));\n    \n    throw error;\n  }\n}\n\nexport const channelWhatsAppWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.CHANNEL_WHATSAPP,\n  processWhatsAppDelivery,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 30, // WhatsApp rate limit consideration\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-j",
  "restrictii_antihalucinatie": [
    "FORMAT phone number E.164 cu prefix România +40",
    "NU hardcoda credentials - din tenant config",
    "RESPECTĂ rate limits WhatsApp Business API",
    "UPDATE message status pentru tracking",
    "HANDLE errors cu retry automat BullMQ"
  ],
  "validare_task": "1. Phone formatting E.164\n2. Text și template messages suportate\n3. Error handling cu status update\n4. Rate limiting respectat\n5. Metrics pentru delivery tracking",
  "outcome": "Worker channel:whatsapp funcțional pentru livrare mesaje WhatsApp Business"
}
```

## F3.11.3 Email Delivery Worker (#59)

```json
{
  "taskID": "F3.11.3.T001",
  "denumire_task": "Implementare worker channel:email pentru livrare email-uri",
  "context_anterior": "WhatsApp delivery implementat. Acum implementăm email delivery cu templates profesionale.",
  "descriere_task": "Ești un expert în email delivery și templates. Task-ul tău este să creezi workerul pentru livrare email-uri profesionale.\n\nCreează fișierul /packages/workers/src/etapa3/category-j/channel-email.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { negotiationMessages, tenants, emailTemplates } from '@cerniq/db/schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport nodemailer from 'nodemailer';\nimport Handlebars from 'handlebars';\n\nconst EmailDeliveryPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  messageId: z.string().uuid(),\n  recipient: z.string().email(),\n  recipientName: z.string().optional(),\n  subject: z.string().optional(),\n  content: z.string(),\n  templateId: z.string().optional(),\n  templateParams: z.record(z.any()).optional(),\n  attachments: z.array(z.object({\n    filename: z.string(),\n    path: z.string().optional(),\n    content: z.string().optional(),\n    contentType: z.string().optional()\n  })).optional(),\n  options: z.object({\n    replyTo: z.string().email().optional(),\n    cc: z.array(z.string().email()).optional(),\n    bcc: z.array(z.string().email()).optional(),\n    priority: z.enum(['low', 'normal', 'high']).default('normal'),\n    trackOpens: z.boolean().default(true),\n    trackClicks: z.boolean().default(true)\n  }).optional()\n});\n\ntype EmailDeliveryJob = z.infer<typeof EmailDeliveryPayload>;\n\ninterface EmailResult {\n  success: boolean;\n  messageId?: string;\n  accepted?: string[];\n  rejected?: string[];\n  error?: string;\n}\n\nasync function processEmailDelivery(job: Job<EmailDeliveryJob>): Promise<EmailResult> {\n  const startTime = Date.now();\n  const log = logger.child({ \n    jobId: job.id, \n    messageId: job.data.messageId,\n    recipient: job.data.recipient \n  });\n  \n  const { \n    tenantId, \n    messageId, \n    recipient, \n    recipientName,\n    subject: customSubject,\n    content, \n    templateId, \n    templateParams,\n    attachments,\n    options \n  } = job.data;\n  \n  log.info('Delivering email');\n  \n  try {\n    // Load tenant SMTP configuration\n    const tenant = await db.query.tenants.findFirst({\n      where: eq(tenants.id, tenantId)\n    });\n    \n    if (!tenant?.smtpHost || !tenant?.smtpUser) {\n      throw new Error('SMTP not configured for tenant');\n    }\n    \n    // Create transporter\n    const transporter = nodemailer.createTransport({\n      host: tenant.smtpHost,\n      port: tenant.smtpPort || 587,\n      secure: tenant.smtpSecure || false,\n      auth: {\n        user: tenant.smtpUser,\n        pass: tenant.smtpPassword\n      }\n    });\n    \n    // Build email content\n    let htmlContent: string;\n    let textContent: string;\n    let subject: string;\n    \n    if (templateId) {\n      // Load and render template\n      const template = await db.query.emailTemplates.findFirst({\n        where: eq(emailTemplates.id, templateId)\n      });\n      \n      if (!template) {\n        throw new Error(`Email template not found: ${templateId}`);\n      }\n      \n      const htmlTemplate = Handlebars.compile(template.htmlContent);\n      const textTemplate = Handlebars.compile(template.textContent || '');\n      const subjectTemplate = Handlebars.compile(template.subject);\n      \n      const params = {\n        ...templateParams,\n        recipientName: recipientName || recipient,\n        companyName: tenant.companyName,\n        year: new Date().getFullYear()\n      };\n      \n      htmlContent = htmlTemplate(params);\n      textContent = textTemplate(params);\n      subject = customSubject || subjectTemplate(params);\n    } else {\n      // Use content directly\n      htmlContent = wrapInTemplate(content, tenant);\n      textContent = stripHtml(content);\n      subject = customSubject || 'Mesaj de la ' + tenant.companyName;\n    }\n    \n    // Add tracking pixel if enabled\n    if (options?.trackOpens) {\n      const trackingPixel = `<img src=\"${process.env.API_URL}/api/v1/track/email/${messageId}/open\" width=\"1\" height=\"1\" style=\"display:none\" />`;\n      htmlContent = htmlContent.replace('</body>', `${trackingPixel}</body>`);\n    }\n    \n    // Build mail options\n    const mailOptions: nodemailer.SendMailOptions = {\n      from: {\n        name: tenant.emailFromName || tenant.companyName,\n        address: tenant.emailFromAddress || tenant.smtpUser\n      },\n      to: recipientName ? `\"${recipientName}\" <${recipient}>` : recipient,\n      subject,\n      html: htmlContent,\n      text: textContent,\n      replyTo: options?.replyTo || tenant.emailReplyTo,\n      cc: options?.cc,\n      bcc: options?.bcc,\n      priority: options?.priority,\n      headers: {\n        'X-Mailer': 'CerniqApp',\n        'X-Message-ID': messageId,\n        'X-Tenant-ID': tenantId\n      },\n      attachments: attachments?.map(a => ({\n        filename: a.filename,\n        path: a.path,\n        content: a.content,\n        contentType: a.contentType\n      }))\n    };\n    \n    // Send email\n    const result = await transporter.sendMail(mailOptions);\n    \n    // Update message status\n    await db.update(negotiationMessages)\n      .set({\n        status: 'delivered',\n        externalMessageId: result.messageId,\n        deliveredAt: new Date(),\n        metadata: {\n          accepted: result.accepted,\n          rejected: result.rejected,\n          response: result.response,\n          deliveryLatencyMs: Date.now() - startTime\n        }\n      })\n      .where(eq(negotiationMessages.id, messageId));\n    \n    metrics.emailMessages.inc({ status: 'delivered' });\n    metrics.emailLatency.observe(Date.now() - startTime);\n    \n    log.info('Email delivered', {\n      smtpMessageId: result.messageId,\n      accepted: result.accepted,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      messageId: result.messageId,\n      accepted: result.accepted as string[],\n      rejected: result.rejected as string[]\n    };\n    \n  } catch (error) {\n    log.error('Email delivery failed', { error });\n    \n    await db.update(negotiationMessages)\n      .set({\n        status: 'failed',\n        deliveryError: error instanceof Error ? error.message : 'Unknown error'\n      })\n      .where(eq(negotiationMessages.id, messageId));\n    \n    metrics.emailMessages.inc({ status: 'failed' });\n    throw error;\n  }\n}\n\nfunction wrapInTemplate(content: string, tenant: any): string {\n  return `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n    .header { text-align: center; padding: 20px 0; border-bottom: 2px solid #007bff; }\n    .content { padding: 20px 0; }\n    .footer { text-align: center; padding: 20px 0; border-top: 1px solid #eee; font-size: 12px; color: #666; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      ${tenant.logoUrl ? `<img src=\"${tenant.logoUrl}\" alt=\"${tenant.companyName}\" style=\"max-width: 200px;\" />` : `<h2>${tenant.companyName}</h2>`}\n    </div>\n    <div class=\"content\">\n      ${content}\n    </div>\n    <div class=\"footer\">\n      <p>${tenant.companyName}</p>\n      <p>${tenant.address}, ${tenant.city}, ${tenant.county}</p>\n      <p>Tel: ${tenant.phone || ''} | Email: ${tenant.email || ''}</p>\n    </div>\n  </div>\n</body>\n</html>`;\n}\n\nfunction stripHtml(html: string): string {\n  return html.replace(/<[^>]*>/g, '').replace(/\\s+/g, ' ').trim();\n}\n\nexport const channelEmailWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.CHANNEL_EMAIL,\n  processEmailDelivery,\n  {\n    concurrency: 15,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-j",
  "restrictii_antihalucinatie": [
    "NU hardcoda SMTP credentials - din tenant config",
    "INCLUDE tracking pixel pentru opens dacă enabled",
    "WRAP content în template HTML profesional",
    "INCLUDE text fallback pentru email clients vechi",
    "HANDLE attachments corect"
  ],
  "validare_task": "1. SMTP configuration din tenant\n2. Template rendering cu Handlebars\n3. HTML și text content\n4. Tracking pixel pentru opens\n5. Error handling cu status update",
  "outcome": "Worker channel:email funcțional pentru livrare email-uri profesionale"
}
```

## F3.11.4 Human Handover Worker (#60)

```json
{
  "taskID": "F3.11.4.T001",
  "denumire_task": "Implementare worker handover:human pentru transfer către agent uman",
  "context_anterior": "Email delivery implementat. Acum implementăm handover către agenți umani când AI nu poate gestiona.",
  "descriere_task": "Ești un expert în sisteme de handover AI-to-human. Task-ul tău este să creezi workerul pentru transfer seamless.\n\nCreează fișierul /packages/workers/src/etapa3/category-j/handover-human.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { \n  negotiations, \n  negotiationMessages, \n  handoverRequests, \n  users,\n  notificationQueue \n} from '@cerniq/db/schema';\nimport { eq, and, isNull, asc } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventEmitter } from '@cerniq/events';\n\nconst HandoverPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  reason: z.enum([\n    'user_request',\n    'ai_unable',\n    'guardrail_failure',\n    'high_value',\n    'complaint',\n    'escalation',\n    'timeout',\n    'sentiment_negative',\n    'custom'\n  ]),\n  reasonDetails: z.string().optional(),\n  priority: z.enum(['low', 'medium', 'high', 'urgent']).default('medium'),\n  preferredAgentId: z.string().uuid().optional(),\n  skillsRequired: z.array(z.string()).optional(),\n  metadata: z.record(z.any()).optional()\n});\n\ntype HandoverJob = z.infer<typeof HandoverPayload>;\n\ninterface HandoverResult {\n  success: boolean;\n  handoverId: string;\n  assignedAgentId?: string;\n  assignedAgentName?: string;\n  estimatedWaitTime?: number;\n  queuePosition?: number;\n}\n\nasync function processHumanHandover(job: Job<HandoverJob>): Promise<HandoverResult> {\n  const startTime = Date.now();\n  const log = logger.child({ \n    jobId: job.id, \n    negotiationId: job.data.negotiationId \n  });\n  \n  const { \n    tenantId, \n    negotiationId, \n    reason, \n    reasonDetails, \n    priority,\n    preferredAgentId,\n    skillsRequired,\n    metadata \n  } = job.data;\n  \n  log.info('Processing human handover', { reason, priority });\n  \n  try {\n    // Load negotiation with recent messages for context\n    const negotiation = await db.query.negotiations.findFirst({\n      where: eq(negotiations.id, negotiationId),\n      with: {\n        contact: true,\n        messages: {\n          limit: 20,\n          orderBy: (m, { desc }) => desc(m.createdAt)\n        }\n      }\n    });\n    \n    if (!negotiation) {\n      throw new Error(`Negotiation not found: ${negotiationId}`);\n    }\n    \n    // Check if handover already exists and is pending\n    const existingHandover = await db.query.handoverRequests.findFirst({\n      where: and(\n        eq(handoverRequests.negotiationId, negotiationId),\n        eq(handoverRequests.status, 'pending')\n      )\n    });\n    \n    if (existingHandover) {\n      log.info('Handover already pending', { handoverId: existingHandover.id });\n      return {\n        success: true,\n        handoverId: existingHandover.id,\n        assignedAgentId: existingHandover.assignedAgentId,\n        queuePosition: existingHandover.queuePosition\n      };\n    }\n    \n    // Build conversation summary for agent context\n    const conversationSummary = buildConversationSummary(negotiation.messages);\n    \n    // Find available agent\n    const assignedAgent = await findAvailableAgent({\n      tenantId,\n      preferredAgentId,\n      skillsRequired,\n      priority,\n      negotiationValue: negotiation.totalValue\n    });\n    \n    // Calculate queue position if no agent immediately available\n    const queuePosition = assignedAgent ? 0 : await calculateQueuePosition(tenantId, priority);\n    \n    // Create handover request\n    const handoverId = uuidv4();\n    const handover = await db.insert(handoverRequests).values({\n      id: handoverId,\n      tenantId,\n      negotiationId,\n      contactId: negotiation.contactId,\n      reason,\n      reasonDetails,\n      priority,\n      status: assignedAgent ? 'assigned' : 'pending',\n      assignedAgentId: assignedAgent?.id,\n      assignedAt: assignedAgent ? new Date() : null,\n      queuePosition,\n      estimatedWaitMinutes: queuePosition * 5, // 5 min per position estimate\n      conversationSummary,\n      lastAiMessages: negotiation.messages.slice(0, 5),\n      skillsRequired,\n      metadata,\n      createdAt: new Date()\n    }).returning();\n    \n    // Update negotiation state\n    const transitionQueue = createEtapa3Queue(ETAPA3_QUEUES.NEG_TRANSITION);\n    await transitionQueue.add('transition', {\n      tenantId,\n      negotiationId,\n      fromState: negotiation.currentState,\n      toState: 'REQUIRES_HUMAN',\n      reason: `Handover: ${reason}`,\n      triggeredBy: 'system'\n    });\n    \n    // Disable AI for this negotiation\n    await db.update(negotiations)\n      .set({ \n        aiEnabled: false,\n        assignedAgentId: assignedAgent?.id,\n        updatedAt: new Date()\n      })\n      .where(eq(negotiations.id, negotiationId));\n    \n    // Notify agent if assigned\n    if (assignedAgent) {\n      await notifyAgent(assignedAgent, handover[0], negotiation);\n    }\n    \n    // Send acknowledgment to customer\n    await sendCustomerAcknowledgment(negotiation, queuePosition, assignedAgent);\n    \n    // Emit event\n    await EventEmitter.emit('handover:created', {\n      tenantId,\n      negotiationId,\n      handoverId,\n      reason,\n      priority,\n      assignedAgentId: assignedAgent?.id\n    });\n    \n    metrics.handoverRequests.inc({ reason, priority });\n    if (assignedAgent) {\n      metrics.handoverAssigned.inc();\n    }\n    \n    log.info('Handover created', {\n      handoverId,\n      assignedAgentId: assignedAgent?.id,\n      queuePosition,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      handoverId,\n      assignedAgentId: assignedAgent?.id,\n      assignedAgentName: assignedAgent?.name,\n      estimatedWaitTime: queuePosition * 5,\n      queuePosition\n    };\n    \n  } catch (error) {\n    log.error('Handover processing failed', { error });\n    metrics.handoverErrors.inc();\n    throw error;\n  }\n}\n\nfunction buildConversationSummary(messages: any[]): string {\n  const recentMessages = messages.slice(0, 10).reverse();\n  let summary = 'REZUMAT CONVERSAȚIE:\\n\\n';\n  \n  for (const msg of recentMessages) {\n    const role = msg.role === 'user' ? 'CLIENT' : 'AI';\n    const content = msg.content.slice(0, 200);\n    summary += `[${role}]: ${content}${msg.content.length > 200 ? '...' : ''}\\n\\n`;\n  }\n  \n  return summary;\n}\n\nasync function findAvailableAgent(params: {\n  tenantId: string;\n  preferredAgentId?: string;\n  skillsRequired?: string[];\n  priority: string;\n  negotiationValue?: number;\n}): Promise<any | null> {\n  const { tenantId, preferredAgentId, skillsRequired, priority, negotiationValue } = params;\n  \n  // Try preferred agent first\n  if (preferredAgentId) {\n    const preferred = await db.query.users.findFirst({\n      where: and(\n        eq(users.id, preferredAgentId),\n        eq(users.tenantId, tenantId),\n        eq(users.status, 'available')\n      )\n    });\n    if (preferred) return preferred;\n  }\n  \n  // Find by skills and availability\n  let query = db.query.users.findMany({\n    where: and(\n      eq(users.tenantId, tenantId),\n      eq(users.role, 'sales_agent'),\n      eq(users.status, 'available')\n    ),\n    orderBy: (u, { asc }) => asc(u.activeConversations)\n  });\n  \n  const availableAgents = await query;\n  \n  // Filter by skills if required\n  if (skillsRequired?.length && availableAgents.length) {\n    const skillMatched = availableAgents.filter(agent => {\n      const agentSkills = agent.skills as string[] || [];\n      return skillsRequired.every(skill => agentSkills.includes(skill));\n    });\n    if (skillMatched.length) return skillMatched[0];\n  }\n  \n  // Return first available\n  return availableAgents[0] || null;\n}\n\nasync function calculateQueuePosition(tenantId: string, priority: string): Promise<number> {\n  const pendingCount = await db.query.handoverRequests.findMany({\n    where: and(\n      eq(handoverRequests.tenantId, tenantId),\n      eq(handoverRequests.status, 'pending')\n    )\n  });\n  \n  // Higher priority = lower position\n  const priorityOffset = { urgent: 0, high: 1, medium: 2, low: 3 };\n  return pendingCount.length + (priorityOffset[priority as keyof typeof priorityOffset] || 2);\n}\n\nasync function notifyAgent(agent: any, handover: any, negotiation: any): Promise<void> {\n  // Queue push notification\n  await db.insert(notificationQueue).values({\n    userId: agent.id,\n    type: 'handover_assigned',\n    title: 'Conversație nouă atribuită',\n    body: `Client: ${negotiation.contact.companyName || negotiation.contact.name}\\nMotiv: ${handover.reason}`,\n    data: {\n      handoverId: handover.id,\n      negotiationId: negotiation.id\n    },\n    channels: ['push', 'email', 'in_app'],\n    priority: handover.priority\n  });\n}\n\nasync function sendCustomerAcknowledgment(\n  negotiation: any, \n  queuePosition: number,\n  assignedAgent: any | null\n): Promise<void> {\n  let message: string;\n  \n  if (assignedAgent) {\n    message = `Conversația dumneavoastră a fost transferată către colegul nostru ${assignedAgent.name}. Veți fi contactat în câteva minute.`;\n  } else {\n    message = `Vă mulțumim pentru mesaj. Un coleg va prelua conversația în aproximativ ${queuePosition * 5} minute. Vă rugăm să aveți răbdare.`;\n  }\n  \n  // Queue message delivery\n  const channelQueue = createEtapa3Queue(ETAPA3_QUEUES.CHANNEL_DELIVER);\n  await channelQueue.add('deliver', {\n    tenantId: negotiation.tenantId,\n    negotiationId: negotiation.id,\n    content: message,\n    isSystemMessage: true\n  });\n}\n\nexport const handoverHumanWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.HANDOVER_HUMAN,\n  processHumanHandover,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-j",
  "restrictii_antihalucinatie": [
    "DISABLE AI pentru negociere la handover",
    "INCLUDE conversation summary pentru agent context",
    "QUEUE notification către agent",
    "TRIMITE acknowledgment către client",
    "CALCULATE queue position corect"
  ],
  "validare_task": "1. Agent assignment cu skills matching\n2. Queue position pentru pending\n3. Negotiation state transition\n4. Agent notification queued\n5. Customer acknowledgment sent",
  "outcome": "Worker handover:human funcțional pentru transfer seamless către agenți"
}
```

---

# FAZA F3.13: MCP SERVER WORKERS (CATEGORIA L)

## F3.13.1 MCP Server Core (#61)

```json
{
  "taskID": "F3.13.1.T001",
  "denumire_task": "Implementare MCP Server Core - Model Context Protocol server pentru AI Agent",
  "context_anterior": "Handover workers finalizați. Acum implementăm MCP Server pentru tool calling standardizat în AI Agent.",
  "descriere_task": "Ești un expert în Model Context Protocol și AI tool systems. Task-ul tău este să creezi serverul MCP care expune tools pentru AI Agent.\n\nCreează fișierul /packages/mcp-server/src/server.ts:\n\n```typescript\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  Tool,\n  TextContent,\n  ImageContent,\n  ToolResult\n} from '@modelcontextprotocol/sdk/types.js';\nimport { z } from 'zod';\nimport { logger } from '@cerniq/logger';\nimport { db } from '@cerniq/db';\nimport { products, negotiations, contactsGold, invoices } from '@cerniq/db/schema';\nimport { eq, and, ilike, inArray } from 'drizzle-orm';\n\n// Tool definitions for B2B agricultural sales\nconst SALES_TOOLS: Tool[] = [\n  {\n    name: 'get_product_info',\n    description: 'Obține informații despre un produs după SKU sau nume. Returnează preț, stoc, descriere.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        sku: { type: 'string', description: 'Codul produsului (SKU)' },\n        productName: { type: 'string', description: 'Numele produsului (căutare parțială)' },\n        tenantId: { type: 'string', description: 'ID-ul tenant-ului' }\n      },\n      required: ['tenantId']\n    }\n  },\n  {\n    name: 'check_stock',\n    description: 'Verifică disponibilitatea stocului pentru unul sau mai multe produse.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        items: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              sku: { type: 'string' },\n              quantity: { type: 'number' }\n            },\n            required: ['sku', 'quantity']\n          }\n        },\n        tenantId: { type: 'string' }\n      },\n      required: ['items', 'tenantId']\n    }\n  },\n  {\n    name: 'calculate_price',\n    description: 'Calculează prețul final pentru o listă de produse cu discount-uri aplicate.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        items: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              sku: { type: 'string' },\n              quantity: { type: 'number' },\n              requestedDiscount: { type: 'number', minimum: 0, maximum: 100 }\n            },\n            required: ['sku', 'quantity']\n          }\n        },\n        contactId: { type: 'string' },\n        tenantId: { type: 'string' }\n      },\n      required: ['items', 'tenantId']\n    }\n  },\n  {\n    name: 'apply_discount',\n    description: 'Solicită aplicarea unui discount pe negociere. Poate necesita aprobare HITL.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        negotiationId: { type: 'string' },\n        discountPercent: { type: 'number', minimum: 0, maximum: 50 },\n        reason: { type: 'string' },\n        tenantId: { type: 'string' }\n      },\n      required: ['negotiationId', 'discountPercent', 'reason', 'tenantId']\n    }\n  },\n  {\n    name: 'create_proposal',\n    description: 'Generează o ofertă comercială PDF pentru negocierea curentă.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        negotiationId: { type: 'string' },\n        validityDays: { type: 'number', default: 30 },\n        includeTerms: { type: 'boolean', default: true },\n        tenantId: { type: 'string' }\n      },\n      required: ['negotiationId', 'tenantId']\n    }\n  },\n  {\n    name: 'schedule_callback',\n    description: 'Programează un apel de follow-up cu clientul.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        negotiationId: { type: 'string' },\n        dateTime: { type: 'string', format: 'date-time' },\n        reason: { type: 'string' },\n        tenantId: { type: 'string' }\n      },\n      required: ['negotiationId', 'dateTime', 'tenantId']\n    }\n  },\n  {\n    name: 'get_client_info',\n    description: 'Obține informații despre clientul din negocierea curentă.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        contactId: { type: 'string' },\n        tenantId: { type: 'string' }\n      },\n      required: ['contactId', 'tenantId']\n    }\n  },\n  {\n    name: 'search_products',\n    description: 'Caută produse folosind căutare semantică sau keyword.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        query: { type: 'string', description: 'Query de căutare' },\n        category: { type: 'string', description: 'Filtru categorie' },\n        cropType: { type: 'string', description: 'Tip cultură (grâu, porumb, etc.)' },\n        maxResults: { type: 'number', default: 5 },\n        tenantId: { type: 'string' }\n      },\n      required: ['query', 'tenantId']\n    }\n  },\n  {\n    name: 'request_human_handover',\n    description: 'Solicită transferul conversației către un agent uman.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        negotiationId: { type: 'string' },\n        reason: { type: 'string', enum: [\n          'user_request', 'ai_unable', 'high_value', 'complaint', 'custom'\n        ]},\n        reasonDetails: { type: 'string' },\n        tenantId: { type: 'string' }\n      },\n      required: ['negotiationId', 'reason', 'tenantId']\n    }\n  },\n  {\n    name: 'get_negotiation_status',\n    description: 'Obține starea curentă a negocierii.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        negotiationId: { type: 'string' },\n        tenantId: { type: 'string' }\n      },\n      required: ['negotiationId', 'tenantId']\n    }\n  }\n];\n\nclass CerniqMCPServer {\n  private server: Server;\n  \n  constructor() {\n    this.server = new Server(\n      {\n        name: 'cerniq-sales-tools',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n    \n    this.setupHandlers();\n  }\n  \n  private setupHandlers(): void {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({\n      tools: SALES_TOOLS,\n    }));\n    \n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n      const log = logger.child({ tool: name });\n      \n      log.info('Tool called', { args });\n      \n      try {\n        const result = await this.executeTool(name, args as Record<string, any>);\n        return {\n          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],\n        };\n      } catch (error) {\n        log.error('Tool execution failed', { error });\n        return {\n          content: [{ type: 'text', text: JSON.stringify({ error: error.message }) }],\n          isError: true,\n        };\n      }\n    });\n  }\n  \n  private async executeTool(name: string, args: Record<string, any>): Promise<any> {\n    switch (name) {\n      case 'get_product_info':\n        return this.getProductInfo(args);\n      case 'check_stock':\n        return this.checkStock(args);\n      case 'calculate_price':\n        return this.calculatePrice(args);\n      case 'apply_discount':\n        return this.applyDiscount(args);\n      case 'create_proposal':\n        return this.createProposal(args);\n      case 'schedule_callback':\n        return this.scheduleCallback(args);\n      case 'get_client_info':\n        return this.getClientInfo(args);\n      case 'search_products':\n        return this.searchProducts(args);\n      case 'request_human_handover':\n        return this.requestHandover(args);\n      case 'get_negotiation_status':\n        return this.getNegotiationStatus(args);\n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n  }\n  \n  private async getProductInfo(args: any): Promise<any> {\n    const { tenantId, sku, productName } = args;\n    \n    let product;\n    if (sku) {\n      product = await db.query.products.findFirst({\n        where: and(\n          eq(products.tenantId, tenantId),\n          eq(products.sku, sku)\n        )\n      });\n    } else if (productName) {\n      product = await db.query.products.findFirst({\n        where: and(\n          eq(products.tenantId, tenantId),\n          ilike(products.name, `%${productName}%`)\n        )\n      });\n    }\n    \n    if (!product) {\n      return { found: false, message: 'Produsul nu a fost găsit' };\n    }\n    \n    return {\n      found: true,\n      sku: product.sku,\n      name: product.name,\n      nameRo: product.nameRo,\n      description: product.shortDescription || product.description?.slice(0, 300),\n      basePrice: parseFloat(product.basePrice),\n      priceWithVat: parseFloat(product.priceWithVat),\n      vatRate: parseFloat(product.vatRate),\n      currency: 'RON',\n      unitOfMeasure: product.unitOfMeasure,\n      availableStock: parseInt(product.availableStock || '0'),\n      brand: product.brand,\n      category: product.categoryName,\n      cropType: product.cropType,\n      maxDiscountPercent: parseFloat(product.maxDiscountPercent || '0')\n    };\n  }\n  \n  private async checkStock(args: any): Promise<any> {\n    const { tenantId, items } = args;\n    const skus = items.map((i: any) => i.sku);\n    \n    const productsList = await db.query.products.findMany({\n      where: and(\n        eq(products.tenantId, tenantId),\n        inArray(products.sku, skus)\n      )\n    });\n    \n    const productMap = new Map(productsList.map(p => [p.sku, p]));\n    \n    const results = items.map((item: any) => {\n      const product = productMap.get(item.sku);\n      if (!product) {\n        return {\n          sku: item.sku,\n          found: false,\n          available: false,\n          message: 'Produs negăsit'\n        };\n      }\n      \n      const available = parseInt(product.availableStock || '0');\n      const requested = item.quantity;\n      \n      return {\n        sku: item.sku,\n        name: product.name,\n        found: true,\n        requestedQuantity: requested,\n        availableStock: available,\n        available: available >= requested,\n        shortfall: available < requested ? requested - available : 0,\n        unitOfMeasure: product.unitOfMeasure\n      };\n    });\n    \n    return {\n      results,\n      allAvailable: results.every((r: any) => r.available),\n      checkedAt: new Date().toISOString()\n    };\n  }\n  \n  private async calculatePrice(args: any): Promise<any> {\n    const { tenantId, items, contactId } = args;\n    \n    // Get customer discount if applicable\n    let customerDiscount = 0;\n    if (contactId) {\n      const contact = await db.query.contactsGold.findFirst({\n        where: eq(contactsGold.id, contactId)\n      });\n      customerDiscount = contact?.defaultDiscount || 0;\n    }\n    \n    const skus = items.map((i: any) => i.sku);\n    const productsList = await db.query.products.findMany({\n      where: and(\n        eq(products.tenantId, tenantId),\n        inArray(products.sku, skus)\n      )\n    });\n    \n    const productMap = new Map(productsList.map(p => [p.sku, p]));\n    \n    let subtotal = 0;\n    let totalVat = 0;\n    let totalDiscount = 0;\n    \n    const lineItems = items.map((item: any) => {\n      const product = productMap.get(item.sku);\n      if (!product) {\n        return {\n          sku: item.sku,\n          error: 'Produs negăsit'\n        };\n      }\n      \n      const basePrice = parseFloat(product.basePrice);\n      const vatRate = parseFloat(product.vatRate);\n      const maxDiscount = parseFloat(product.maxDiscountPercent || '0');\n      \n      // Combine discounts\n      const requestedDiscount = Math.min(item.requestedDiscount || 0, maxDiscount);\n      const effectiveDiscount = Math.min(requestedDiscount + customerDiscount, maxDiscount);\n      \n      const discountedPrice = basePrice * (1 - effectiveDiscount / 100);\n      const lineSubtotal = discountedPrice * item.quantity;\n      const lineVat = lineSubtotal * vatRate / 100;\n      \n      subtotal += lineSubtotal;\n      totalVat += lineVat;\n      totalDiscount += (basePrice - discountedPrice) * item.quantity;\n      \n      return {\n        sku: item.sku,\n        name: product.name,\n        quantity: item.quantity,\n        unitPrice: discountedPrice,\n        unitPriceWithVat: discountedPrice * (1 + vatRate / 100),\n        discountPercent: effectiveDiscount,\n        lineSubtotal,\n        lineVat,\n        lineTotal: lineSubtotal + lineVat\n      };\n    });\n    \n    return {\n      items: lineItems,\n      summary: {\n        subtotal: Math.round(subtotal * 100) / 100,\n        totalVat: Math.round(totalVat * 100) / 100,\n        totalDiscount: Math.round(totalDiscount * 100) / 100,\n        grandTotal: Math.round((subtotal + totalVat) * 100) / 100,\n        currency: 'RON'\n      },\n      calculatedAt: new Date().toISOString()\n    };\n  }\n  \n  // Additional tool implementations...\n  private async applyDiscount(args: any): Promise<any> {\n    // Queue discount request for HITL if exceeds threshold\n    const { createEtapa3Queue, ETAPA3_QUEUES } = await import('@cerniq/workers');\n    const queue = createEtapa3Queue(ETAPA3_QUEUES.PRICE_DISCOUNT_REQUEST);\n    \n    const job = await queue.add('request', args);\n    return { queued: true, jobId: job.id, status: 'pending_approval' };\n  }\n  \n  private async createProposal(args: any): Promise<any> {\n    const { createEtapa3Queue, ETAPA3_QUEUES } = await import('@cerniq/workers');\n    const queue = createEtapa3Queue(ETAPA3_QUEUES.DOC_PROPOSAL);\n    \n    const job = await queue.add('generate', args);\n    return { queued: true, jobId: job.id, message: 'Oferta se generează...' };\n  }\n  \n  private async scheduleCallback(args: any): Promise<any> {\n    // Implementation for scheduling\n    return { scheduled: true, dateTime: args.dateTime };\n  }\n  \n  private async getClientInfo(args: any): Promise<any> {\n    const contact = await db.query.contactsGold.findFirst({\n      where: eq(contactsGold.id, args.contactId)\n    });\n    \n    if (!contact) return { found: false };\n    \n    return {\n      found: true,\n      companyName: contact.companyName,\n      cui: contact.cui,\n      contactPerson: contact.name,\n      email: contact.email,\n      phone: contact.phone,\n      tier: contact.tier,\n      totalOrders: contact.totalOrders,\n      totalValue: contact.totalValue\n    };\n  }\n  \n  private async searchProducts(args: any): Promise<any> {\n    // Use RAG search\n    const { createEtapa3Queue, ETAPA3_QUEUES } = await import('@cerniq/workers');\n    const queue = createEtapa3Queue(ETAPA3_QUEUES.RAG_HYBRID_MERGE);\n    \n    const job = await queue.add('search', {\n      tenantId: args.tenantId,\n      query: args.query,\n      topK: args.maxResults || 5,\n      filters: {\n        cropTypes: args.cropType ? [args.cropType] : undefined\n      }\n    });\n    \n    const result = await job.waitUntilFinished(queue, 30000);\n    return result;\n  }\n  \n  private async requestHandover(args: any): Promise<any> {\n    const { createEtapa3Queue, ETAPA3_QUEUES } = await import('@cerniq/workers');\n    const queue = createEtapa3Queue(ETAPA3_QUEUES.HANDOVER_HUMAN);\n    \n    const job = await queue.add('handover', args);\n    return { queued: true, jobId: job.id, message: 'Transfer către agent solicitat' };\n  }\n  \n  private async getNegotiationStatus(args: any): Promise<any> {\n    const negotiation = await db.query.negotiations.findFirst({\n      where: eq(negotiations.id, args.negotiationId)\n    });\n    \n    if (!negotiation) return { found: false };\n    \n    return {\n      found: true,\n      currentState: negotiation.currentState,\n      priority: negotiation.priority,\n      totalValue: negotiation.totalValue,\n      discountPercent: negotiation.discountPercent,\n      aiEnabled: negotiation.aiEnabled,\n      createdAt: negotiation.createdAt\n    };\n  }\n  \n  async run(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    logger.info('CerniqMCP Server started');\n  }\n}\n\n// Start server\nconst server = new CerniqMCPServer();\nserver.run().catch(console.error);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/mcp-server/src",
  "restrictii_antihalucinatie": [
    "EXPUNE doar tools definite explicit - nu permite arbitrary execution",
    "VALIDEAZĂ input cu schema înainte de execution",
    "QUEUE operații complexe (proposals, handover) - nu execută inline",
    "INCLUDE tenantId în toate operațiile pentru izolare",
    "LOGEAZĂ toate tool calls pentru audit"
  ],
  "validare_task": "1. Tools expuse conform MCP SDK\n2. Input validation cu schema\n3. Queue integration pentru async ops\n4. Error handling cu mesaje clare\n5. Logging și audit trail",
  "outcome": "MCP Server funcțional pentru AI Agent cu tools pentru vânzări B2B"
}
```

## F3.13.2 MCP Tool Execute Worker (#62)

```json
{
  "taskID": "F3.13.2.T001",
  "denumire_task": "Implementare worker mcp:tool-execute pentru execuție tool calls din AI",
  "context_anterior": "MCP Server implementat. Acum implementăm workerul care procesează tool calls din orchestrator.",
  "descriere_task": "Ești un expert în tool execution pentru AI agents. Task-ul tău este să creezi workerul care execută tool calls în mod sigur.\n\nCreează fișierul /packages/workers/src/etapa3/category-l/mcp-tool-execute.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { toolExecutions, products, negotiations } from '@cerniq/db/schema';\nimport { eq, and, inArray } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst ToolExecutePayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid(),\n  messageId: z.string().uuid().optional(),\n  toolName: z.string(),\n  toolInput: z.record(z.any()),\n  callId: z.string().optional(), // For tracking in conversation\n  timeout: z.number().default(30000)\n});\n\ntype ToolExecuteJob = z.infer<typeof ToolExecutePayload>;\n\ninterface ToolExecutionResult {\n  success: boolean;\n  toolName: string;\n  callId?: string;\n  result?: any;\n  error?: string;\n  executionTimeMs: number;\n  cached: boolean;\n}\n\n// Tool implementations\nconst TOOL_HANDLERS: Record<string, (input: any, ctx: ToolContext) => Promise<any>> = {\n  get_product_info: async (input, ctx) => {\n    const { sku, productName } = input;\n    \n    let product;\n    if (sku) {\n      product = await db.query.products.findFirst({\n        where: and(\n          eq(products.tenantId, ctx.tenantId),\n          eq(products.sku, sku)\n        )\n      });\n    } else if (productName) {\n      product = await db.query.products.findFirst({\n        where: and(\n          eq(products.tenantId, ctx.tenantId),\n          sql`name ILIKE ${'%' + productName + '%'}`\n        )\n      });\n    }\n    \n    if (!product) {\n      return { found: false, message: 'Produsul nu a fost găsit' };\n    }\n    \n    return {\n      found: true,\n      sku: product.sku,\n      name: product.name,\n      description: product.shortDescription || product.description?.slice(0, 300),\n      basePrice: parseFloat(product.basePrice),\n      priceWithVat: parseFloat(product.priceWithVat),\n      vatRate: parseFloat(product.vatRate),\n      currency: 'RON',\n      unitOfMeasure: product.unitOfMeasure,\n      availableStock: parseInt(product.availableStock || '0'),\n      brand: product.brand,\n      category: product.categoryName,\n      cropType: product.cropType,\n      maxDiscountPercent: parseFloat(product.maxDiscountPercent || '0')\n    };\n  },\n  \n  check_stock: async (input, ctx) => {\n    const { items } = input;\n    const skus = items.map((i: any) => i.sku);\n    \n    const productsList = await db.query.products.findMany({\n      where: and(\n        eq(products.tenantId, ctx.tenantId),\n        inArray(products.sku, skus)\n      )\n    });\n    \n    const productMap = new Map(productsList.map(p => [p.sku, p]));\n    \n    const results = items.map((item: any) => {\n      const product = productMap.get(item.sku);\n      if (!product) {\n        return {\n          sku: item.sku,\n          found: false,\n          available: false\n        };\n      }\n      \n      const available = parseInt(product.availableStock || '0');\n      const reserved = parseInt(product.reservedStock || '0');\n      const actualAvailable = available - reserved;\n      \n      return {\n        sku: item.sku,\n        name: product.name,\n        found: true,\n        requestedQuantity: item.quantity,\n        currentStock: available,\n        reservedStock: reserved,\n        availableStock: actualAvailable,\n        available: actualAvailable >= item.quantity,\n        shortfall: actualAvailable < item.quantity ? item.quantity - actualAvailable : 0\n      };\n    });\n    \n    return {\n      results,\n      allAvailable: results.every((r: any) => r.available),\n      summary: {\n        totalItems: items.length,\n        availableItems: results.filter((r: any) => r.available).length,\n        unavailableItems: results.filter((r: any) => !r.available).length\n      }\n    };\n  },\n  \n  calculate_price: async (input, ctx) => {\n    // Delegate to price calculation worker for complex logic\n    const priceQueue = createEtapa3Queue(ETAPA3_QUEUES.PRICE_CALCULATE);\n    const job = await priceQueue.add('calculate', {\n      tenantId: ctx.tenantId,\n      negotiationId: ctx.negotiationId,\n      contactId: input.contactId,\n      items: input.items\n    });\n    \n    return await job.waitUntilFinished(priceQueue, 30000);\n  },\n  \n  apply_discount: async (input, ctx) => {\n    const { discountPercent, reason } = input;\n    \n    // Load negotiation to check limits\n    const negotiation = await db.query.negotiations.findFirst({\n      where: eq(negotiations.id, ctx.negotiationId)\n    });\n    \n    if (!negotiation) {\n      return { success: false, error: 'Negocierea nu a fost găsită' };\n    }\n    \n    const maxAutoDiscount = negotiation.maxAutoDiscountPercent || 10;\n    \n    if (discountPercent <= maxAutoDiscount) {\n      // Auto-approve\n      await db.update(negotiations)\n        .set({\n          discountPercent,\n          discountAppliedAt: new Date(),\n          discountReason: reason\n        })\n        .where(eq(negotiations.id, ctx.negotiationId));\n      \n      return {\n        success: true,\n        approved: true,\n        discountPercent,\n        message: `Discount de ${discountPercent}% aplicat`\n      };\n    } else {\n      // Needs HITL approval\n      const hitlQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_CREATE_APPROVAL);\n      const job = await hitlQueue.add('discount-approval', {\n        tenantId: ctx.tenantId,\n        negotiationId: ctx.negotiationId,\n        approvalType: 'discount',\n        requestedValue: discountPercent,\n        reason,\n        requestedBy: 'ai_agent'\n      });\n      \n      return {\n        success: true,\n        approved: false,\n        pendingApproval: true,\n        approvalId: job.id,\n        message: `Discount de ${discountPercent}% necesită aprobare (maxim auto: ${maxAutoDiscount}%)`\n      };\n    }\n  },\n  \n  create_proposal: async (input, ctx) => {\n    const proposalQueue = createEtapa3Queue(ETAPA3_QUEUES.DOC_PROPOSAL);\n    const job = await proposalQueue.add('generate', {\n      tenantId: ctx.tenantId,\n      negotiationId: ctx.negotiationId,\n      ...input\n    });\n    \n    // Wait for generation (with timeout)\n    try {\n      const result = await job.waitUntilFinished(proposalQueue, 60000);\n      return {\n        success: true,\n        documentId: result.documentId,\n        documentNumber: result.documentNumber,\n        pdfUrl: result.pdfUrl\n      };\n    } catch (error) {\n      return {\n        success: false,\n        queued: true,\n        jobId: job.id,\n        message: 'Oferta se generează. Veți primi link-ul în curând.'\n      };\n    }\n  },\n  \n  request_human_handover: async (input, ctx) => {\n    const handoverQueue = createEtapa3Queue(ETAPA3_QUEUES.HANDOVER_HUMAN);\n    await handoverQueue.add('handover', {\n      tenantId: ctx.tenantId,\n      negotiationId: ctx.negotiationId,\n      reason: input.reason,\n      reasonDetails: input.reasonDetails,\n      priority: input.reason === 'complaint' ? 'high' : 'medium'\n    });\n    \n    return {\n      success: true,\n      message: 'Conversația va fi preluată de un coleg în scurt timp.'\n    };\n  }\n};\n\ninterface ToolContext {\n  tenantId: string;\n  negotiationId: string;\n  messageId?: string;\n}\n\nasync function processToolExecute(job: Job<ToolExecuteJob>): Promise<ToolExecutionResult> {\n  const startTime = Date.now();\n  const executionId = uuidv4();\n  const log = logger.child({ \n    jobId: job.id, \n    toolName: job.data.toolName,\n    executionId \n  });\n  \n  const { tenantId, negotiationId, messageId, toolName, toolInput, callId } = job.data;\n  \n  log.info('Executing tool', { input: JSON.stringify(toolInput).slice(0, 200) });\n  \n  const ctx: ToolContext = { tenantId, negotiationId, messageId };\n  \n  try {\n    // Check if tool exists\n    const handler = TOOL_HANDLERS[toolName];\n    if (!handler) {\n      throw new Error(`Unknown tool: ${toolName}`);\n    }\n    \n    // Execute tool\n    const result = await Promise.race([\n      handler(toolInput, ctx),\n      new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Tool execution timeout')), job.data.timeout)\n      )\n    ]);\n    \n    const executionTimeMs = Date.now() - startTime;\n    \n    // Log execution\n    await db.insert(toolExecutions).values({\n      id: executionId,\n      tenantId,\n      negotiationId,\n      messageId,\n      toolName,\n      toolInput,\n      toolOutput: result,\n      success: true,\n      executionTimeMs,\n      callId,\n      createdAt: new Date()\n    });\n    \n    metrics.toolExecutions.inc({ tool: toolName, status: 'success' });\n    metrics.toolLatency.observe({ tool: toolName }, executionTimeMs);\n    \n    log.info('Tool executed successfully', { executionTimeMs });\n    \n    return {\n      success: true,\n      toolName,\n      callId,\n      result,\n      executionTimeMs,\n      cached: false\n    };\n    \n  } catch (error) {\n    const executionTimeMs = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    log.error('Tool execution failed', { error: errorMessage });\n    \n    // Log failed execution\n    await db.insert(toolExecutions).values({\n      id: executionId,\n      tenantId,\n      negotiationId,\n      messageId,\n      toolName,\n      toolInput,\n      toolOutput: null,\n      success: false,\n      errorMessage,\n      executionTimeMs,\n      callId,\n      createdAt: new Date()\n    });\n    \n    metrics.toolExecutions.inc({ tool: toolName, status: 'error' });\n    \n    return {\n      success: false,\n      toolName,\n      callId,\n      error: errorMessage,\n      executionTimeMs,\n      cached: false\n    };\n  }\n}\n\nexport const mcpToolExecuteWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.MCP_TOOL_EXECUTE,\n  processToolExecute,\n  {\n    concurrency: 15,\n    limiter: {\n      max: 100,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-l",
  "restrictii_antihalucinatie": [
    "HANDLER explicit per tool - nu permite dynamic execution",
    "TIMEOUT pentru toate execuțiile",
    "LOG toate execuțiile în tool_executions pentru audit",
    "DELEGATE operații complexe către workers specializați",
    "HITL auto pentru discount-uri peste prag"
  ],
  "validare_task": "1. Handler registration explicit\n2. Timeout protection\n3. Audit logging complet\n4. Queue delegation pentru ops complexe\n5. HITL integration pentru aprobări",
  "outcome": "Worker mcp:tool-execute funcțional pentru execuție sigură tool calls"
}
```

---

# FAZA F3.15: HUMAN INTERVENTION & HITL WORKERS (CATEGORIA N)

## F3.15.1 HITL Approval Create Worker (#71)

```json
{
  "taskID": "F3.15.1.T001",
  "denumire_task": "Implementare worker hitl:create-approval pentru creare cereri aprobare",
  "context_anterior": "MCP Server workers finalizați. Acum implementăm sistemul HITL pentru aprobare umană în proces.",
  "descriere_task": "Ești un expert în sisteme de workflow cu aprobare umană. Task-ul tău este să creezi workerul pentru creare cereri de aprobare.\n\nCreează fișierul /packages/workers/src/etapa3/category-n/hitl-create-approval.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { \n  hitlApprovals, \n  negotiations, \n  users,\n  notificationQueue \n} from '@cerniq/db/schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventEmitter } from '@cerniq/events';\n\nconst HITLCreateApprovalPayload = z.object({\n  tenantId: z.string().uuid(),\n  negotiationId: z.string().uuid().optional(),\n  entityType: z.enum(['negotiation', 'contact', 'product', 'invoice', 'general']),\n  entityId: z.string().uuid().optional(),\n  approvalType: z.enum([\n    'discount',\n    'price_override',\n    'credit_extension',\n    'data_correction',\n    'content_review',\n    'document_approval',\n    'exception_request',\n    'refund',\n    'custom'\n  ]),\n  requestedValue: z.any(),\n  currentValue: z.any().optional(),\n  reason: z.string(),\n  requestedBy: z.enum(['ai_agent', 'user', 'system']),\n  requestedByUserId: z.string().uuid().optional(),\n  priority: z.enum(['low', 'medium', 'high', 'urgent']).default('medium'),\n  slaMinutes: z.number().optional(), // Override default SLA\n  requiredApprovers: z.number().min(1).default(1),\n  approverUserIds: z.array(z.string().uuid()).optional(), // Specific approvers\n  approverRoles: z.array(z.string()).optional(), // Or roles that can approve\n  contextData: z.record(z.any()).optional(),\n  autoExpireMinutes: z.number().optional()\n});\n\ntype HITLCreateApprovalJob = z.infer<typeof HITLCreateApprovalPayload>;\n\ninterface ApprovalResult {\n  success: boolean;\n  approvalId: string;\n  status: 'pending' | 'auto_approved' | 'auto_rejected';\n  assignedApprovers: string[];\n  slaDeadline: string;\n  queuePosition?: number;\n}\n\n// SLA configuration per approval type (minutes)\nconst SLA_CONFIG: Record<string, Record<string, number>> = {\n  discount: { low: 480, medium: 120, high: 30, urgent: 15 },\n  price_override: { low: 480, medium: 120, high: 30, urgent: 15 },\n  credit_extension: { low: 1440, medium: 480, high: 120, urgent: 60 },\n  data_correction: { low: 1440, medium: 480, high: 120, urgent: 30 },\n  content_review: { low: 240, medium: 60, high: 30, urgent: 15 },\n  document_approval: { low: 480, medium: 120, high: 60, urgent: 30 },\n  exception_request: { low: 480, medium: 240, high: 60, urgent: 30 },\n  refund: { low: 1440, medium: 480, high: 120, urgent: 60 },\n  custom: { low: 480, medium: 240, high: 120, urgent: 60 }\n};\n\nasync function processHITLCreateApproval(job: Job<HITLCreateApprovalJob>): Promise<ApprovalResult> {\n  const startTime = Date.now();\n  const approvalId = uuidv4();\n  const log = logger.child({ \n    jobId: job.id, \n    approvalId,\n    approvalType: job.data.approvalType \n  });\n  \n  const { \n    tenantId,\n    negotiationId,\n    entityType,\n    entityId,\n    approvalType,\n    requestedValue,\n    currentValue,\n    reason,\n    requestedBy,\n    requestedByUserId,\n    priority,\n    slaMinutes,\n    requiredApprovers,\n    approverUserIds,\n    approverRoles,\n    contextData,\n    autoExpireMinutes\n  } = job.data;\n  \n  log.info('Creating HITL approval request', { approvalType, priority });\n  \n  try {\n    // Check for auto-approval rules\n    const autoApprovalResult = await checkAutoApproval({\n      tenantId,\n      approvalType,\n      requestedValue,\n      currentValue,\n      contextData\n    });\n    \n    if (autoApprovalResult.autoApproved !== undefined) {\n      log.info('Auto-decision made', { autoApproved: autoApprovalResult.autoApproved });\n      \n      // Create record but mark as auto-resolved\n      await db.insert(hitlApprovals).values({\n        id: approvalId,\n        tenantId,\n        negotiationId,\n        entityType,\n        entityId,\n        approvalType,\n        status: autoApprovalResult.autoApproved ? 'approved' : 'rejected',\n        requestedValue: JSON.stringify(requestedValue),\n        currentValue: currentValue ? JSON.stringify(currentValue) : null,\n        reason,\n        requestedBy,\n        requestedByUserId,\n        priority,\n        resolvedBy: 'system',\n        resolvedAt: new Date(),\n        resolutionReason: autoApprovalResult.reason,\n        isAutoResolved: true,\n        contextData,\n        createdAt: new Date()\n      });\n      \n      // Execute post-approval action if auto-approved\n      if (autoApprovalResult.autoApproved) {\n        await executeApprovalAction(tenantId, approvalType, entityId, requestedValue);\n      }\n      \n      metrics.hitlAutoResolved.inc({ type: approvalType, result: autoApprovalResult.autoApproved ? 'approved' : 'rejected' });\n      \n      return {\n        success: true,\n        approvalId,\n        status: autoApprovalResult.autoApproved ? 'auto_approved' : 'auto_rejected',\n        assignedApprovers: [],\n        slaDeadline: new Date().toISOString()\n      };\n    }\n    \n    // Find eligible approvers\n    const approvers = await findEligibleApprovers({\n      tenantId,\n      approvalType,\n      approverUserIds,\n      approverRoles,\n      requiredApprovers\n    });\n    \n    if (approvers.length === 0) {\n      log.warn('No eligible approvers found');\n      // Escalate to tenant admin\n      approvers.push(...await getTenantAdmins(tenantId));\n    }\n    \n    // Calculate SLA deadline\n    const slaConfig = SLA_CONFIG[approvalType] || SLA_CONFIG.custom;\n    const effectiveSlaMinutes = slaMinutes || slaConfig[priority];\n    const slaDeadline = new Date(Date.now() + effectiveSlaMinutes * 60 * 1000);\n    \n    // Calculate expiry if set\n    const expiresAt = autoExpireMinutes \n      ? new Date(Date.now() + autoExpireMinutes * 60 * 1000)\n      : null;\n    \n    // Create approval request\n    await db.insert(hitlApprovals).values({\n      id: approvalId,\n      tenantId,\n      negotiationId,\n      entityType,\n      entityId,\n      approvalType,\n      status: 'pending',\n      requestedValue: JSON.stringify(requestedValue),\n      currentValue: currentValue ? JSON.stringify(currentValue) : null,\n      reason,\n      requestedBy,\n      requestedByUserId,\n      priority,\n      requiredApprovers,\n      currentApprovers: 0,\n      assignedApproverIds: approvers.map(a => a.id),\n      slaDeadline,\n      slaMinutes: effectiveSlaMinutes,\n      expiresAt,\n      contextData,\n      createdAt: new Date()\n    });\n    \n    // Notify approvers\n    for (const approver of approvers) {\n      await db.insert(notificationQueue).values({\n        userId: approver.id,\n        type: 'approval_required',\n        title: `Aprobare necesară: ${getApprovalTypeLabel(approvalType)}`,\n        body: reason.slice(0, 200),\n        data: {\n          approvalId,\n          approvalType,\n          priority,\n          negotiationId,\n          slaDeadline: slaDeadline.toISOString()\n        },\n        channels: priority === 'urgent' ? ['push', 'sms', 'email'] : ['push', 'email'],\n        priority\n      });\n    }\n    \n    // Schedule SLA escalation check\n    const escalationQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_SLA_CHECK);\n    await escalationQueue.add('check', {\n      approvalId,\n      tenantId\n    }, {\n      delay: effectiveSlaMinutes * 60 * 1000 * 0.8 // Check at 80% of SLA\n    });\n    \n    // Schedule expiry check if applicable\n    if (expiresAt) {\n      await escalationQueue.add('expire-check', {\n        approvalId,\n        tenantId\n      }, {\n        delay: autoExpireMinutes * 60 * 1000\n      });\n    }\n    \n    // If negotiation involved, pause AI\n    if (negotiationId) {\n      await db.update(negotiations)\n        .set({ \n          aiEnabled: false,\n          pendingApprovalId: approvalId,\n          updatedAt: new Date()\n        })\n        .where(eq(negotiations.id, negotiationId));\n    }\n    \n    // Emit event\n    await EventEmitter.emit('hitl:approval:created', {\n      tenantId,\n      approvalId,\n      approvalType,\n      priority,\n      assignedApprovers: approvers.map(a => a.id)\n    });\n    \n    metrics.hitlApprovals.inc({ type: approvalType, priority });\n    \n    log.info('HITL approval created', {\n      approvalId,\n      approverCount: approvers.length,\n      slaDeadline: slaDeadline.toISOString(),\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      approvalId,\n      status: 'pending',\n      assignedApprovers: approvers.map(a => a.id),\n      slaDeadline: slaDeadline.toISOString()\n    };\n    \n  } catch (error) {\n    log.error('Failed to create HITL approval', { error });\n    metrics.hitlErrors.inc({ type: approvalType });\n    throw error;\n  }\n}\n\nasync function checkAutoApproval(params: any): Promise<{ autoApproved?: boolean; reason?: string }> {\n  const { tenantId, approvalType, requestedValue, currentValue, contextData } = params;\n  \n  // Auto-approval rules\n  if (approvalType === 'discount') {\n    const discountPercent = typeof requestedValue === 'number' \n      ? requestedValue \n      : parseFloat(requestedValue);\n    \n    // Auto-reject if > 50%\n    if (discountPercent > 50) {\n      return { autoApproved: false, reason: 'Discount exceeds maximum allowed (50%)' };\n    }\n    \n    // Auto-approve if <= 5%\n    if (discountPercent <= 5) {\n      return { autoApproved: true, reason: 'Discount within auto-approval threshold (5%)' };\n    }\n  }\n  \n  if (approvalType === 'data_correction') {\n    // Auto-approve minor corrections (e.g., typos)\n    if (contextData?.correctionType === 'typo') {\n      return { autoApproved: true, reason: 'Minor correction auto-approved' };\n    }\n  }\n  \n  // No auto-decision\n  return {};\n}\n\nasync function findEligibleApprovers(params: any): Promise<any[]> {\n  const { tenantId, approvalType, approverUserIds, approverRoles, requiredApprovers } = params;\n  \n  // If specific approvers specified\n  if (approverUserIds?.length) {\n    return await db.query.users.findMany({\n      where: and(\n        eq(users.tenantId, tenantId),\n        sql`id = ANY(${approverUserIds})`,\n        eq(users.status, 'active')\n      )\n    });\n  }\n  \n  // Find by roles or default approval roles\n  const roles = approverRoles?.length \n    ? approverRoles \n    : getDefaultApproverRoles(approvalType);\n  \n  return await db.query.users.findMany({\n    where: and(\n      eq(users.tenantId, tenantId),\n      sql`role = ANY(${roles})`,\n      eq(users.status, 'active')\n    ),\n    limit: Math.max(requiredApprovers * 2, 5) // Get more than needed\n  });\n}\n\nfunction getDefaultApproverRoles(approvalType: string): string[] {\n  const roleMap: Record<string, string[]> = {\n    discount: ['sales_manager', 'admin'],\n    price_override: ['sales_manager', 'admin'],\n    credit_extension: ['finance_manager', 'admin'],\n    data_correction: ['data_admin', 'admin'],\n    content_review: ['content_manager', 'admin'],\n    document_approval: ['sales_manager', 'admin'],\n    exception_request: ['admin'],\n    refund: ['finance_manager', 'admin'],\n    custom: ['admin']\n  };\n  \n  return roleMap[approvalType] || ['admin'];\n}\n\nasync function getTenantAdmins(tenantId: string): Promise<any[]> {\n  return await db.query.users.findMany({\n    where: and(\n      eq(users.tenantId, tenantId),\n      eq(users.role, 'admin'),\n      eq(users.status, 'active')\n    )\n  });\n}\n\nfunction getApprovalTypeLabel(type: string): string {\n  const labels: Record<string, string> = {\n    discount: 'Discount',\n    price_override: 'Modificare Preț',\n    credit_extension: 'Extindere Credit',\n    data_correction: 'Corecție Date',\n    content_review: 'Revizuire Conținut',\n    document_approval: 'Aprobare Document',\n    exception_request: 'Excepție',\n    refund: 'Ramburs',\n    custom: 'Aprobare'\n  };\n  return labels[type] || 'Aprobare';\n}\n\nasync function executeApprovalAction(\n  tenantId: string,\n  approvalType: string,\n  entityId: string | undefined,\n  requestedValue: any\n): Promise<void> {\n  // Execute the approved action\n  switch (approvalType) {\n    case 'discount':\n      if (entityId) {\n        await db.update(negotiations)\n          .set({ \n            discountPercent: requestedValue,\n            discountAppliedAt: new Date()\n          })\n          .where(eq(negotiations.id, entityId));\n      }\n      break;\n    // Add other approval type actions...\n  }\n}\n\nexport const hitlCreateApprovalWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.HITL_CREATE_APPROVAL,\n  processHITLCreateApproval,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-n",
  "restrictii_antihalucinatie": [
    "CHECK auto-approval rules înainte de creare cerere",
    "NOTIFY toți approvers assignați",
    "SCHEDULE SLA check la 80% din deadline",
    "PAUSE AI pe negociere când pending approval",
    "ESCALATE la admin dacă nu există approvers"
  ],
  "validare_task": "1. Auto-approval/rejection pentru cazuri clare\n2. Approver assignment funcțional\n3. SLA deadline calculat per type/priority\n4. Notification queued pentru approvers\n5. Escalation scheduled",
  "outcome": "Worker hitl:create-approval funcțional pentru creare cereri aprobare cu SLA"
}
```

## F3.15.2 HITL Process Approval Worker (#72)

```json
{
  "taskID": "F3.15.2.T001",
  "denumire_task": "Implementare worker hitl:process-approval pentru procesare decizii aprobare",
  "context_anterior": "HITL Create implementat. Acum implementăm procesarea deciziilor de aprobare/respingere.",
  "descriere_task": "Ești un expert în workflow approval systems. Task-ul tău este să creezi workerul pentru procesare decizii.\n\nCreează fișierul /packages/workers/src/etapa3/category-n/hitl-process-approval.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { \n  hitlApprovals, \n  hitlApprovalVotes,\n  negotiations,\n  notificationQueue \n} from '@cerniq/db/schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventEmitter } from '@cerniq/events';\n\nconst HITLProcessApprovalPayload = z.object({\n  tenantId: z.string().uuid(),\n  approvalId: z.string().uuid(),\n  approverId: z.string().uuid(),\n  decision: z.enum(['approve', 'reject', 'request_info']),\n  comment: z.string().optional(),\n  modifiedValue: z.any().optional(), // For partial approvals\n  conditions: z.array(z.string()).optional() // Conditional approval\n});\n\ntype HITLProcessApprovalJob = z.infer<typeof HITLProcessApprovalPayload>;\n\ninterface ProcessResult {\n  success: boolean;\n  approvalStatus: 'pending' | 'approved' | 'rejected' | 'info_requested';\n  remainingApprovers: number;\n  actionExecuted: boolean;\n}\n\nasync function processHITLApproval(job: Job<HITLProcessApprovalJob>): Promise<ProcessResult> {\n  const startTime = Date.now();\n  const log = logger.child({ \n    jobId: job.id, \n    approvalId: job.data.approvalId \n  });\n  \n  const { \n    tenantId,\n    approvalId,\n    approverId,\n    decision,\n    comment,\n    modifiedValue,\n    conditions\n  } = job.data;\n  \n  log.info('Processing approval decision', { decision });\n  \n  try {\n    // Load approval request\n    const approval = await db.query.hitlApprovals.findFirst({\n      where: eq(hitlApprovals.id, approvalId)\n    });\n    \n    if (!approval) {\n      throw new Error(`Approval not found: ${approvalId}`);\n    }\n    \n    // Validate approver is authorized\n    const assignedApprovers = approval.assignedApproverIds as string[] || [];\n    if (!assignedApprovers.includes(approverId)) {\n      throw new Error('User not authorized to approve this request');\n    }\n    \n    // Check if already resolved\n    if (approval.status !== 'pending') {\n      log.info('Approval already resolved', { status: approval.status });\n      return {\n        success: true,\n        approvalStatus: approval.status as any,\n        remainingApprovers: 0,\n        actionExecuted: false\n      };\n    }\n    \n    // Check if approver already voted\n    const existingVote = await db.query.hitlApprovalVotes.findFirst({\n      where: and(\n        eq(hitlApprovalVotes.approvalId, approvalId),\n        eq(hitlApprovalVotes.approverId, approverId)\n      )\n    });\n    \n    if (existingVote) {\n      throw new Error('Approver already voted on this request');\n    }\n    \n    // Record vote\n    await db.insert(hitlApprovalVotes).values({\n      id: uuidv4(),\n      approvalId,\n      approverId,\n      decision,\n      comment,\n      modifiedValue: modifiedValue ? JSON.stringify(modifiedValue) : null,\n      conditions,\n      votedAt: new Date()\n    });\n    \n    // Get all votes for this approval\n    const allVotes = await db.query.hitlApprovalVotes.findMany({\n      where: eq(hitlApprovalVotes.approvalId, approvalId)\n    });\n    \n    const approveVotes = allVotes.filter(v => v.decision === 'approve').length;\n    const rejectVotes = allVotes.filter(v => v.decision === 'reject').length;\n    const infoVotes = allVotes.filter(v => v.decision === 'request_info').length;\n    \n    // Determine final status\n    let finalStatus: string = 'pending';\n    let actionExecuted = false;\n    \n    // Rejection overrides (any reject = rejected)\n    if (rejectVotes > 0) {\n      finalStatus = 'rejected';\n    }\n    // Info request pauses (any info request = waiting)\n    else if (infoVotes > 0) {\n      finalStatus = 'info_requested';\n    }\n    // Approval requires quorum\n    else if (approveVotes >= approval.requiredApprovers) {\n      finalStatus = 'approved';\n    }\n    \n    // Update approval record\n    const updateData: any = {\n      currentApprovers: approveVotes,\n      lastVoteAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    if (finalStatus !== 'pending') {\n      updateData.status = finalStatus;\n      updateData.resolvedAt = new Date();\n      updateData.resolvedBy = approverId;\n      updateData.resolutionComment = comment;\n      \n      if (modifiedValue) {\n        updateData.approvedValue = JSON.stringify(modifiedValue);\n      }\n      if (conditions?.length) {\n        updateData.approvalConditions = conditions;\n      }\n    }\n    \n    await db.update(hitlApprovals)\n      .set(updateData)\n      .where(eq(hitlApprovals.id, approvalId));\n    \n    // Execute action if approved\n    if (finalStatus === 'approved') {\n      actionExecuted = await executeApprovalAction(approval, modifiedValue);\n      \n      // Re-enable AI if negotiation involved\n      if (approval.negotiationId) {\n        await db.update(negotiations)\n          .set({ \n            aiEnabled: true,\n            pendingApprovalId: null,\n            updatedAt: new Date()\n          })\n          .where(eq(negotiations.id, approval.negotiationId));\n        \n        // Queue notification to AI orchestrator to resume\n        const aiQueue = createEtapa3Queue(ETAPA3_QUEUES.AI_ORCHESTRATE);\n        await aiQueue.add('resume', {\n          tenantId,\n          negotiationId: approval.negotiationId,\n          approvalResult: {\n            approvalId,\n            decision: 'approved',\n            approvedValue: modifiedValue || JSON.parse(approval.requestedValue)\n          }\n        });\n      }\n    }\n    \n    // Notify requester of decision\n    if (finalStatus !== 'pending') {\n      await notifyRequester(approval, finalStatus, comment, modifiedValue);\n    }\n    \n    // Emit event\n    await EventEmitter.emit('hitl:approval:processed', {\n      tenantId,\n      approvalId,\n      decision,\n      finalStatus,\n      approverId\n    });\n    \n    // Update metrics\n    metrics.hitlDecisions.inc({ \n      type: approval.approvalType, \n      decision: finalStatus \n    });\n    \n    if (finalStatus !== 'pending') {\n      const resolutionTimeMs = new Date().getTime() - new Date(approval.createdAt).getTime();\n      metrics.hitlResolutionTime.observe({ type: approval.approvalType }, resolutionTimeMs / 1000);\n    }\n    \n    log.info('Approval decision processed', {\n      finalStatus,\n      approveVotes,\n      rejectVotes,\n      actionExecuted,\n      latencyMs: Date.now() - startTime\n    });\n    \n    return {\n      success: true,\n      approvalStatus: finalStatus as any,\n      remainingApprovers: Math.max(0, approval.requiredApprovers - approveVotes),\n      actionExecuted\n    };\n    \n  } catch (error) {\n    log.error('Failed to process approval', { error });\n    throw error;\n  }\n}\n\nasync function executeApprovalAction(approval: any, modifiedValue?: any): Promise<boolean> {\n  const value = modifiedValue || JSON.parse(approval.requestedValue);\n  \n  switch (approval.approvalType) {\n    case 'discount':\n      if (approval.negotiationId) {\n        await db.update(negotiations)\n          .set({ \n            discountPercent: value,\n            discountAppliedAt: new Date(),\n            discountApprovedBy: approval.resolvedBy\n          })\n          .where(eq(negotiations.id, approval.negotiationId));\n        return true;\n      }\n      break;\n      \n    case 'price_override':\n      // Apply price override\n      // Implementation specific to your price system\n      return true;\n      \n    case 'document_approval':\n      // Mark document as approved\n      const { documents } = await import('@cerniq/db/schema');\n      if (approval.entityId) {\n        await db.update(documents)\n          .set({ \n            status: 'approved',\n            approvedAt: new Date(),\n            approvedBy: approval.resolvedBy\n          })\n          .where(eq(documents.id, approval.entityId));\n        return true;\n      }\n      break;\n      \n    // Add other approval type actions...\n  }\n  \n  return false;\n}\n\nasync function notifyRequester(\n  approval: any,\n  finalStatus: string,\n  comment?: string,\n  modifiedValue?: any\n): Promise<void> {\n  const notificationData = {\n    type: 'approval_result',\n    title: finalStatus === 'approved' \n      ? 'Cerere aprobată' \n      : finalStatus === 'rejected'\n        ? 'Cerere respinsă'\n        : 'Informații suplimentare necesare',\n    body: comment || `Cererea de ${approval.approvalType} a fost ${finalStatus === 'approved' ? 'aprobată' : 'respinsă'}.`,\n    data: {\n      approvalId: approval.id,\n      approvalType: approval.approvalType,\n      status: finalStatus,\n      modifiedValue\n    },\n    channels: ['push', 'email'],\n    priority: 'medium' as const\n  };\n  \n  // Notify AI/system or user who requested\n  if (approval.requestedByUserId) {\n    await db.insert(notificationQueue).values({\n      userId: approval.requestedByUserId,\n      ...notificationData\n    });\n  }\n}\n\nexport const hitlProcessApprovalWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.HITL_PROCESS_APPROVAL,\n  processHITLApproval,\n  {\n    concurrency: 10,\n    limiter: {\n      max: 50,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-n",
  "restrictii_antihalucinatie": [
    "VALIDEAZĂ că approver este autorizat",
    "PREVINE duplicate votes de la același approver",
    "REJECTION overrides - orice reject = rejected",
    "EXECUTE action doar pe approved final",
    "RE-ENABLE AI după approval rezolvat"
  ],
  "validare_task": "1. Approver validation\n2. Duplicate vote prevention\n3. Quorum calculation corect\n4. Action execution pe approved\n5. AI resume pe completion",
  "outcome": "Worker hitl:process-approval funcțional pentru procesare decizii cu action execution"
}
```

## F3.15.3 HITL SLA Check Worker (#73)

```json
{
  "taskID": "F3.15.3.T001",
  "denumire_task": "Implementare worker hitl:sla-check pentru monitorizare și escalare SLA",
  "context_anterior": "Process Approval implementat. Acum implementăm monitorizarea SLA pentru escalare automată.",
  "descriere_task": "Ești un expert în SLA management. Task-ul tău este să creezi workerul pentru verificare și escalare SLA.\n\nCreează fișierul /packages/workers/src/etapa3/category-n/hitl-sla-check.worker.ts:\n\n```typescript\nimport { Job } from 'bullmq';\nimport { createEtapa3Worker, createEtapa3Queue, ETAPA3_QUEUES } from '../../config/etapa3-queues';\nimport { db } from '@cerniq/db';\nimport { \n  hitlApprovals, \n  users,\n  notificationQueue,\n  slaEscalations \n} from '@cerniq/db/schema';\nimport { eq, and, lt, sql } from 'drizzle-orm';\nimport { logger } from '@cerniq/logger';\nimport { z } from 'zod';\nimport { metrics } from '@cerniq/metrics';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventEmitter } from '@cerniq/events';\n\nconst SLACheckPayload = z.object({\n  tenantId: z.string().uuid(),\n  approvalId: z.string().uuid().optional(), // Specific approval or batch check\n  checkType: z.enum(['single', 'batch', 'expire']).default('single')\n});\n\ntype SLACheckJob = z.infer<typeof SLACheckPayload>;\n\ninterface SLACheckResult {\n  checked: number;\n  escalated: number;\n  expired: number;\n  escalations: Array<{\n    approvalId: string;\n    escalationLevel: number;\n    escalatedTo: string[];\n  }>;\n}\n\nasync function processSLACheck(job: Job<SLACheckJob>): Promise<SLACheckResult> {\n  const log = logger.child({ jobId: job.id });\n  \n  const { tenantId, approvalId, checkType } = job.data;\n  \n  log.info('Running SLA check', { checkType, approvalId });\n  \n  const result: SLACheckResult = {\n    checked: 0,\n    escalated: 0,\n    expired: 0,\n    escalations: []\n  };\n  \n  try {\n    let approvalsToCheck: any[] = [];\n    \n    if (checkType === 'single' && approvalId) {\n      // Check single approval\n      const approval = await db.query.hitlApprovals.findFirst({\n        where: and(\n          eq(hitlApprovals.id, approvalId),\n          eq(hitlApprovals.status, 'pending')\n        )\n      });\n      if (approval) approvalsToCheck = [approval];\n      \n    } else if (checkType === 'expire' && approvalId) {\n      // Check for expiry\n      const approval = await db.query.hitlApprovals.findFirst({\n        where: and(\n          eq(hitlApprovals.id, approvalId),\n          eq(hitlApprovals.status, 'pending')\n        )\n      });\n      \n      if (approval && approval.expiresAt && new Date(approval.expiresAt) <= new Date()) {\n        await handleExpiry(approval);\n        result.expired = 1;\n        return result;\n      }\n      \n    } else {\n      // Batch check all pending approvals\n      approvalsToCheck = await db.query.hitlApprovals.findMany({\n        where: and(\n          eq(hitlApprovals.tenantId, tenantId),\n          eq(hitlApprovals.status, 'pending')\n        )\n      });\n    }\n    \n    result.checked = approvalsToCheck.length;\n    \n    for (const approval of approvalsToCheck) {\n      const now = new Date();\n      const slaDeadline = new Date(approval.slaDeadline);\n      const createdAt = new Date(approval.createdAt);\n      \n      // Calculate time elapsed as percentage of SLA\n      const totalSlaMs = slaDeadline.getTime() - createdAt.getTime();\n      const elapsedMs = now.getTime() - createdAt.getTime();\n      const slaPercentage = (elapsedMs / totalSlaMs) * 100;\n      \n      // Determine escalation level\n      let escalationLevel = 0;\n      if (slaPercentage >= 100) {\n        escalationLevel = 3; // SLA breached\n      } else if (slaPercentage >= 90) {\n        escalationLevel = 2; // Critical\n      } else if (slaPercentage >= 80) {\n        escalationLevel = 1; // Warning\n      }\n      \n      // Check if already escalated to this level\n      const currentEscalationLevel = approval.escalationLevel || 0;\n      \n      if (escalationLevel > currentEscalationLevel) {\n        // Escalate\n        const escalatedTo = await performEscalation(approval, escalationLevel);\n        \n        // Update approval\n        await db.update(hitlApprovals)\n          .set({\n            escalationLevel,\n            lastEscalationAt: now,\n            updatedAt: now\n          })\n          .where(eq(hitlApprovals.id, approval.id));\n        \n        // Log escalation\n        await db.insert(slaEscalations).values({\n          id: uuidv4(),\n          approvalId: approval.id,\n          tenantId: approval.tenantId,\n          escalationLevel,\n          slaPercentage: Math.round(slaPercentage),\n          escalatedToUserIds: escalatedTo,\n          escalatedAt: now\n        });\n        \n        result.escalated++;\n        result.escalations.push({\n          approvalId: approval.id,\n          escalationLevel,\n          escalatedTo\n        });\n        \n        metrics.hitlEscalations.inc({ \n          level: escalationLevel.toString(),\n          type: approval.approvalType \n        });\n        \n        // Emit event\n        await EventEmitter.emit('hitl:sla:escalated', {\n          approvalId: approval.id,\n          escalationLevel,\n          slaPercentage: Math.round(slaPercentage)\n        });\n      }\n      \n      // Schedule next check\n      if (escalationLevel < 3) {\n        const nextCheckDelay = calculateNextCheckDelay(approval, escalationLevel);\n        const slaQueue = createEtapa3Queue(ETAPA3_QUEUES.HITL_SLA_CHECK);\n        await slaQueue.add('check', {\n          tenantId: approval.tenantId,\n          approvalId: approval.id,\n          checkType: 'single'\n        }, {\n          delay: nextCheckDelay,\n          jobId: `sla-check-${approval.id}-${escalationLevel + 1}` // Dedupe\n        });\n      }\n    }\n    \n    log.info('SLA check completed', {\n      checked: result.checked,\n      escalated: result.escalated\n    });\n    \n    return result;\n    \n  } catch (error) {\n    log.error('SLA check failed', { error });\n    throw error;\n  }\n}\n\nasync function performEscalation(approval: any, level: number): Promise<string[]> {\n  const escalatedTo: string[] = [];\n  \n  // Get escalation targets based on level\n  let targetUsers: any[] = [];\n  \n  if (level === 1) {\n    // Level 1: Reminder to original approvers\n    targetUsers = await db.query.users.findMany({\n      where: sql`id = ANY(${approval.assignedApproverIds})`\n    });\n    \n  } else if (level === 2) {\n    // Level 2: Add managers\n    targetUsers = await db.query.users.findMany({\n      where: and(\n        eq(users.tenantId, approval.tenantId),\n        sql`role IN ('sales_manager', 'finance_manager', 'admin')`\n      )\n    });\n    \n  } else if (level === 3) {\n    // Level 3: SLA breach - notify admins and auto-escalate\n    targetUsers = await db.query.users.findMany({\n      where: and(\n        eq(users.tenantId, approval.tenantId),\n        eq(users.role, 'admin')\n      )\n    });\n  }\n  \n  // Send notifications\n  for (const user of targetUsers) {\n    await db.insert(notificationQueue).values({\n      userId: user.id,\n      type: 'sla_escalation',\n      title: level === 3 \n        ? '⚠️ SLA ÎNCĂLCAT - Aprobare Urgentă'\n        : level === 2\n          ? '⏰ Aprobare Aproape de Deadline'\n          : 'Reminder: Aprobare În Așteptare',\n      body: `Cererea de ${approval.approvalType} așteaptă de ${getWaitingTime(approval.createdAt)}.`,\n      data: {\n        approvalId: approval.id,\n        approvalType: approval.approvalType,\n        escalationLevel: level,\n        slaDeadline: approval.slaDeadline\n      },\n      channels: level >= 2 ? ['push', 'sms', 'email'] : ['push', 'email'],\n      priority: level === 3 ? 'urgent' : level === 2 ? 'high' : 'medium'\n    });\n    \n    escalatedTo.push(user.id);\n  }\n  \n  return escalatedTo;\n}\n\nasync function handleExpiry(approval: any): Promise<void> {\n  // Mark as expired\n  await db.update(hitlApprovals)\n    .set({\n      status: 'expired',\n      resolvedAt: new Date(),\n      resolutionReason: 'Auto-expired after timeout'\n    })\n    .where(eq(hitlApprovals.id, approval.id));\n  \n  // Notify requester\n  if (approval.requestedByUserId) {\n    await db.insert(notificationQueue).values({\n      userId: approval.requestedByUserId,\n      type: 'approval_expired',\n      title: 'Cerere Expirată',\n      body: `Cererea de ${approval.approvalType} a expirat fără decizie.`,\n      data: { approvalId: approval.id },\n      channels: ['push', 'email'],\n      priority: 'medium'\n    });\n  }\n  \n  metrics.hitlExpired.inc({ type: approval.approvalType });\n}\n\nfunction calculateNextCheckDelay(approval: any, currentLevel: number): number {\n  const slaMs = approval.slaMinutes * 60 * 1000;\n  \n  // Check more frequently as deadline approaches\n  if (currentLevel === 0) {\n    return slaMs * 0.1; // Check at 90%\n  } else if (currentLevel === 1) {\n    return slaMs * 0.05; // Check at 95%\n  } else {\n    return 60 * 1000; // Check every minute when critical\n  }\n}\n\nfunction getWaitingTime(createdAt: Date): string {\n  const ms = Date.now() - new Date(createdAt).getTime();\n  const minutes = Math.floor(ms / 60000);\n  const hours = Math.floor(minutes / 60);\n  \n  if (hours > 0) {\n    return `${hours}h ${minutes % 60}m`;\n  }\n  return `${minutes}m`;\n}\n\nexport const hitlSlaCheckWorker = createEtapa3Worker(\n  ETAPA3_QUEUES.HITL_SLA_CHECK,\n  processSLACheck,\n  {\n    concurrency: 5,\n    limiter: {\n      max: 20,\n      duration: 1000\n    }\n  }\n);\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/etapa3/category-n",
  "restrictii_antihalucinatie": [
    "CALCULATE SLA percentage corect",
    "ESCALATE progresiv - nu sari nivele",
    "SCHEDULE next check cu delay calculat",
    "HANDLE expiry separat de escalare",
    "LOG toate escalările pentru audit"
  ],
  "validare_task": "1. SLA percentage calculation\n2. Multi-level escalation (1-3)\n3. Progressive notifications\n4. Next check scheduling\n5. Expiry handling",
  "outcome": "Worker hitl:sla-check funcțional pentru monitorizare SLA cu escalare progresivă"
}
```

---

# FAZA F3.16: FRONTEND UI/UX (CATEGORIA O)

## F3.16.1 AI Agent Dashboard Page (#74)

```json
{
  "taskID": "F3.16.1.T001",
  "denumire_task": "Implementare pagină AI Agent Dashboard pentru monitorizare conversații active",
  "context_anterior": "HITL Workers finalizați. Acum implementăm interfața frontend pentru monitorizare și control AI Agent.",
  "descriere_task": "Ești un expert în React și dashboard design. Task-ul tău este să creezi dashboard-ul principal pentru AI Agent.\n\nCreează fișierul /apps/web/src/pages/ai-agent/dashboard.tsx:\n\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { useQuery, useMutation } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Switch } from '@/components/ui/switch';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { \n  MessageSquare, \n  Users, \n  TrendingUp, \n  AlertTriangle,\n  CheckCircle,\n  Clock,\n  Zap,\n  Brain,\n  Phone,\n  Mail,\n  MessageCircle\n} from 'lucide-react';\nimport { useSocket } from '@/hooks/useSocket';\nimport { apiClient } from '@/lib/api-client';\nimport { ConversationsList } from '@/components/ai-agent/ConversationsList';\nimport { MetricsPanel } from '@/components/ai-agent/MetricsPanel';\nimport { AlertsPanel } from '@/components/ai-agent/AlertsPanel';\nimport { PerformanceChart } from '@/components/ai-agent/PerformanceChart';\n\nexport default function AIAgentDashboard() {\n  const [selectedTab, setSelectedTab] = useState('active');\n  const [aiGlobalEnabled, setAiGlobalEnabled] = useState(true);\n  \n  // Real-time socket connection\n  const socket = useSocket('ai-agent');\n  \n  // Fetch dashboard metrics\n  const { data: metrics, isLoading: metricsLoading } = useQuery({\n    queryKey: ['ai-agent-metrics'],\n    queryFn: () => apiClient.get('/api/v1/ai-agent/metrics'),\n    refetchInterval: 30000 // 30 seconds\n  });\n  \n  // Fetch active conversations\n  const { data: conversations, isLoading: conversationsLoading } = useQuery({\n    queryKey: ['ai-agent-conversations', selectedTab],\n    queryFn: () => apiClient.get('/api/v1/ai-agent/conversations', {\n      params: { status: selectedTab }\n    }),\n    refetchInterval: 10000\n  });\n  \n  // Fetch pending approvals\n  const { data: approvals } = useQuery({\n    queryKey: ['pending-approvals'],\n    queryFn: () => apiClient.get('/api/v1/hitl/approvals', {\n      params: { status: 'pending' }\n    })\n  });\n  \n  // Toggle AI global status\n  const toggleAIMutation = useMutation({\n    mutationFn: (enabled: boolean) => \n      apiClient.post('/api/v1/ai-agent/toggle', { enabled }),\n    onSuccess: (_, enabled) => setAiGlobalEnabled(enabled)\n  });\n  \n  // Listen for real-time updates\n  useEffect(() => {\n    if (!socket) return;\n    \n    socket.on('conversation:new', (data) => {\n      // Refresh conversations list\n    });\n    \n    socket.on('conversation:updated', (data) => {\n      // Update specific conversation\n    });\n    \n    socket.on('approval:pending', (data) => {\n      // Show approval notification\n    });\n    \n    return () => {\n      socket.off('conversation:new');\n      socket.off('conversation:updated');\n      socket.off('approval:pending');\n    };\n  }, [socket]);\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">AI Sales Agent</h1>\n          <p className=\"text-muted-foreground\">\n            Monitorizare conversații și performanță AI\n          </p>\n        </div>\n        \n        <div className=\"flex items-center gap-4\">\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-sm\">AI Agent Global:</span>\n            <Switch\n              checked={aiGlobalEnabled}\n              onCheckedChange={(checked) => toggleAIMutation.mutate(checked)}\n            />\n            <Badge variant={aiGlobalEnabled ? 'default' : 'secondary'}>\n              {aiGlobalEnabled ? 'Activ' : 'Oprit'}\n            </Badge>\n          </div>\n        </div>\n      </div>\n      \n      {/* Quick Stats */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Conversații Active</p>\n                <p className=\"text-2xl font-bold\">\n                  {metrics?.activeConversations || 0}\n                </p>\n              </div>\n              <MessageSquare className=\"h-8 w-8 text-blue-500\" />\n            </div>\n            <div className=\"mt-2 flex items-center gap-2 text-sm\">\n              <Badge variant=\"outline\" className=\"gap-1\">\n                <Phone className=\"h-3 w-3\" />\n                {metrics?.byChannel?.whatsapp || 0}\n              </Badge>\n              <Badge variant=\"outline\" className=\"gap-1\">\n                <Mail className=\"h-3 w-3\" />\n                {metrics?.byChannel?.email || 0}\n              </Badge>\n              <Badge variant=\"outline\" className=\"gap-1\">\n                <MessageCircle className=\"h-3 w-3\" />\n                {metrics?.byChannel?.web || 0}\n              </Badge>\n            </div>\n          </CardContent>\n        </Card>\n        \n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Mesaje Azi</p>\n                <p className=\"text-2xl font-bold\">\n                  {metrics?.messagesToday || 0}\n                </p>\n              </div>\n              <Zap className=\"h-8 w-8 text-yellow-500\" />\n            </div>\n            <p className=\"mt-2 text-sm text-muted-foreground\">\n              Avg. răspuns: {metrics?.avgResponseTime || '-'}s\n            </p>\n          </CardContent>\n        </Card>\n        \n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Conversii</p>\n                <p className=\"text-2xl font-bold\">\n                  {metrics?.conversions || 0}\n                </p>\n              </div>\n              <TrendingUp className=\"h-8 w-8 text-green-500\" />\n            </div>\n            <p className=\"mt-2 text-sm text-muted-foreground\">\n              Rată: {metrics?.conversionRate || '-'}%\n            </p>\n          </CardContent>\n        </Card>\n        \n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Aprobări Pending</p>\n                <p className=\"text-2xl font-bold\">\n                  {approvals?.total || 0}\n                </p>\n              </div>\n              <Clock className=\"h-8 w-8 text-orange-500\" />\n            </div>\n            {approvals?.urgent > 0 && (\n              <Badge variant=\"destructive\" className=\"mt-2\">\n                {approvals.urgent} urgente\n              </Badge>\n            )}\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Main Content */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\n        {/* Conversations Panel */}\n        <div className=\"lg:col-span-2\">\n          <Card>\n            <CardHeader>\n              <div className=\"flex items-center justify-between\">\n                <CardTitle>Conversații</CardTitle>\n                <Tabs value={selectedTab} onValueChange={setSelectedTab}>\n                  <TabsList>\n                    <TabsTrigger value=\"active\">\n                      Active ({metrics?.activeConversations || 0})\n                    </TabsTrigger>\n                    <TabsTrigger value=\"pending\">\n                      Pending ({metrics?.pendingConversations || 0})\n                    </TabsTrigger>\n                    <TabsTrigger value=\"handover\">\n                      Handover ({metrics?.handoverCount || 0})\n                    </TabsTrigger>\n                  </TabsList>\n                </Tabs>\n              </div>\n            </CardHeader>\n            <CardContent>\n              <ConversationsList \n                conversations={conversations?.items || []}\n                isLoading={conversationsLoading}\n                onSelect={(id) => window.location.href = `/ai-agent/conversation/${id}`}\n              />\n            </CardContent>\n          </Card>\n        </div>\n        \n        {/* Side Panels */}\n        <div className=\"space-y-6\">\n          {/* Alerts */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <AlertTriangle className=\"h-5 w-5 text-orange-500\" />\n                Alerte\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <AlertsPanel alerts={metrics?.alerts || []} />\n            </CardContent>\n          </Card>\n          \n          {/* Guardrail Stats */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <Brain className=\"h-5 w-5 text-purple-500\" />\n                Guardrails\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-3\">\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-sm\">Preț</span>\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-sm font-medium\">\n                      {metrics?.guardrails?.price?.passed || 0} / {metrics?.guardrails?.price?.total || 0}\n                    </span>\n                    <CheckCircle className=\"h-4 w-4 text-green-500\" />\n                  </div>\n                </div>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-sm\">Stoc</span>\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-sm font-medium\">\n                      {metrics?.guardrails?.stock?.passed || 0} / {metrics?.guardrails?.stock?.total || 0}\n                    </span>\n                    <CheckCircle className=\"h-4 w-4 text-green-500\" />\n                  </div>\n                </div>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-sm\">SKU</span>\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-sm font-medium\">\n                      {metrics?.guardrails?.sku?.passed || 0} / {metrics?.guardrails?.sku?.total || 0}\n                    </span>\n                    <CheckCircle className=\"h-4 w-4 text-green-500\" />\n                  </div>\n                </div>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-sm\">Regenerări</span>\n                  <Badge variant=\"outline\">\n                    {metrics?.guardrails?.regenerations || 0}\n                  </Badge>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      </div>\n      \n      {/* Performance Chart */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Performanță Ultimele 7 Zile</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <PerformanceChart data={metrics?.performanceHistory || []} />\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/ai-agent",
  "restrictii_antihalucinatie": [
    "FOLOSEȘTE React Query pentru data fetching",
    "INCLUDE real-time updates via WebSocket",
    "DISPLAY guardrail stats pentru monitorizare",
    "LINK către conversation details",
    "TOGGLE AI global cu confirmare"
  ],
  "validare_task": "1. Quick stats cards funcționale\n2. Conversations list cu tabs\n3. Real-time WebSocket updates\n4. Guardrails monitoring panel\n5. Performance chart",
  "outcome": "Pagină AI Agent Dashboard funcțională pentru monitorizare completă"
}
```

## F3.16.2 Negotiation Detail Page (#75)

```json
{
  "taskID": "F3.16.2.T001",
  "denumire_task": "Implementare pagină Negotiation Detail cu conversație AI și HITL controls",
  "context_anterior": "AI Dashboard implementat. Acum implementăm pagina de detalii negociere cu chat și control HITL.",
  "descriere_task": "Ești un expert în React și chat interfaces. Task-ul tău este să creezi pagina de detalii negociere.\n\nCreează fișierul /apps/web/src/pages/negotiations/[id].tsx:\n\n```tsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useParams } from 'next/navigation';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Switch } from '@/components/ui/switch';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Separator } from '@/components/ui/separator';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport {\n  Sheet,\n  SheetContent,\n  SheetHeader,\n  SheetTitle,\n  SheetTrigger,\n} from '@/components/ui/sheet';\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/components/ui/alert-dialog';\nimport { \n  Send, \n  User, \n  Bot,\n  AlertTriangle,\n  CheckCircle,\n  Clock,\n  Phone,\n  Mail,\n  FileText,\n  Settings,\n  UserPlus,\n  Pause,\n  Play,\n  RefreshCw\n} from 'lucide-react';\nimport { useSocket } from '@/hooks/useSocket';\nimport { apiClient } from '@/lib/api-client';\nimport { formatDistanceToNow } from 'date-fns';\nimport { ro } from 'date-fns/locale';\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  channelType?: string;\n  detectedIntent?: string;\n  sentimentLabel?: string;\n  guardrailPassed?: boolean;\n  regenerationCount?: number;\n  createdAt: string;\n}\n\nexport default function NegotiationDetailPage() {\n  const params = useParams();\n  const negotiationId = params.id as string;\n  const queryClient = useQueryClient();\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  const [newMessage, setNewMessage] = useState('');\n  const [showHandoverDialog, setShowHandoverDialog] = useState(false);\n  const [handoverReason, setHandoverReason] = useState('');\n  \n  const socket = useSocket('negotiation');\n  \n  // Fetch negotiation details\n  const { data: negotiation, isLoading } = useQuery({\n    queryKey: ['negotiation', negotiationId],\n    queryFn: () => apiClient.get(`/api/v1/negotiations/${negotiationId}`)\n  });\n  \n  // Fetch messages\n  const { data: messages } = useQuery({\n    queryKey: ['negotiation-messages', negotiationId],\n    queryFn: () => apiClient.get(`/api/v1/negotiations/${negotiationId}/messages`),\n    refetchInterval: 5000\n  });\n  \n  // Toggle AI\n  const toggleAIMutation = useMutation({\n    mutationFn: (enabled: boolean) => \n      apiClient.patch(`/api/v1/negotiations/${negotiationId}`, { aiEnabled: enabled }),\n    onSuccess: () => queryClient.invalidateQueries(['negotiation', negotiationId])\n  });\n  \n  // Send human message\n  const sendMessageMutation = useMutation({\n    mutationFn: (content: string) => \n      apiClient.post(`/api/v1/negotiations/${negotiationId}/messages`, {\n        content,\n        role: 'assistant',\n        isHumanOverride: true\n      }),\n    onSuccess: () => {\n      setNewMessage('');\n      queryClient.invalidateQueries(['negotiation-messages', negotiationId]);\n    }\n  });\n  \n  // Request handover\n  const handoverMutation = useMutation({\n    mutationFn: () => \n      apiClient.post(`/api/v1/negotiations/${negotiationId}/handover`, {\n        reason: 'user_request',\n        reasonDetails: handoverReason\n      }),\n    onSuccess: () => {\n      setShowHandoverDialog(false);\n      queryClient.invalidateQueries(['negotiation', negotiationId]);\n    }\n  });\n  \n  // Regenerate last AI response\n  const regenerateMutation = useMutation({\n    mutationFn: () => \n      apiClient.post(`/api/v1/negotiations/${negotiationId}/regenerate`)\n  });\n  \n  // Socket real-time updates\n  useEffect(() => {\n    if (!socket || !negotiationId) return;\n    \n    socket.emit('join', negotiationId);\n    \n    socket.on('message:new', (msg: Message) => {\n      queryClient.invalidateQueries(['negotiation-messages', negotiationId]);\n    });\n    \n    socket.on('negotiation:updated', () => {\n      queryClient.invalidateQueries(['negotiation', negotiationId]);\n    });\n    \n    return () => {\n      socket.emit('leave', negotiationId);\n      socket.off('message:new');\n      socket.off('negotiation:updated');\n    };\n  }, [socket, negotiationId]);\n  \n  // Auto-scroll to bottom\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n  \n  if (isLoading) {\n    return <div className=\"p-6\">Se încarcă...</div>;\n  }\n  \n  return (\n    <div className=\"h-screen flex\">\n      {/* Main Chat Area */}\n      <div className=\"flex-1 flex flex-col\">\n        {/* Header */}\n        <div className=\"border-b p-4 flex items-center justify-between\">\n          <div className=\"flex items-center gap-4\">\n            <div>\n              <h1 className=\"text-lg font-semibold\">\n                {negotiation?.contact?.companyName || negotiation?.contact?.name}\n              </h1>\n              <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                <Badge variant={getStateVariant(negotiation?.currentState)}>\n                  {negotiation?.currentState}\n                </Badge>\n                {negotiation?.contact?.cui && (\n                  <span>CUI: {negotiation.contact.cui}</span>\n                )}\n              </div>\n            </div>\n          </div>\n          \n          <div className=\"flex items-center gap-3\">\n            <div className=\"flex items-center gap-2\">\n              <span className=\"text-sm\">AI Agent:</span>\n              <Switch\n                checked={negotiation?.aiEnabled}\n                onCheckedChange={(checked) => toggleAIMutation.mutate(checked)}\n              />\n              {negotiation?.aiEnabled ? (\n                <Badge variant=\"default\" className=\"gap-1\">\n                  <Bot className=\"h-3 w-3\" /> Activ\n                </Badge>\n              ) : (\n                <Badge variant=\"secondary\" className=\"gap-1\">\n                  <Pause className=\"h-3 w-3\" /> Oprit\n                </Badge>\n              )}\n            </div>\n            \n            <Button \n              variant=\"outline\" \n              size=\"sm\"\n              onClick={() => setShowHandoverDialog(true)}\n            >\n              <UserPlus className=\"h-4 w-4 mr-2\" />\n              Handover\n            </Button>\n            \n            <Sheet>\n              <SheetTrigger asChild>\n                <Button variant=\"ghost\" size=\"icon\">\n                  <Settings className=\"h-4 w-4\" />\n                </Button>\n              </SheetTrigger>\n              <SheetContent>\n                <SheetHeader>\n                  <SheetTitle>Setări Negociere</SheetTitle>\n                </SheetHeader>\n                {/* Settings content */}\n              </SheetContent>\n            </Sheet>\n          </div>\n        </div>\n        \n        {/* Messages */}\n        <ScrollArea className=\"flex-1 p-4\">\n          <div className=\"space-y-4\">\n            {messages?.items?.map((message: Message) => (\n              <div\n                key={message.id}\n                className={`flex gap-3 ${message.role === 'assistant' ? '' : 'flex-row-reverse'}`}\n              >\n                <div className={`w-8 h-8 rounded-full flex items-center justify-center ${\n                  message.role === 'assistant' \n                    ? 'bg-primary text-primary-foreground' \n                    : 'bg-muted'\n                }`}>\n                  {message.role === 'assistant' ? (\n                    <Bot className=\"h-4 w-4\" />\n                  ) : (\n                    <User className=\"h-4 w-4\" />\n                  )}\n                </div>\n                \n                <div className={`flex-1 max-w-[70%] ${\n                  message.role === 'assistant' ? '' : 'text-right'\n                }`}>\n                  <div className={`inline-block p-3 rounded-lg ${\n                    message.role === 'assistant' \n                      ? 'bg-muted' \n                      : 'bg-primary text-primary-foreground'\n                  }`}>\n                    <p className=\"whitespace-pre-wrap\">{message.content}</p>\n                  </div>\n                  \n                  <div className=\"flex items-center gap-2 mt-1 text-xs text-muted-foreground\">\n                    <span>\n                      {formatDistanceToNow(new Date(message.createdAt), {\n                        addSuffix: true,\n                        locale: ro\n                      })}\n                    </span>\n                    \n                    {message.role === 'assistant' && (\n                      <>\n                        {message.detectedIntent && (\n                          <Badge variant=\"outline\" className=\"text-xs\">\n                            {message.detectedIntent}\n                          </Badge>\n                        )}\n                        {message.guardrailPassed === false && (\n                          <Badge variant=\"destructive\" className=\"text-xs gap-1\">\n                            <AlertTriangle className=\"h-3 w-3\" />\n                            Guardrail\n                          </Badge>\n                        )}\n                        {message.regenerationCount > 0 && (\n                          <Badge variant=\"outline\" className=\"text-xs\">\n                            Regen: {message.regenerationCount}\n                          </Badge>\n                        )}\n                      </>\n                    )}\n                  </div>\n                </div>\n              </div>\n            ))}\n            <div ref={messagesEndRef} />\n          </div>\n        </ScrollArea>\n        \n        {/* Input Area */}\n        <div className=\"border-t p-4\">\n          {!negotiation?.aiEnabled && (\n            <div className=\"mb-3 p-2 bg-yellow-50 rounded-lg flex items-center gap-2 text-sm text-yellow-800\">\n              <AlertTriangle className=\"h-4 w-4\" />\n              AI Agent dezactivat. Răspundeți manual.\n            </div>\n          )}\n          \n          <div className=\"flex gap-2\">\n            <Input\n              placeholder=\"Scrie un mesaj... (Enter pentru trimitere)\"\n              value={newMessage}\n              onChange={(e) => setNewMessage(e.target.value)}\n              onKeyDown={(e) => {\n                if (e.key === 'Enter' && !e.shiftKey && newMessage.trim()) {\n                  e.preventDefault();\n                  sendMessageMutation.mutate(newMessage);\n                }\n              }}\n            />\n            <Button\n              onClick={() => sendMessageMutation.mutate(newMessage)}\n              disabled={!newMessage.trim() || sendMessageMutation.isPending}\n            >\n              <Send className=\"h-4 w-4\" />\n            </Button>\n            \n            {negotiation?.aiEnabled && (\n              <Button\n                variant=\"outline\"\n                onClick={() => regenerateMutation.mutate()}\n                disabled={regenerateMutation.isPending}\n              >\n                <RefreshCw className=\"h-4 w-4\" />\n              </Button>\n            )}\n          </div>\n        </div>\n      </div>\n      \n      {/* Sidebar - Contact & Negotiation Info */}\n      <div className=\"w-80 border-l p-4 space-y-4 overflow-y-auto\">\n        {/* Contact Card */}\n        <Card>\n          <CardHeader className=\"pb-2\">\n            <CardTitle className=\"text-sm\">Contact</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-2 text-sm\">\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">Companie</span>\n              <span className=\"font-medium\">{negotiation?.contact?.companyName}</span>\n            </div>\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">CUI</span>\n              <span>{negotiation?.contact?.cui}</span>\n            </div>\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">Contact</span>\n              <span>{negotiation?.contact?.name}</span>\n            </div>\n            <Separator />\n            <div className=\"flex gap-2\">\n              {negotiation?.contact?.phone && (\n                <Button variant=\"outline\" size=\"sm\" className=\"flex-1\">\n                  <Phone className=\"h-3 w-3 mr-1\" />\n                  Sună\n                </Button>\n              )}\n              {negotiation?.contact?.email && (\n                <Button variant=\"outline\" size=\"sm\" className=\"flex-1\">\n                  <Mail className=\"h-3 w-3 mr-1\" />\n                  Email\n                </Button>\n              )}\n            </div>\n          </CardContent>\n        </Card>\n        \n        {/* Negotiation Summary */}\n        <Card>\n          <CardHeader className=\"pb-2\">\n            <CardTitle className=\"text-sm\">Rezumat Negociere</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-2 text-sm\">\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">Valoare</span>\n              <span className=\"font-medium\">\n                {negotiation?.totalValue?.toLocaleString('ro-RO')} RON\n              </span>\n            </div>\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">Discount</span>\n              <span>{negotiation?.discountPercent || 0}%</span>\n            </div>\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">Produse</span>\n              <span>{negotiation?.products?.length || 0}</span>\n            </div>\n            <div className=\"flex justify-between\">\n              <span className=\"text-muted-foreground\">Mesaje AI</span>\n              <span>{negotiation?.aiMessageCount || 0}</span>\n            </div>\n          </CardContent>\n        </Card>\n        \n        {/* Products */}\n        {negotiation?.products?.length > 0 && (\n          <Card>\n            <CardHeader className=\"pb-2\">\n              <CardTitle className=\"text-sm\">Produse</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-2\">\n                {negotiation.products.slice(0, 5).map((p: any, i: number) => (\n                  <div key={i} className=\"text-sm flex justify-between\">\n                    <span className=\"truncate flex-1\">{p.name}</span>\n                    <span className=\"text-muted-foreground ml-2\">\n                      {p.quantity} x {p.unitPrice}\n                    </span>\n                  </div>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n        )}\n        \n        {/* Pending Approval */}\n        {negotiation?.pendingApprovalId && (\n          <Card className=\"border-orange-200 bg-orange-50\">\n            <CardHeader className=\"pb-2\">\n              <CardTitle className=\"text-sm flex items-center gap-2 text-orange-800\">\n                <Clock className=\"h-4 w-4\" />\n                Aprobare Pending\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <Button variant=\"outline\" size=\"sm\" className=\"w-full\">\n                Vezi Cererea\n              </Button>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n      \n      {/* Handover Dialog */}\n      <AlertDialog open={showHandoverDialog} onOpenChange={setShowHandoverDialog}>\n        <AlertDialogContent>\n          <AlertDialogHeader>\n            <AlertDialogTitle>Transfer către Agent Uman</AlertDialogTitle>\n            <AlertDialogDescription>\n              Conversația va fi transferată către un coleg. AI Agent va fi dezactivat.\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <Textarea\n            placeholder=\"Motiv handover (opțional)...\"\n            value={handoverReason}\n            onChange={(e) => setHandoverReason(e.target.value)}\n          />\n          <AlertDialogFooter>\n            <AlertDialogCancel>Anulează</AlertDialogCancel>\n            <AlertDialogAction onClick={() => handoverMutation.mutate()}>\n              Transferă\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n    </div>\n  );\n}\n\nfunction getStateVariant(state: string): 'default' | 'secondary' | 'destructive' | 'outline' {\n  const variants: Record<string, any> = {\n    'NEW': 'secondary',\n    'NEEDS_DISCOVERY': 'outline',\n    'PRODUCT_PRESENTATION': 'outline',\n    'PRICE_NEGOTIATION': 'default',\n    'PROPOSAL_SENT': 'default',\n    'VERBAL_AGREEMENT': 'default',\n    'WON': 'default',\n    'LOST': 'destructive',\n    'REQUIRES_HUMAN': 'destructive'\n  };\n  return variants[state] || 'secondary';\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/negotiations",
  "restrictii_antihalucinatie": [
    "DISPLAY guardrail status pe mesaje AI",
    "INCLUDE regeneration count pentru debugging",
    "TOGGLE AI cu confirmare vizuală",
    "SHOW pending approval alert când există",
    "SOCKET real-time pentru mesaje noi"
  ],
  "validare_task": "1. Chat interface funcțional\n2. AI toggle cu status clear\n3. Handover dialog\n4. Sidebar cu info contact/negociere\n5. Real-time updates",
  "outcome": "Pagină Negotiation Detail completă cu chat și HITL controls"
}
```

## F3.16.3 HITL Approval Queue Page (#76)

```json
{
  "taskID": "F3.16.3.T001",
  "denumire_task": "Implementare pagină HITL Approval Queue pentru procesare cereri aprobare",
  "context_anterior": "Negotiation Detail implementat. Acum implementăm pagina de aprobare HITL.",
  "descriere_task": "Ești un expert în React și approval workflows. Task-ul tău este să creezi pagina de queue aprobări.\n\nCreează fișierul /apps/web/src/pages/hitl/approvals.tsx:\n\n```tsx\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Input } from '@/components/ui/input';\nimport { DataTable } from '@/components/ui/data-table';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/components/ui/dialog';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { \n  CheckCircle, \n  XCircle, \n  Clock, \n  AlertTriangle,\n  MessageSquare,\n  ChevronRight\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport { formatDistanceToNow } from 'date-fns';\nimport { ro } from 'date-fns/locale';\nimport { ColumnDef } from '@tanstack/react-table';\n\ninterface Approval {\n  id: string;\n  approvalType: string;\n  entityType: string;\n  requestedValue: any;\n  currentValue: any;\n  reason: string;\n  priority: 'low' | 'medium' | 'high' | 'urgent';\n  status: 'pending' | 'approved' | 'rejected';\n  slaDeadline: string;\n  escalationLevel: number;\n  negotiation?: {\n    id: string;\n    contact: {\n      companyName: string;\n    };\n  };\n  createdAt: string;\n}\n\nexport default function HITLApprovalsPage() {\n  const queryClient = useQueryClient();\n  const [selectedTab, setSelectedTab] = useState('pending');\n  const [selectedApproval, setSelectedApproval] = useState<Approval | null>(null);\n  const [decision, setDecision] = useState<'approve' | 'reject' | null>(null);\n  const [comment, setComment] = useState('');\n  const [modifiedValue, setModifiedValue] = useState<string>('');\n  \n  // Fetch approvals\n  const { data: approvals, isLoading } = useQuery({\n    queryKey: ['hitl-approvals', selectedTab],\n    queryFn: () => apiClient.get('/api/v1/hitl/approvals', {\n      params: { status: selectedTab }\n    }),\n    refetchInterval: 10000\n  });\n  \n  // Process approval mutation\n  const processMutation = useMutation({\n    mutationFn: (data: {\n      approvalId: string;\n      decision: 'approve' | 'reject';\n      comment?: string;\n      modifiedValue?: any;\n    }) => apiClient.post(`/api/v1/hitl/approvals/${data.approvalId}/process`, data),\n    onSuccess: () => {\n      setSelectedApproval(null);\n      setDecision(null);\n      setComment('');\n      setModifiedValue('');\n      queryClient.invalidateQueries(['hitl-approvals']);\n    }\n  });\n  \n  const handleProcess = () => {\n    if (!selectedApproval || !decision) return;\n    \n    processMutation.mutate({\n      approvalId: selectedApproval.id,\n      decision,\n      comment: comment || undefined,\n      modifiedValue: modifiedValue ? JSON.parse(modifiedValue) : undefined\n    });\n  };\n  \n  const columns: ColumnDef<Approval>[] = [\n    {\n      accessorKey: 'priority',\n      header: 'Prioritate',\n      cell: ({ row }) => (\n        <Badge variant={getPriorityVariant(row.original.priority)}>\n          {row.original.priority}\n        </Badge>\n      )\n    },\n    {\n      accessorKey: 'approvalType',\n      header: 'Tip',\n      cell: ({ row }) => (\n        <span className=\"font-medium\">\n          {getApprovalTypeLabel(row.original.approvalType)}\n        </span>\n      )\n    },\n    {\n      accessorKey: 'requestedValue',\n      header: 'Valoare Cerută',\n      cell: ({ row }) => (\n        <span>\n          {formatValue(row.original.approvalType, row.original.requestedValue)}\n        </span>\n      )\n    },\n    {\n      accessorKey: 'negotiation',\n      header: 'Client',\n      cell: ({ row }) => (\n        <span className=\"text-sm\">\n          {row.original.negotiation?.contact?.companyName || '-'}\n        </span>\n      )\n    },\n    {\n      accessorKey: 'slaDeadline',\n      header: 'SLA',\n      cell: ({ row }) => {\n        const deadline = new Date(row.original.slaDeadline);\n        const isOverdue = deadline < new Date();\n        return (\n          <div className=\"flex items-center gap-2\">\n            {isOverdue ? (\n              <AlertTriangle className=\"h-4 w-4 text-red-500\" />\n            ) : (\n              <Clock className=\"h-4 w-4 text-muted-foreground\" />\n            )}\n            <span className={isOverdue ? 'text-red-500 font-medium' : ''}>\n              {formatDistanceToNow(deadline, { addSuffix: true, locale: ro })}\n            </span>\n          </div>\n        );\n      }\n    },\n    {\n      accessorKey: 'escalationLevel',\n      header: 'Escalare',\n      cell: ({ row }) => (\n        row.original.escalationLevel > 0 ? (\n          <Badge variant=\"destructive\">\n            Nivel {row.original.escalationLevel}\n          </Badge>\n        ) : null\n      )\n    },\n    {\n      id: 'actions',\n      cell: ({ row }) => (\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={() => setSelectedApproval(row.original)}\n        >\n          Procesează\n          <ChevronRight className=\"h-4 w-4 ml-1\" />\n        </Button>\n      )\n    }\n  ];\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">Coadă Aprobări</h1>\n          <p className=\"text-muted-foreground\">\n            Procesează cererile de aprobare Human-in-the-Loop\n          </p>\n        </div>\n        \n        <div className=\"flex items-center gap-2\">\n          <Badge variant=\"outline\" className=\"gap-1\">\n            <Clock className=\"h-3 w-3\" />\n            Pending: {approvals?.stats?.pending || 0}\n          </Badge>\n          <Badge variant=\"destructive\" className=\"gap-1\">\n            <AlertTriangle className=\"h-3 w-3\" />\n            Urgente: {approvals?.stats?.urgent || 0}\n          </Badge>\n        </div>\n      </div>\n      \n      <Tabs value={selectedTab} onValueChange={setSelectedTab}>\n        <TabsList>\n          <TabsTrigger value=\"pending\">\n            Pending ({approvals?.stats?.pending || 0})\n          </TabsTrigger>\n          <TabsTrigger value=\"approved\">\n            Aprobate\n          </TabsTrigger>\n          <TabsTrigger value=\"rejected\">\n            Respinse\n          </TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value={selectedTab} className=\"mt-4\">\n          <Card>\n            <CardContent className=\"pt-6\">\n              <DataTable\n                columns={columns}\n                data={approvals?.items || []}\n                isLoading={isLoading}\n              />\n            </CardContent>\n          </Card>\n        </TabsContent>\n      </Tabs>\n      \n      {/* Approval Detail Dialog */}\n      <Dialog \n        open={!!selectedApproval} \n        onOpenChange={(open) => !open && setSelectedApproval(null)}\n      >\n        <DialogContent className=\"max-w-2xl\">\n          <DialogHeader>\n            <DialogTitle>\n              {getApprovalTypeLabel(selectedApproval?.approvalType || '')}\n            </DialogTitle>\n          </DialogHeader>\n          \n          {selectedApproval && (\n            <div className=\"space-y-4\">\n              {/* Details */}\n              <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                <div>\n                  <span className=\"text-muted-foreground\">Client:</span>\n                  <p className=\"font-medium\">\n                    {selectedApproval.negotiation?.contact?.companyName}\n                  </p>\n                </div>\n                <div>\n                  <span className=\"text-muted-foreground\">Prioritate:</span>\n                  <Badge variant={getPriorityVariant(selectedApproval.priority)} className=\"ml-2\">\n                    {selectedApproval.priority}\n                  </Badge>\n                </div>\n                <div>\n                  <span className=\"text-muted-foreground\">Valoare Actuală:</span>\n                  <p className=\"font-medium\">\n                    {formatValue(selectedApproval.approvalType, selectedApproval.currentValue)}\n                  </p>\n                </div>\n                <div>\n                  <span className=\"text-muted-foreground\">Valoare Cerută:</span>\n                  <p className=\"font-medium text-primary\">\n                    {formatValue(selectedApproval.approvalType, selectedApproval.requestedValue)}\n                  </p>\n                </div>\n              </div>\n              \n              <div>\n                <span className=\"text-muted-foreground text-sm\">Motiv:</span>\n                <p className=\"p-3 bg-muted rounded-lg mt-1\">\n                  {selectedApproval.reason}\n                </p>\n              </div>\n              \n              {/* Decision Buttons */}\n              <div className=\"flex gap-2\">\n                <Button\n                  variant={decision === 'approve' ? 'default' : 'outline'}\n                  className=\"flex-1\"\n                  onClick={() => setDecision('approve')}\n                >\n                  <CheckCircle className=\"h-4 w-4 mr-2\" />\n                  Aprobă\n                </Button>\n                <Button\n                  variant={decision === 'reject' ? 'destructive' : 'outline'}\n                  className=\"flex-1\"\n                  onClick={() => setDecision('reject')}\n                >\n                  <XCircle className=\"h-4 w-4 mr-2\" />\n                  Respinge\n                </Button>\n              </div>\n              \n              {decision && (\n                <div className=\"space-y-3\">\n                  {decision === 'approve' && selectedApproval.approvalType === 'discount' && (\n                    <div>\n                      <label className=\"text-sm text-muted-foreground\">\n                        Modifică valoarea (opțional):\n                      </label>\n                      <Input\n                        type=\"number\"\n                        placeholder=\"Discount aprobat (%)\"\n                        value={modifiedValue}\n                        onChange={(e) => setModifiedValue(e.target.value)}\n                      />\n                    </div>\n                  )}\n                  \n                  <div>\n                    <label className=\"text-sm text-muted-foreground\">Comentariu:</label>\n                    <Textarea\n                      placeholder=\"Adaugă un comentariu...\"\n                      value={comment}\n                      onChange={(e) => setComment(e.target.value)}\n                    />\n                  </div>\n                </div>\n              )}\n            </div>\n          )}\n          \n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setSelectedApproval(null)}>\n              Anulează\n            </Button>\n            <Button\n              onClick={handleProcess}\n              disabled={!decision || processMutation.isPending}\n            >\n              Confirmă Decizia\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n\nfunction getPriorityVariant(priority: string): 'default' | 'secondary' | 'destructive' | 'outline' {\n  return {\n    urgent: 'destructive',\n    high: 'destructive',\n    medium: 'default',\n    low: 'secondary'\n  }[priority] as any || 'secondary';\n}\n\nfunction getApprovalTypeLabel(type: string): string {\n  return {\n    discount: 'Aprobare Discount',\n    price_override: 'Modificare Preț',\n    credit_extension: 'Extindere Credit',\n    content_review: 'Revizuire Conținut',\n    document_approval: 'Aprobare Document'\n  }[type] || type;\n}\n\nfunction formatValue(type: string, value: any): string {\n  if (value === null || value === undefined) return '-';\n  \n  if (type === 'discount') {\n    return `${value}%`;\n  }\n  return String(value);\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/hitl",
  "restrictii_antihalucinatie": [
    "DISPLAY SLA status cu urgency indication",
    "SHOW escalation level când > 0",
    "ALLOW modified value pentru partial approvals",
    "REQUIRE decision înainte de submit",
    "REFRESH automat la 10s"
  ],
  "validare_task": "1. Approval table cu toate coloanele\n2. Detail dialog funcțional\n3. Approve/Reject cu comentarii\n4. Modified value support\n5. SLA urgency indicators",
  "outcome": "Pagină HITL Approvals funcțională pentru procesare cereri"
}
```

    "IMPLEMENTEAZĂ toggle AI per conversație",
    "AFIȘEAZĂ metrics real-time cu refresh",
    "INCLUDE guardrails monitoring vizual"
  ],
  "validare_task": "1. Dashboard renders corect\n2. Real-time updates funcționale\n3. Quick stats afișate\n4. Conversations list funcțională\n5. Guardrails panel afișat",
  "outcome": "Pagină AI Agent Dashboard funcțională cu monitorizare real-time"
}

```

## F3.16.2 Negotiation Detail Page (#75)

```json
{
  "taskID": "F3.16.2.T001",
  "denumire_task": "Implementare pagină detaliu negociere cu chat interface și controls AI",
  "context_anterior": "Dashboard implementat. Acum implementăm pagina de detaliu pentru fiecare negociere.",
  "descriere_task": "Ești un expert în React și chat interfaces. Task-ul tău este să creezi pagina de detaliu negociere.\n\nCreează fișierul /apps/web/src/pages/ai-agent/negotiation/[id].tsx:\n\n```tsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useParams, useRouter } from 'next/navigation';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Switch } from '@/components/ui/switch';\nimport { Textarea } from '@/components/ui/textarea';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Avatar, AvatarFallback } from '@/components/ui/avatar';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { \n  Send, \n  Bot, \n  User, \n  RefreshCw, \n  Phone, \n  AlertCircle,\n  CheckCircle,\n  Clock,\n  FileText,\n  Package,\n  Euro,\n  HandHeart,\n  History,\n  ChevronRight\n} from 'lucide-react';\nimport { useSocket } from '@/hooks/useSocket';\nimport { apiClient } from '@/lib/api-client';\nimport { formatDistanceToNow } from 'date-fns';\nimport { ro } from 'date-fns/locale';\nimport { cn } from '@/lib/utils';\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  metadata?: {\n    toolCalls?: any[];\n    guardrailStatus?: 'passed' | 'warning' | 'failed';\n    regenerated?: boolean;\n  };\n  createdAt: string;\n}\n\ninterface NegotiationDetails {\n  id: string;\n  status: string;\n  currentState: string;\n  aiEnabled: boolean;\n  contact: {\n    id: string;\n    name: string;\n    company: string;\n    phone?: string;\n    email?: string;\n  };\n  products: Array<{\n    sku: string;\n    name: string;\n    quantity: number;\n    unitPrice: number;\n    discount: number;\n  }>;\n  totals: {\n    subtotal: number;\n    discount: number;\n    total: number;\n  };\n  messages: Message[];\n  pendingApprovals: any[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport default function NegotiationDetailPage() {\n  const params = useParams();\n  const router = useRouter();\n  const queryClient = useQueryClient();\n  const negotiationId = params.id as string;\n  \n  const [manualMessage, setManualMessage] = useState('');\n  const [handoverDialogOpen, setHandoverDialogOpen] = useState(false);\n  const [handoverReason, setHandoverReason] = useState('');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  const socket = useSocket('negotiation');\n  \n  // Fetch negotiation details\n  const { data: negotiation, isLoading } = useQuery<NegotiationDetails>({\n    queryKey: ['negotiation', negotiationId],\n    queryFn: () => apiClient.get(`/api/v1/negotiations/${negotiationId}`),\n    refetchInterval: 5000\n  });\n  \n  // Toggle AI mutation\n  const toggleAIMutation = useMutation({\n    mutationFn: (enabled: boolean) => \n      apiClient.patch(`/api/v1/negotiations/${negotiationId}/ai`, { enabled }),\n    onSuccess: () => queryClient.invalidateQueries(['negotiation', negotiationId])\n  });\n  \n  // Send manual message\n  const sendMessageMutation = useMutation({\n    mutationFn: (content: string) => \n      apiClient.post(`/api/v1/negotiations/${negotiationId}/messages`, { \n        content,\n        role: 'assistant',\n        manual: true \n      }),\n    onSuccess: () => {\n      setManualMessage('');\n      queryClient.invalidateQueries(['negotiation', negotiationId]);\n    }\n  });\n  \n  // Request handover\n  const handoverMutation = useMutation({\n    mutationFn: () => \n      apiClient.post(`/api/v1/negotiations/${negotiationId}/handover`, { \n        reason: handoverReason \n      }),\n    onSuccess: () => {\n      setHandoverDialogOpen(false);\n      setHandoverReason('');\n      queryClient.invalidateQueries(['negotiation', negotiationId]);\n    }\n  });\n  \n  // Regenerate last response\n  const regenerateMutation = useMutation({\n    mutationFn: () => \n      apiClient.post(`/api/v1/negotiations/${negotiationId}/regenerate`),\n    onSuccess: () => queryClient.invalidateQueries(['negotiation', negotiationId])\n  });\n  \n  // Real-time updates\n  useEffect(() => {\n    if (!socket || !negotiationId) return;\n    \n    socket.emit('join', { negotiationId });\n    \n    socket.on('message:new', (message) => {\n      queryClient.setQueryData(['negotiation', negotiationId], (old: any) => ({\n        ...old,\n        messages: [...(old?.messages || []), message]\n      }));\n    });\n    \n    socket.on('negotiation:updated', (data) => {\n      queryClient.invalidateQueries(['negotiation', negotiationId]);\n    });\n    \n    return () => {\n      socket.emit('leave', { negotiationId });\n      socket.off('message:new');\n      socket.off('negotiation:updated');\n    };\n  }, [socket, negotiationId]);\n  \n  // Auto-scroll to bottom\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [negotiation?.messages]);\n  \n  if (isLoading) {\n    return <div className=\"p-6\">Se încarcă...</div>;\n  }\n  \n  if (!negotiation) {\n    return <div className=\"p-6\">Negocierea nu a fost găsită</div>;\n  }\n  \n  const stateLabels: Record<string, string> = {\n    'initial_contact': 'Contact Inițial',\n    'needs_discovery': 'Descoperire Nevoi',\n    'product_presentation': 'Prezentare Produse',\n    'negotiation': 'Negociere',\n    'closing': 'Închidere',\n    'won': 'Câștigat',\n    'lost': 'Pierdut'\n  };\n  \n  return (\n    <div className=\"h-screen flex\">\n      {/* Main Chat Area */}\n      <div className=\"flex-1 flex flex-col\">\n        {/* Header */}\n        <div className=\"border-b p-4 flex items-center justify-between bg-background\">\n          <div className=\"flex items-center gap-4\">\n            <Button variant=\"ghost\" size=\"sm\" onClick={() => router.back()}>\n              ← Înapoi\n            </Button>\n            <div>\n              <h1 className=\"font-semibold\">{negotiation.contact.name}</h1>\n              <p className=\"text-sm text-muted-foreground\">\n                {negotiation.contact.company}\n              </p>\n            </div>\n            <Badge variant={negotiation.status === 'active' ? 'default' : 'secondary'}>\n              {stateLabels[negotiation.currentState] || negotiation.currentState}\n            </Badge>\n          </div>\n          \n          <div className=\"flex items-center gap-4\">\n            <div className=\"flex items-center gap-2\">\n              <Bot className=\"h-4 w-4\" />\n              <span className=\"text-sm\">AI:</span>\n              <Switch\n                checked={negotiation.aiEnabled}\n                onCheckedChange={(checked) => toggleAIMutation.mutate(checked)}\n              />\n              <Badge variant={negotiation.aiEnabled ? 'default' : 'outline'}>\n                {negotiation.aiEnabled ? 'Activ' : 'Manual'}\n              </Badge>\n            </div>\n            \n            <Button \n              variant=\"outline\" \n              size=\"sm\"\n              onClick={() => setHandoverDialogOpen(true)}\n            >\n              <HandHeart className=\"h-4 w-4 mr-2\" />\n              Handover\n            </Button>\n          </div>\n        </div>\n        \n        {/* Messages */}\n        <ScrollArea className=\"flex-1 p-4\">\n          <div className=\"space-y-4 max-w-3xl mx-auto\">\n            {negotiation.messages.map((message) => (\n              <div\n                key={message.id}\n                className={cn(\n                  \"flex gap-3\",\n                  message.role === 'assistant' && \"flex-row-reverse\"\n                )}\n              >\n                <Avatar className=\"h-8 w-8\">\n                  <AvatarFallback>\n                    {message.role === 'user' ? (\n                      <User className=\"h-4 w-4\" />\n                    ) : (\n                      <Bot className=\"h-4 w-4\" />\n                    )}\n                  </AvatarFallback>\n                </Avatar>\n                \n                <div className={cn(\n                  \"max-w-[70%] rounded-lg p-3\",\n                  message.role === 'user' \n                    ? \"bg-muted\" \n                    : \"bg-primary text-primary-foreground\"\n                )}>\n                  <p className=\"text-sm whitespace-pre-wrap\">{message.content}</p>\n                  \n                  <div className=\"mt-2 flex items-center gap-2 text-xs opacity-70\">\n                    <span>\n                      {formatDistanceToNow(new Date(message.createdAt), { \n                        addSuffix: true,\n                        locale: ro \n                      })}\n                    </span>\n                    \n                    {message.metadata?.guardrailStatus && (\n                      <Badge \n                        variant={message.metadata.guardrailStatus === 'passed' \n                          ? 'outline' \n                          : 'destructive'\n                        }\n                        className=\"h-4 text-[10px]\"\n                      >\n                        {message.metadata.guardrailStatus === 'passed' ? (\n                          <><CheckCircle className=\"h-2 w-2 mr-1\" /> Valid</>\n                        ) : (\n                          <><AlertCircle className=\"h-2 w-2 mr-1\" /> {message.metadata.guardrailStatus}</>\n                        )}\n                      </Badge>\n                    )}\n                    \n                    {message.metadata?.regenerated && (\n                      <Badge variant=\"outline\" className=\"h-4 text-[10px]\">\n                        <RefreshCw className=\"h-2 w-2 mr-1\" /> Regenerat\n                      </Badge>\n                    )}\n                  </div>\n                </div>\n              </div>\n            ))}\n            <div ref={messagesEndRef} />\n          </div>\n        </ScrollArea>\n        \n        {/* Input Area - Only when AI disabled */}\n        {!negotiation.aiEnabled && (\n          <div className=\"border-t p-4 bg-background\">\n            <div className=\"max-w-3xl mx-auto flex gap-2\">\n              <Textarea\n                value={manualMessage}\n                onChange={(e) => setManualMessage(e.target.value)}\n                placeholder=\"Scrie un mesaj manual...\"\n                className=\"min-h-[60px]\"\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault();\n                    if (manualMessage.trim()) {\n                      sendMessageMutation.mutate(manualMessage);\n                    }\n                  }\n                }}\n              />\n              <div className=\"flex flex-col gap-2\">\n                <Button\n                  onClick={() => manualMessage.trim() && sendMessageMutation.mutate(manualMessage)}\n                  disabled={!manualMessage.trim() || sendMessageMutation.isPending}\n                >\n                  <Send className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  onClick={() => regenerateMutation.mutate()}\n                  disabled={regenerateMutation.isPending}\n                  title=\"Regenerează ultimul răspuns AI\"\n                >\n                  <RefreshCw className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n      \n      {/* Right Sidebar */}\n      <div className=\"w-80 border-l bg-muted/30 overflow-y-auto\">\n        {/* Contact Info */}\n        <div className=\"p-4 border-b\">\n          <h3 className=\"font-semibold mb-3 flex items-center gap-2\">\n            <User className=\"h-4 w-4\" />\n            Contact\n          </h3>\n          <div className=\"space-y-2 text-sm\">\n            <p><strong>Nume:</strong> {negotiation.contact.name}</p>\n            <p><strong>Companie:</strong> {negotiation.contact.company}</p>\n            {negotiation.contact.phone && (\n              <p className=\"flex items-center gap-2\">\n                <Phone className=\"h-3 w-3\" />\n                {negotiation.contact.phone}\n              </p>\n            )}\n          </div>\n        </div>\n        \n        {/* Products */}\n        <div className=\"p-4 border-b\">\n          <h3 className=\"font-semibold mb-3 flex items-center gap-2\">\n            <Package className=\"h-4 w-4\" />\n            Produse ({negotiation.products.length})\n          </h3>\n          <div className=\"space-y-2\">\n            {negotiation.products.map((product, idx) => (\n              <div key={idx} className=\"text-sm bg-background rounded p-2\">\n                <p className=\"font-medium\">{product.name}</p>\n                <div className=\"flex justify-between text-muted-foreground\">\n                  <span>{product.quantity} x {product.unitPrice.toFixed(2)} RON</span>\n                  {product.discount > 0 && (\n                    <Badge variant=\"secondary\" className=\"text-xs\">\n                      -{product.discount}%\n                    </Badge>\n                  )}\n                </div>\n              </div>\n            ))}\n          </div>\n          \n          <div className=\"mt-3 pt-3 border-t space-y-1 text-sm\">\n            <div className=\"flex justify-between\">\n              <span>Subtotal:</span>\n              <span>{negotiation.totals.subtotal.toFixed(2)} RON</span>\n            </div>\n            {negotiation.totals.discount > 0 && (\n              <div className=\"flex justify-between text-green-600\">\n                <span>Discount:</span>\n                <span>-{negotiation.totals.discount.toFixed(2)} RON</span>\n              </div>\n            )}\n            <div className=\"flex justify-between font-bold\">\n              <span>Total:</span>\n              <span>{negotiation.totals.total.toFixed(2)} RON</span>\n            </div>\n          </div>\n        </div>\n        \n        {/* Pending Approvals */}\n        {negotiation.pendingApprovals.length > 0 && (\n          <div className=\"p-4 border-b\">\n            <h3 className=\"font-semibold mb-3 flex items-center gap-2\">\n              <Clock className=\"h-4 w-4 text-orange-500\" />\n              Aprobări Pending ({negotiation.pendingApprovals.length})\n            </h3>\n            <div className=\"space-y-2\">\n              {negotiation.pendingApprovals.map((approval: any) => (\n                <div \n                  key={approval.id} \n                  className=\"text-sm bg-orange-50 dark:bg-orange-900/20 rounded p-2\"\n                >\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"font-medium\">{approval.approvalType}</span>\n                    <Badge variant=\"outline\" className=\"text-xs\">\n                      {approval.priority}\n                    </Badge>\n                  </div>\n                  <p className=\"text-muted-foreground mt-1\">\n                    {approval.description}\n                  </p>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n        \n        {/* Timeline/History */}\n        <div className=\"p-4\">\n          <h3 className=\"font-semibold mb-3 flex items-center gap-2\">\n            <History className=\"h-4 w-4\" />\n            Istoric\n          </h3>\n          <div className=\"space-y-2 text-sm\">\n            <div className=\"flex items-center gap-2 text-muted-foreground\">\n              <Clock className=\"h-3 w-3\" />\n              <span>Creat: {new Date(negotiation.createdAt).toLocaleDateString('ro-RO')}</span>\n            </div>\n            <div className=\"flex items-center gap-2 text-muted-foreground\">\n              <RefreshCw className=\"h-3 w-3\" />\n              <span>Actualizat: {formatDistanceToNow(new Date(negotiation.updatedAt), { addSuffix: true, locale: ro })}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      {/* Handover Dialog */}\n      <Dialog open={handoverDialogOpen} onOpenChange={setHandoverDialogOpen}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Solicită Handover la Agent Uman</DialogTitle>\n          </DialogHeader>\n          <div className=\"space-y-4\">\n            <div>\n              <label className=\"text-sm font-medium\">Motivul handover-ului</label>\n              <Select value={handoverReason} onValueChange={setHandoverReason}>\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Selectează motivul\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"complex_negotiation\">Negociere Complexă</SelectItem>\n                  <SelectItem value=\"customer_request\">La Cererea Clientului</SelectItem>\n                  <SelectItem value=\"technical_issue\">Problemă Tehnică</SelectItem>\n                  <SelectItem value=\"escalation\">Escalare</SelectItem>\n                  <SelectItem value=\"other\">Altul</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setHandoverDialogOpen(false)}>\n              Anulează\n            </Button>\n            <Button \n              onClick={() => handoverMutation.mutate()}\n              disabled={!handoverReason || handoverMutation.isPending}\n            >\n              Solicită Handover\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/ai-agent",
  "restrictii_antihalucinatie": [
    "AFIȘEAZĂ messages în ordine cronologică",
    "INCLUDE guardrail status per mesaj",
    "PERMITE toggle AI on/off",
    "AFIȘEAZĂ pending approvals sidebar",
    "IMPLEMENT handover dialog corect"
  ],
  "validare_task": "1. Chat interface funcțională\n2. AI toggle funcționează\n3. Manual messages când AI off\n4. Sidebar cu toate informațiile\n5. Handover dialog funcțional",
  "outcome": "Pagină Negotiation Detail funcțională cu chat interface și controls AI"
}
```

## F3.16.3 HITL Approval Queue Page (#76)

```json
{
  "taskID": "F3.16.3.T001",
  "denumire_task": "Implementare pagină HITL Approval Queue pentru gestionare aprobări",
  "context_anterior": "Negotiation Detail implementat. Acum implementăm pagina pentru coadă de aprobări HITL.",
  "descriere_task": "Ești un expert în React și approval workflows. Task-ul tău este să creezi pagina pentru coadă de aprobări HITL.\n\nCreează fișierul /apps/web/src/pages/approvals/index.tsx:\n\n```tsx\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from '@/components/ui/dialog';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { DataTable } from '@/components/ui/data-table';\nimport { ColumnDef } from '@tanstack/react-table';\nimport { \n  CheckCircle, \n  XCircle, \n  Clock, \n  AlertTriangle,\n  Filter,\n  Search,\n  Eye,\n  Percent,\n  Package,\n  Euro,\n  User,\n  Calendar,\n  ArrowUpRight,\n  Bell\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport { formatDistanceToNow, differenceInMinutes } from 'date-fns';\nimport { ro } from 'date-fns/locale';\nimport { cn } from '@/lib/utils';\nimport { useToast } from '@/components/ui/use-toast';\n\ninterface Approval {\n  id: string;\n  approvalType: 'discount' | 'price_override' | 'custom_terms' | 'special_conditions' | 'credit_extension' | 'manual_override';\n  priority: 'low' | 'medium' | 'high' | 'urgent';\n  status: 'pending' | 'approved' | 'rejected' | 'expired';\n  description: string;\n  requestedValue: any;\n  contextData: {\n    negotiationId?: string;\n    contactName?: string;\n    companyName?: string;\n    productName?: string;\n    currentPrice?: number;\n    requestedPrice?: number;\n    discountPercent?: number;\n  };\n  slaDeadline: string;\n  escalationLevel: number;\n  requestedByUser?: {\n    id: string;\n    name: string;\n  };\n  createdAt: string;\n}\n\nexport default function ApprovalsPage() {\n  const queryClient = useQueryClient();\n  const { toast } = useToast();\n  \n  const [selectedTab, setSelectedTab] = useState('pending');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [typeFilter, setTypeFilter] = useState<string>('all');\n  const [priorityFilter, setPriorityFilter] = useState<string>('all');\n  const [selectedApproval, setSelectedApproval] = useState<Approval | null>(null);\n  const [approvalComment, setApprovalComment] = useState('');\n  const [modifiedValue, setModifiedValue] = useState('');\n  \n  // Fetch approvals\n  const { data: approvals, isLoading } = useQuery({\n    queryKey: ['approvals', selectedTab, typeFilter, priorityFilter],\n    queryFn: () => apiClient.get('/api/v1/hitl/approvals', {\n      params: { \n        status: selectedTab,\n        type: typeFilter !== 'all' ? typeFilter : undefined,\n        priority: priorityFilter !== 'all' ? priorityFilter : undefined\n      }\n    })\n  });\n  \n  // Approve mutation\n  const approveMutation = useMutation({\n    mutationFn: ({ id, comment, modifiedValue }: { id: string; comment: string; modifiedValue?: any }) =>\n      apiClient.post(`/api/v1/hitl/approvals/${id}/approve`, { comment, modifiedValue }),\n    onSuccess: () => {\n      toast({ title: 'Aprobat', description: 'Cererea a fost aprobată cu succes.' });\n      setSelectedApproval(null);\n      setApprovalComment('');\n      setModifiedValue('');\n      queryClient.invalidateQueries(['approvals']);\n    }\n  });\n  \n  // Reject mutation\n  const rejectMutation = useMutation({\n    mutationFn: ({ id, comment }: { id: string; comment: string }) =>\n      apiClient.post(`/api/v1/hitl/approvals/${id}/reject`, { comment }),\n    onSuccess: () => {\n      toast({ title: 'Respins', description: 'Cererea a fost respinsă.' });\n      setSelectedApproval(null);\n      setApprovalComment('');\n      queryClient.invalidateQueries(['approvals']);\n    }\n  });\n  \n  const getSlaUrgency = (deadline: string): { label: string; variant: 'default' | 'secondary' | 'destructive' | 'outline' } => {\n    const minutes = differenceInMinutes(new Date(deadline), new Date());\n    if (minutes <= 0) return { label: 'EXPIRAT', variant: 'destructive' };\n    if (minutes <= 15) return { label: `${minutes}m`, variant: 'destructive' };\n    if (minutes <= 60) return { label: `${minutes}m`, variant: 'secondary' };\n    const hours = Math.floor(minutes / 60);\n    return { label: `${hours}h`, variant: 'outline' };\n  };\n  \n  const getTypeIcon = (type: string) => {\n    switch (type) {\n      case 'discount': return <Percent className=\"h-4 w-4\" />;\n      case 'price_override': return <Euro className=\"h-4 w-4\" />;\n      case 'custom_terms': return <Package className=\"h-4 w-4\" />;\n      default: return <AlertTriangle className=\"h-4 w-4\" />;\n    }\n  };\n  \n  const typeLabels: Record<string, string> = {\n    'discount': 'Discount',\n    'price_override': 'Suprascriere Preț',\n    'custom_terms': 'Termeni Custom',\n    'special_conditions': 'Condiții Speciale',\n    'credit_extension': 'Extensie Credit',\n    'manual_override': 'Override Manual'\n  };\n  \n  const priorityLabels: Record<string, { label: string; variant: 'default' | 'secondary' | 'destructive' | 'outline' }> = {\n    'urgent': { label: 'Urgent', variant: 'destructive' },\n    'high': { label: 'Înalt', variant: 'secondary' },\n    'medium': { label: 'Mediu', variant: 'outline' },\n    'low': { label: 'Scăzut', variant: 'default' }\n  };\n  \n  const columns: ColumnDef<Approval>[] = [\n    {\n      accessorKey: 'approvalType',\n      header: 'Tip',\n      cell: ({ row }) => (\n        <div className=\"flex items-center gap-2\">\n          {getTypeIcon(row.original.approvalType)}\n          <span>{typeLabels[row.original.approvalType]}</span>\n        </div>\n      )\n    },\n    {\n      accessorKey: 'description',\n      header: 'Descriere',\n      cell: ({ row }) => (\n        <div className=\"max-w-[300px]\">\n          <p className=\"truncate\">{row.original.description}</p>\n          {row.original.contextData.contactName && (\n            <p className=\"text-xs text-muted-foreground\">\n              {row.original.contextData.contactName} - {row.original.contextData.companyName}\n            </p>\n          )}\n        </div>\n      )\n    },\n    {\n      accessorKey: 'priority',\n      header: 'Prioritate',\n      cell: ({ row }) => {\n        const p = priorityLabels[row.original.priority];\n        return <Badge variant={p.variant}>{p.label}</Badge>;\n      }\n    },\n    {\n      accessorKey: 'slaDeadline',\n      header: 'SLA',\n      cell: ({ row }) => {\n        const sla = getSlaUrgency(row.original.slaDeadline);\n        return (\n          <div className=\"flex items-center gap-2\">\n            <Clock className={cn(\n              \"h-4 w-4\",\n              sla.variant === 'destructive' && \"text-red-500 animate-pulse\"\n            )} />\n            <Badge variant={sla.variant}>{sla.label}</Badge>\n          </div>\n        );\n      }\n    },\n    {\n      accessorKey: 'escalationLevel',\n      header: 'Escalare',\n      cell: ({ row }) => {\n        const level = row.original.escalationLevel;\n        if (level === 0) return <span className=\"text-muted-foreground\">-</span>;\n        return (\n          <Badge variant={level >= 2 ? 'destructive' : 'secondary'}>\n            Nivel {level}\n          </Badge>\n        );\n      }\n    },\n    {\n      accessorKey: 'createdAt',\n      header: 'Creat',\n      cell: ({ row }) => (\n        <span className=\"text-sm text-muted-foreground\">\n          {formatDistanceToNow(new Date(row.original.createdAt), { addSuffix: true, locale: ro })}\n        </span>\n      )\n    },\n    {\n      id: 'actions',\n      header: 'Acțiuni',\n      cell: ({ row }) => (\n        <div className=\"flex items-center gap-2\">\n          <Button \n            variant=\"ghost\" \n            size=\"sm\"\n            onClick={() => setSelectedApproval(row.original)}\n          >\n            <Eye className=\"h-4 w-4\" />\n          </Button>\n          {row.original.status === 'pending' && (\n            <>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"text-green-600 hover:text-green-700\"\n                onClick={() => {\n                  setSelectedApproval(row.original);\n                }}\n              >\n                <CheckCircle className=\"h-4 w-4\" />\n              </Button>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"text-red-600 hover:text-red-700\"\n                onClick={() => {\n                  setSelectedApproval(row.original);\n                }}\n              >\n                <XCircle className=\"h-4 w-4\" />\n              </Button>\n            </>\n          )}\n        </div>\n      )\n    }\n  ];\n  \n  const filteredApprovals = approvals?.items?.filter((a: Approval) => {\n    if (!searchQuery) return true;\n    const q = searchQuery.toLowerCase();\n    return (\n      a.description.toLowerCase().includes(q) ||\n      a.contextData.contactName?.toLowerCase().includes(q) ||\n      a.contextData.companyName?.toLowerCase().includes(q)\n    );\n  }) || [];\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">Aprobări HITL</h1>\n          <p className=\"text-muted-foreground\">\n            Gestionare cereri de aprobare pentru acțiuni AI\n          </p>\n        </div>\n        \n        <div className=\"flex items-center gap-2\">\n          {approvals?.urgent > 0 && (\n            <Badge variant=\"destructive\" className=\"animate-pulse\">\n              <Bell className=\"h-3 w-3 mr-1\" />\n              {approvals.urgent} urgente\n            </Badge>\n          )}\n        </div>\n      </div>\n      \n      {/* Filters */}\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"flex items-center gap-4\">\n            <div className=\"relative flex-1 max-w-sm\">\n              <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n              <Input\n                placeholder=\"Caută după descriere, contact, companie...\"\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                className=\"pl-10\"\n              />\n            </div>\n            \n            <Select value={typeFilter} onValueChange={setTypeFilter}>\n              <SelectTrigger className=\"w-[180px]\">\n                <SelectValue placeholder=\"Tip aprobare\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"all\">Toate tipurile</SelectItem>\n                <SelectItem value=\"discount\">Discount</SelectItem>\n                <SelectItem value=\"price_override\">Suprascriere Preț</SelectItem>\n                <SelectItem value=\"custom_terms\">Termeni Custom</SelectItem>\n                <SelectItem value=\"special_conditions\">Condiții Speciale</SelectItem>\n              </SelectContent>\n            </Select>\n            \n            <Select value={priorityFilter} onValueChange={setPriorityFilter}>\n              <SelectTrigger className=\"w-[150px]\">\n                <SelectValue placeholder=\"Prioritate\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"all\">Toate</SelectItem>\n                <SelectItem value=\"urgent\">Urgent</SelectItem>\n                <SelectItem value=\"high\">Înalt</SelectItem>\n                <SelectItem value=\"medium\">Mediu</SelectItem>\n                <SelectItem value=\"low\">Scăzut</SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n        </CardContent>\n      </Card>\n      \n      {/* Tabs & Table */}\n      <Tabs value={selectedTab} onValueChange={setSelectedTab}>\n        <TabsList>\n          <TabsTrigger value=\"pending\">\n            În Așteptare ({approvals?.counts?.pending || 0})\n          </TabsTrigger>\n          <TabsTrigger value=\"approved\">\n            Aprobate ({approvals?.counts?.approved || 0})\n          </TabsTrigger>\n          <TabsTrigger value=\"rejected\">\n            Respinse ({approvals?.counts?.rejected || 0})\n          </TabsTrigger>\n          <TabsTrigger value=\"expired\">\n            Expirate ({approvals?.counts?.expired || 0})\n          </TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value={selectedTab} className=\"mt-4\">\n          <Card>\n            <CardContent className=\"pt-6\">\n              <DataTable\n                columns={columns}\n                data={filteredApprovals}\n                isLoading={isLoading}\n              />\n            </CardContent>\n          </Card>\n        </TabsContent>\n      </Tabs>\n      \n      {/* Approval Detail Dialog */}\n      <Dialog open={!!selectedApproval} onOpenChange={() => setSelectedApproval(null)}>\n        <DialogContent className=\"max-w-2xl\">\n          <DialogHeader>\n            <DialogTitle className=\"flex items-center gap-2\">\n              {selectedApproval && getTypeIcon(selectedApproval.approvalType)}\n              {selectedApproval && typeLabels[selectedApproval.approvalType]}\n            </DialogTitle>\n            <DialogDescription>\n              {selectedApproval?.description}\n            </DialogDescription>\n          </DialogHeader>\n          \n          {selectedApproval && (\n            <div className=\"space-y-4\">\n              {/* Context Info */}\n              <div className=\"grid grid-cols-2 gap-4\">\n                {selectedApproval.contextData.contactName && (\n                  <div>\n                    <label className=\"text-sm font-medium text-muted-foreground\">Contact</label>\n                    <p>{selectedApproval.contextData.contactName}</p>\n                    <p className=\"text-sm text-muted-foreground\">{selectedApproval.contextData.companyName}</p>\n                  </div>\n                )}\n                \n                {selectedApproval.contextData.productName && (\n                  <div>\n                    <label className=\"text-sm font-medium text-muted-foreground\">Produs</label>\n                    <p>{selectedApproval.contextData.productName}</p>\n                  </div>\n                )}\n                \n                {selectedApproval.contextData.currentPrice && (\n                  <div>\n                    <label className=\"text-sm font-medium text-muted-foreground\">Preț Curent</label>\n                    <p>{selectedApproval.contextData.currentPrice.toFixed(2)} RON</p>\n                  </div>\n                )}\n                \n                {selectedApproval.contextData.requestedPrice && (\n                  <div>\n                    <label className=\"text-sm font-medium text-muted-foreground\">Preț Solicitat</label>\n                    <p className=\"text-orange-600 font-semibold\">\n                      {selectedApproval.contextData.requestedPrice.toFixed(2)} RON\n                    </p>\n                  </div>\n                )}\n                \n                {selectedApproval.contextData.discountPercent && (\n                  <div>\n                    <label className=\"text-sm font-medium text-muted-foreground\">Discount Solicitat</label>\n                    <p className=\"text-orange-600 font-semibold\">\n                      {selectedApproval.contextData.discountPercent}%\n                    </p>\n                  </div>\n                )}\n              </div>\n              \n              {/* SLA & Priority */}\n              <div className=\"flex items-center gap-4 p-3 bg-muted rounded-lg\">\n                <div className=\"flex items-center gap-2\">\n                  <Clock className=\"h-4 w-4\" />\n                  <span className=\"text-sm\">SLA:</span>\n                  <Badge variant={getSlaUrgency(selectedApproval.slaDeadline).variant}>\n                    {getSlaUrgency(selectedApproval.slaDeadline).label}\n                  </Badge>\n                </div>\n                <div className=\"flex items-center gap-2\">\n                  <AlertTriangle className=\"h-4 w-4\" />\n                  <span className=\"text-sm\">Prioritate:</span>\n                  <Badge variant={priorityLabels[selectedApproval.priority].variant}>\n                    {priorityLabels[selectedApproval.priority].label}\n                  </Badge>\n                </div>\n                {selectedApproval.escalationLevel > 0 && (\n                  <div className=\"flex items-center gap-2\">\n                    <ArrowUpRight className=\"h-4 w-4 text-red-500\" />\n                    <span className=\"text-sm\">Escalat Nivel {selectedApproval.escalationLevel}</span>\n                  </div>\n                )}\n              </div>\n              \n              {/* Actions for Pending */}\n              {selectedApproval.status === 'pending' && (\n                <>\n                  {/* Optional Modified Value */}\n                  {(selectedApproval.approvalType === 'discount' || \n                    selectedApproval.approvalType === 'price_override') && (\n                    <div>\n                      <label className=\"text-sm font-medium\">Valoare Modificată (opțional)</label>\n                      <Input\n                        type=\"number\"\n                        placeholder=\"Lasă gol pentru a aproba valoarea solicitată\"\n                        value={modifiedValue}\n                        onChange={(e) => setModifiedValue(e.target.value)}\n                        className=\"mt-1\"\n                      />\n                      <p className=\"text-xs text-muted-foreground mt-1\">\n                        Poți aproba cu o valoare diferită de cea solicitată\n                      </p>\n                    </div>\n                  )}\n                  \n                  {/* Comment */}\n                  <div>\n                    <label className=\"text-sm font-medium\">Comentariu</label>\n                    <Textarea\n                      placeholder=\"Adaugă un comentariu (opțional pentru aprobare, obligatoriu pentru respingere)\"\n                      value={approvalComment}\n                      onChange={(e) => setApprovalComment(e.target.value)}\n                      className=\"mt-1\"\n                    />\n                  </div>\n                </>\n              )}\n            </div>\n          )}\n          \n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setSelectedApproval(null)}>\n              Închide\n            </Button>\n            \n            {selectedApproval?.status === 'pending' && (\n              <>\n                <Button\n                  variant=\"destructive\"\n                  onClick={() => {\n                    if (!approvalComment) {\n                      toast({ \n                        title: 'Comentariu necesar', \n                        description: 'Adaugă un motiv pentru respingere.',\n                        variant: 'destructive'\n                      });\n                      return;\n                    }\n                    rejectMutation.mutate({ \n                      id: selectedApproval.id, \n                      comment: approvalComment \n                    });\n                  }}\n                  disabled={rejectMutation.isPending}\n                >\n                  <XCircle className=\"h-4 w-4 mr-2\" />\n                  Respinge\n                </Button>\n                <Button\n                  onClick={() => approveMutation.mutate({ \n                    id: selectedApproval.id, \n                    comment: approvalComment,\n                    modifiedValue: modifiedValue ? parseFloat(modifiedValue) : undefined\n                  })}\n                  disabled={approveMutation.isPending}\n                >\n                  <CheckCircle className=\"h-4 w-4 mr-2\" />\n                  Aprobă\n                </Button>\n              </>\n            )}\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/approvals",
  "restrictii_antihalucinatie": [
    "AFIȘEAZĂ SLA urgency cu countdown",
    "PERMITE filtering și search",
    "INCLUDE approve/reject cu comentarii",
    "AFIȘEAZĂ escalation level clar",
    "VALIDEAZĂ comment obligatoriu pentru reject"
  ],
  "validare_task": "1. DataTable renders cu toate coloanele\n2. Filtering funcționează\n3. Approve/Reject cu comentarii\n4. SLA urgency afișat corect\n5. Modified value pentru partial approvals",
  "outcome": "Pagină HITL Approval Queue funcțională pentru gestionare aprobări"
}
```

## F3.16.4 Products Catalog Page (#77)

```json
{
  "taskID": "F3.16.4.T001",
  "denumire_task": "Implementare pagină Products Catalog cu căutare și filtrare avansată",
  "context_anterior": "Pagini AI implementate. Acum implementăm catalog produse pentru vizualizare și căutare.",
  "descriere_task": "Ești un expert în React și catalog interfaces. Task-ul tău este să creezi pagina catalog produse.\n\nCreează fișierul /apps/web/src/pages/products/index.tsx:\n\n```tsx\nimport React, { useState, useMemo } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { Slider } from '@/components/ui/slider';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Label } from '@/components/ui/label';\nimport { DataTable } from '@/components/ui/data-table';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { \n  Search, \n  Filter, \n  Grid, \n  List, \n  Package,\n  AlertTriangle,\n  TrendingUp,\n  Tag\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport { useDebounce } from '@/hooks/useDebounce';\nimport { ColumnDef } from '@tanstack/react-table';\n\ninterface Product {\n  id: string;\n  sku: string;\n  name: string;\n  category: string;\n  brand: string;\n  basePrice: number;\n  currentStock: number;\n  reservedStock: number;\n  unit: string;\n  isActive: boolean;\n  compatibleCrops: string[];\n  seasonality: string[];\n}\n\nexport default function ProductsCatalogPage() {\n  const [searchQuery, setSearchQuery] = useState('');\n  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');\n  const [selectedCategory, setSelectedCategory] = useState<string>('');\n  const [selectedBrand, setSelectedBrand] = useState<string>('');\n  const [priceRange, setPriceRange] = useState<[number, number]>([0, 100000]);\n  const [stockFilter, setStockFilter] = useState<string>('all');\n  \n  const debouncedSearch = useDebounce(searchQuery, 300);\n  \n  // Fetch products\n  const { data: productsData, isLoading } = useQuery({\n    queryKey: ['products', debouncedSearch, selectedCategory, selectedBrand, priceRange, stockFilter],\n    queryFn: () => apiClient.get('/api/v1/products', {\n      params: {\n        search: debouncedSearch,\n        category: selectedCategory || undefined,\n        brand: selectedBrand || undefined,\n        minPrice: priceRange[0],\n        maxPrice: priceRange[1],\n        stockFilter,\n        limit: 50\n      }\n    })\n  });\n  \n  // Fetch filter options\n  const { data: categories } = useQuery({\n    queryKey: ['product-categories'],\n    queryFn: () => apiClient.get('/api/v1/products/categories')\n  });\n  \n  const { data: brands } = useQuery({\n    queryKey: ['product-brands'],\n    queryFn: () => apiClient.get('/api/v1/products/brands')\n  });\n  \n  const products = productsData?.items || [];\n  \n  const columns: ColumnDef<Product>[] = [\n    {\n      accessorKey: 'sku',\n      header: 'SKU',\n      cell: ({ row }) => (\n        <span className=\"font-mono text-sm\">{row.original.sku}</span>\n      )\n    },\n    {\n      accessorKey: 'name',\n      header: 'Produs',\n      cell: ({ row }) => (\n        <div>\n          <p className=\"font-medium\">{row.original.name}</p>\n          <p className=\"text-sm text-muted-foreground\">{row.original.category}</p>\n        </div>\n      )\n    },\n    {\n      accessorKey: 'brand',\n      header: 'Brand'\n    },\n    {\n      accessorKey: 'basePrice',\n      header: 'Preț',\n      cell: ({ row }) => (\n        <span className=\"font-medium\">\n          {row.original.basePrice.toLocaleString('ro-RO')} RON/{row.original.unit}\n        </span>\n      )\n    },\n    {\n      accessorKey: 'currentStock',\n      header: 'Stoc',\n      cell: ({ row }) => {\n        const available = row.original.currentStock - row.original.reservedStock;\n        const isLow = available < 10;\n        return (\n          <div className=\"flex items-center gap-2\">\n            {isLow && <AlertTriangle className=\"h-4 w-4 text-orange-500\" />}\n            <span className={isLow ? 'text-orange-500 font-medium' : ''}>\n              {available} {row.original.unit}\n            </span>\n          </div>\n        );\n      }\n    },\n    {\n      accessorKey: 'isActive',\n      header: 'Status',\n      cell: ({ row }) => (\n        <Badge variant={row.original.isActive ? 'default' : 'secondary'}>\n          {row.original.isActive ? 'Activ' : 'Inactiv'}\n        </Badge>\n      )\n    }\n  ];\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">Catalog Produse</h1>\n          <p className=\"text-muted-foreground\">\n            {productsData?.total || 0} produse disponibile\n          </p>\n        </div>\n        \n        <div className=\"flex items-center gap-2\">\n          <Button\n            variant={viewMode === 'grid' ? 'default' : 'outline'}\n            size=\"icon\"\n            onClick={() => setViewMode('grid')}\n          >\n            <Grid className=\"h-4 w-4\" />\n          </Button>\n          <Button\n            variant={viewMode === 'list' ? 'default' : 'outline'}\n            size=\"icon\"\n            onClick={() => setViewMode('list')}\n          >\n            <List className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      </div>\n      \n      {/* Filters */}\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"grid grid-cols-1 md:grid-cols-5 gap-4\">\n            <div className=\"md:col-span-2\">\n              <div className=\"relative\">\n                <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n                <Input\n                  placeholder=\"Caută produse...\"\n                  value={searchQuery}\n                  onChange={(e) => setSearchQuery(e.target.value)}\n                  className=\"pl-9\"\n                />\n              </div>\n            </div>\n            \n            <Select value={selectedCategory} onValueChange={setSelectedCategory}>\n              <SelectTrigger>\n                <SelectValue placeholder=\"Categorie\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"\">Toate categoriile</SelectItem>\n                {categories?.map((cat: string) => (\n                  <SelectItem key={cat} value={cat}>{cat}</SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n            \n            <Select value={selectedBrand} onValueChange={setSelectedBrand}>\n              <SelectTrigger>\n                <SelectValue placeholder=\"Brand\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"\">Toate brandurile</SelectItem>\n                {brands?.map((b: string) => (\n                  <SelectItem key={b} value={b}>{b}</SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n            \n            <Select value={stockFilter} onValueChange={setStockFilter}>\n              <SelectTrigger>\n                <SelectValue placeholder=\"Stoc\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"all\">Toate</SelectItem>\n                <SelectItem value=\"in_stock\">În stoc</SelectItem>\n                <SelectItem value=\"low_stock\">Stoc scăzut</SelectItem>\n                <SelectItem value=\"out_of_stock\">Fără stoc</SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n        </CardContent>\n      </Card>\n      \n      {/* Products Display */}\n      {viewMode === 'grid' ? (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\">\n          {products.map((product: Product) => (\n            <Card key={product.id} className=\"hover:shadow-lg transition-shadow\">\n              <CardHeader className=\"pb-2\">\n                <div className=\"flex items-start justify-between\">\n                  <Badge variant=\"outline\">{product.category}</Badge>\n                  <Badge variant={product.isActive ? 'default' : 'secondary'}>\n                    {product.isActive ? 'Activ' : 'Inactiv'}\n                  </Badge>\n                </div>\n                <CardTitle className=\"text-lg mt-2\">{product.name}</CardTitle>\n                <p className=\"text-sm text-muted-foreground\">{product.brand}</p>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-2\">\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">SKU</span>\n                    <span className=\"font-mono text-sm\">{product.sku}</span>\n                  </div>\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Preț</span>\n                    <span className=\"font-semibold\">\n                      {product.basePrice.toLocaleString('ro-RO')} RON/{product.unit}\n                    </span>\n                  </div>\n                  <div className=\"flex justify-between items-center\">\n                    <span className=\"text-muted-foreground\">Stoc</span>\n                    <div className=\"flex items-center gap-1\">\n                      {(product.currentStock - product.reservedStock) < 10 && (\n                        <AlertTriangle className=\"h-4 w-4 text-orange-500\" />\n                      )}\n                      <span>\n                        {product.currentStock - product.reservedStock} {product.unit}\n                      </span>\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n              <CardFooter>\n                <Button variant=\"outline\" className=\"w-full\">\n                  Vezi Detalii\n                </Button>\n              </CardFooter>\n            </Card>\n          ))}\n        </div>\n      ) : (\n        <Card>\n          <CardContent className=\"pt-6\">\n            <DataTable\n              columns={columns}\n              data={products}\n              isLoading={isLoading}\n            />\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/products",
  "restrictii_antihalucinatie": [
    "DISPLAY stock alerts pentru stoc scăzut",
    "FILTER produse pe multiple criterii",
    "SWITCH între grid și list view",
    "DEBOUNCE search la 300ms",
    "SHOW available stock (current - reserved)"
  ],
  "validare_task": "1. Grid și list views funcționale\n2. Search cu debounce\n3. Filtre categorie/brand/stoc\n4. Stock alerts vizibile\n5. Responsive layout",
  "outcome": "Pagină Products Catalog completă cu căutare și filtrare"
}
```

## F3.16.5 Product Detail Page (#78)

```json
{
  "taskID": "F3.16.5.T001",
  "denumire_task": "Implementare pagină Product Detail cu informații complete și RAG knowledge",
  "context_anterior": "Products Catalog implementat. Acum implementăm pagina de detalii produs.",
  "descriere_task": "Ești un expert în React și product pages. Task-ul tău este să creezi pagina detalii produs.\n\nCreează fișierul /apps/web/src/pages/products/[id].tsx:\n\n```tsx\nimport React from 'react';\nimport { useParams, useRouter } from 'next/navigation';\nimport { useQuery } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Separator } from '@/components/ui/separator';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { \n  ArrowLeft,\n  Package,\n  Tag,\n  Leaf,\n  Calendar,\n  AlertTriangle,\n  TrendingUp,\n  TrendingDown,\n  Info,\n  FileText,\n  Edit\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport { StockHistoryChart } from '@/components/charts/StockHistoryChart';\nimport { PriceHistoryChart } from '@/components/charts/PriceHistoryChart';\n\ninterface ProductDetail {\n  id: string;\n  sku: string;\n  name: string;\n  category: string;\n  brand: string;\n  description: string;\n  basePrice: number;\n  currentStock: number;\n  reservedStock: number;\n  unit: string;\n  isActive: boolean;\n  compatibleCrops: string[];\n  seasonality: string[];\n  specifications: Record<string, string>;\n  applicationNotes: string;\n  safetyInfo: string;\n  embeddingVersion: number;\n  lastEmbeddingAt: string;\n  priceHistory: Array<{ date: string; price: number }>;\n  stockHistory: Array<{ date: string; stock: number }>;\n  relatedProducts: Array<{ id: string; name: string; category: string }>;\n}\n\nexport default function ProductDetailPage() {\n  const params = useParams();\n  const router = useRouter();\n  const productId = params.id as string;\n  \n  const { data: product, isLoading } = useQuery({\n    queryKey: ['product', productId],\n    queryFn: () => apiClient.get<ProductDetail>(`/api/v1/products/${productId}`)\n  });\n  \n  if (isLoading) {\n    return <div className=\"p-6\">Se încarcă...</div>;\n  }\n  \n  if (!product) {\n    return <div className=\"p-6\">Produsul nu a fost găsit.</div>;\n  }\n  \n  const availableStock = product.currentStock - product.reservedStock;\n  const isLowStock = availableStock < 10;\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-start justify-between\">\n        <div className=\"flex items-center gap-4\">\n          <Button variant=\"ghost\" size=\"icon\" onClick={() => router.back()}>\n            <ArrowLeft className=\"h-4 w-4\" />\n          </Button>\n          <div>\n            <div className=\"flex items-center gap-2\">\n              <h1 className=\"text-2xl font-bold\">{product.name}</h1>\n              <Badge variant={product.isActive ? 'default' : 'secondary'}>\n                {product.isActive ? 'Activ' : 'Inactiv'}\n              </Badge>\n            </div>\n            <div className=\"flex items-center gap-3 text-muted-foreground mt-1\">\n              <span className=\"font-mono\">{product.sku}</span>\n              <span>•</span>\n              <span>{product.brand}</span>\n              <span>•</span>\n              <span>{product.category}</span>\n            </div>\n          </div>\n        </div>\n        \n        <Button>\n          <Edit className=\"h-4 w-4 mr-2\" />\n          Editează\n        </Button>\n      </div>\n      \n      {/* Main Content */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\n        {/* Left Column - Main Info */}\n        <div className=\"lg:col-span-2 space-y-6\">\n          <Tabs defaultValue=\"overview\">\n            <TabsList>\n              <TabsTrigger value=\"overview\">Prezentare</TabsTrigger>\n              <TabsTrigger value=\"specs\">Specificații</TabsTrigger>\n              <TabsTrigger value=\"application\">Aplicare</TabsTrigger>\n              <TabsTrigger value=\"safety\">Siguranță</TabsTrigger>\n              <TabsTrigger value=\"analytics\">Analize</TabsTrigger>\n            </TabsList>\n            \n            <TabsContent value=\"overview\" className=\"space-y-4 mt-4\">\n              <Card>\n                <CardHeader>\n                  <CardTitle>Descriere</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <p className=\"whitespace-pre-wrap\">{product.description}</p>\n                </CardContent>\n              </Card>\n              \n              {/* Crops & Seasonality */}\n              <div className=\"grid grid-cols-2 gap-4\">\n                <Card>\n                  <CardHeader className=\"pb-2\">\n                    <CardTitle className=\"text-sm flex items-center gap-2\">\n                      <Leaf className=\"h-4 w-4\" />\n                      Culturi Compatibile\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"flex flex-wrap gap-2\">\n                      {product.compatibleCrops?.map((crop) => (\n                        <Badge key={crop} variant=\"outline\">{crop}</Badge>\n                      ))}\n                    </div>\n                  </CardContent>\n                </Card>\n                \n                <Card>\n                  <CardHeader className=\"pb-2\">\n                    <CardTitle className=\"text-sm flex items-center gap-2\">\n                      <Calendar className=\"h-4 w-4\" />\n                      Sezonalitate\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"flex flex-wrap gap-2\">\n                      {product.seasonality?.map((season) => (\n                        <Badge key={season} variant=\"secondary\">{season}</Badge>\n                      ))}\n                    </div>\n                  </CardContent>\n                </Card>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"specs\" className=\"mt-4\">\n              <Card>\n                <CardContent className=\"pt-6\">\n                  <Table>\n                    <TableBody>\n                      {Object.entries(product.specifications || {}).map(([key, value]) => (\n                        <TableRow key={key}>\n                          <TableCell className=\"font-medium w-1/3\">{key}</TableCell>\n                          <TableCell>{value}</TableCell>\n                        </TableRow>\n                      ))}\n                    </TableBody>\n                  </Table>\n                </CardContent>\n              </Card>\n            </TabsContent>\n            \n            <TabsContent value=\"application\" className=\"mt-4\">\n              <Card>\n                <CardHeader>\n                  <CardTitle>Note de Aplicare</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <p className=\"whitespace-pre-wrap\">{product.applicationNotes}</p>\n                </CardContent>\n              </Card>\n            </TabsContent>\n            \n            <TabsContent value=\"safety\" className=\"mt-4\">\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-orange-600\">\n                    <AlertTriangle className=\"h-5 w-5\" />\n                    Informații de Siguranță\n                  </CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <p className=\"whitespace-pre-wrap\">{product.safetyInfo}</p>\n                </CardContent>\n              </Card>\n            </TabsContent>\n            \n            <TabsContent value=\"analytics\" className=\"space-y-4 mt-4\">\n              <Card>\n                <CardHeader>\n                  <CardTitle>Istoric Preț</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <PriceHistoryChart data={product.priceHistory} />\n                </CardContent>\n              </Card>\n              \n              <Card>\n                <CardHeader>\n                  <CardTitle>Istoric Stoc</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <StockHistoryChart data={product.stockHistory} />\n                </CardContent>\n              </Card>\n            </TabsContent>\n          </Tabs>\n        </div>\n        \n        {/* Right Column - Quick Info */}\n        <div className=\"space-y-4\">\n          {/* Price Card */}\n          <Card>\n            <CardHeader className=\"pb-2\">\n              <CardTitle className=\"text-sm\">Preț</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"text-3xl font-bold\">\n                {product.basePrice.toLocaleString('ro-RO')} RON\n              </div>\n              <p className=\"text-muted-foreground\">per {product.unit}</p>\n            </CardContent>\n          </Card>\n          \n          {/* Stock Card */}\n          <Card className={isLowStock ? 'border-orange-200' : ''}>\n            <CardHeader className=\"pb-2\">\n              <CardTitle className=\"text-sm flex items-center gap-2\">\n                <Package className=\"h-4 w-4\" />\n                Stoc\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-2\">\n                <div className=\"flex justify-between\">\n                  <span className=\"text-muted-foreground\">Total</span>\n                  <span className=\"font-medium\">{product.currentStock} {product.unit}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span className=\"text-muted-foreground\">Rezervat</span>\n                  <span className=\"font-medium text-orange-500\">\n                    {product.reservedStock} {product.unit}\n                  </span>\n                </div>\n                <Separator />\n                <div className=\"flex justify-between\">\n                  <span className=\"font-medium\">Disponibil</span>\n                  <span className={`font-bold ${isLowStock ? 'text-orange-500' : 'text-green-600'}`}>\n                    {availableStock} {product.unit}\n                  </span>\n                </div>\n                {isLowStock && (\n                  <div className=\"flex items-center gap-2 text-orange-500 text-sm mt-2\">\n                    <AlertTriangle className=\"h-4 w-4\" />\n                    Stoc scăzut!\n                  </div>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n          \n          {/* Embedding Status */}\n          <Card>\n            <CardHeader className=\"pb-2\">\n              <CardTitle className=\"text-sm flex items-center gap-2\">\n                <Info className=\"h-4 w-4\" />\n                RAG Knowledge\n              </CardTitle>\n            </CardHeader>\n            <CardContent className=\"text-sm\">\n              <div className=\"space-y-1\">\n                <div className=\"flex justify-between\">\n                  <span className=\"text-muted-foreground\">Versiune embedding</span>\n                  <span>v{product.embeddingVersion}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span className=\"text-muted-foreground\">Ultima actualizare</span>\n                  <span>\n                    {new Date(product.lastEmbeddingAt).toLocaleDateString('ro-RO')}\n                  </span>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n          \n          {/* Related Products */}\n          {product.relatedProducts?.length > 0 && (\n            <Card>\n              <CardHeader className=\"pb-2\">\n                <CardTitle className=\"text-sm\">Produse Similare</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-2\">\n                  {product.relatedProducts.slice(0, 5).map((related) => (\n                    <Button\n                      key={related.id}\n                      variant=\"ghost\"\n                      className=\"w-full justify-start text-left h-auto py-2\"\n                      onClick={() => router.push(`/products/${related.id}`)}\n                    >\n                      <div>\n                        <p className=\"font-medium\">{related.name}</p>\n                        <p className=\"text-xs text-muted-foreground\">{related.category}</p>\n                      </div>\n                    </Button>\n                  ))}\n                </div>\n              </CardContent>\n            </Card>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/products",
  "restrictii_antihalucinatie": [
    "DISPLAY all product info tabs",
    "SHOW stock status cu alerts",
    "INCLUDE RAG embedding status",
    "LINK related products",
    "CHARTS pentru istoric preț/stoc"
  ],
  "validare_task": "1. Tabs navigație funcționale\n2. Stock info cu alerts\n3. Embedding status display\n4. Price/stock history charts\n5. Related products links",
  "outcome": "Pagină Product Detail completă cu toate informațiile"
}
```

## F3.16.6 Proposals Management Page (#79)

```json
{
  "taskID": "F3.16.6.T001",
  "denumire_task": "Implementare pagină Proposals cu listare și acțiuni",
  "context_anterior": "Product pages implementate. Acum implementăm managementul propunerilor/ofertelor.",
  "descriere_task": "Ești un expert în React și document management. Task-ul tău este să creezi pagina de propuneri.\n\nCreează fișierul /apps/web/src/pages/proposals/index.tsx:\n\n```tsx\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { DataTable } from '@/components/ui/data-table';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\nimport { \n  FileText, \n  Download, \n  Send, \n  MoreHorizontal,\n  Eye,\n  Copy,\n  Trash2,\n  Search,\n  Plus,\n  CheckCircle,\n  XCircle,\n  Clock\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport { ColumnDef } from '@tanstack/react-table';\nimport { format } from 'date-fns';\nimport { ro } from 'date-fns/locale';\n\ninterface Proposal {\n  id: string;\n  documentNumber: string;\n  negotiationId: string;\n  contact: {\n    companyName: string;\n    name: string;\n  };\n  status: 'draft' | 'sent' | 'viewed' | 'accepted' | 'rejected' | 'expired';\n  totalValue: number;\n  discountPercent: number;\n  validUntil: string;\n  createdAt: string;\n  sentAt?: string;\n  fileUrl?: string;\n}\n\nexport default function ProposalsPage() {\n  const queryClient = useQueryClient();\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedStatus, setSelectedStatus] = useState('all');\n  \n  const { data: proposalsData, isLoading } = useQuery({\n    queryKey: ['proposals', selectedStatus, searchQuery],\n    queryFn: () => apiClient.get('/api/v1/proposals', {\n      params: {\n        status: selectedStatus !== 'all' ? selectedStatus : undefined,\n        search: searchQuery || undefined\n      }\n    })\n  });\n  \n  const sendMutation = useMutation({\n    mutationFn: (proposalId: string) => \n      apiClient.post(`/api/v1/proposals/${proposalId}/send`),\n    onSuccess: () => queryClient.invalidateQueries(['proposals'])\n  });\n  \n  const deleteMutation = useMutation({\n    mutationFn: (proposalId: string) => \n      apiClient.delete(`/api/v1/proposals/${proposalId}`),\n    onSuccess: () => queryClient.invalidateQueries(['proposals'])\n  });\n  \n  const getStatusBadge = (status: string) => {\n    const variants: Record<string, { variant: any; icon: any; label: string }> = {\n      draft: { variant: 'secondary', icon: FileText, label: 'Draft' },\n      sent: { variant: 'default', icon: Send, label: 'Trimisă' },\n      viewed: { variant: 'outline', icon: Eye, label: 'Vizualizată' },\n      accepted: { variant: 'default', icon: CheckCircle, label: 'Acceptată' },\n      rejected: { variant: 'destructive', icon: XCircle, label: 'Respinsă' },\n      expired: { variant: 'secondary', icon: Clock, label: 'Expirată' }\n    };\n    const config = variants[status] || variants.draft;\n    const Icon = config.icon;\n    return (\n      <Badge variant={config.variant} className=\"gap-1\">\n        <Icon className=\"h-3 w-3\" />\n        {config.label}\n      </Badge>\n    );\n  };\n  \n  const columns: ColumnDef<Proposal>[] = [\n    {\n      accessorKey: 'documentNumber',\n      header: 'Număr',\n      cell: ({ row }) => (\n        <span className=\"font-mono font-medium\">{row.original.documentNumber}</span>\n      )\n    },\n    {\n      accessorKey: 'contact',\n      header: 'Client',\n      cell: ({ row }) => (\n        <div>\n          <p className=\"font-medium\">{row.original.contact.companyName}</p>\n          <p className=\"text-sm text-muted-foreground\">{row.original.contact.name}</p>\n        </div>\n      )\n    },\n    {\n      accessorKey: 'totalValue',\n      header: 'Valoare',\n      cell: ({ row }) => (\n        <div>\n          <p className=\"font-medium\">\n            {row.original.totalValue.toLocaleString('ro-RO')} RON\n          </p>\n          {row.original.discountPercent > 0 && (\n            <p className=\"text-sm text-green-600\">\n              -{row.original.discountPercent}% discount\n            </p>\n          )}\n        </div>\n      )\n    },\n    {\n      accessorKey: 'status',\n      header: 'Status',\n      cell: ({ row }) => getStatusBadge(row.original.status)\n    },\n    {\n      accessorKey: 'validUntil',\n      header: 'Valabilitate',\n      cell: ({ row }) => {\n        const isExpired = new Date(row.original.validUntil) < new Date();\n        return (\n          <span className={isExpired ? 'text-red-500' : ''}>\n            {format(new Date(row.original.validUntil), 'dd MMM yyyy', { locale: ro })}\n          </span>\n        );\n      }\n    },\n    {\n      accessorKey: 'createdAt',\n      header: 'Creată',\n      cell: ({ row }) => (\n        format(new Date(row.original.createdAt), 'dd MMM yyyy', { locale: ro })\n      )\n    },\n    {\n      id: 'actions',\n      cell: ({ row }) => (\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button variant=\"ghost\" size=\"icon\">\n              <MoreHorizontal className=\"h-4 w-4\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"end\">\n            <DropdownMenuItem onClick={() => window.open(row.original.fileUrl)}>\n              <Download className=\"h-4 w-4 mr-2\" />\n              Descarcă PDF\n            </DropdownMenuItem>\n            <DropdownMenuItem>\n              <Eye className=\"h-4 w-4 mr-2\" />\n              Previzualizare\n            </DropdownMenuItem>\n            {row.original.status === 'draft' && (\n              <DropdownMenuItem onClick={() => sendMutation.mutate(row.original.id)}>\n                <Send className=\"h-4 w-4 mr-2\" />\n                Trimite\n              </DropdownMenuItem>\n            )}\n            <DropdownMenuItem>\n              <Copy className=\"h-4 w-4 mr-2\" />\n              Duplică\n            </DropdownMenuItem>\n            <DropdownMenuItem \n              className=\"text-red-600\"\n              onClick={() => deleteMutation.mutate(row.original.id)}\n            >\n              <Trash2 className=\"h-4 w-4 mr-2\" />\n              Șterge\n            </DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n      )\n    }\n  ];\n  \n  const stats = proposalsData?.stats || {};\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">Propuneri</h1>\n          <p className=\"text-muted-foreground\">\n            Gestionează ofertele și propunerile comerciale\n          </p>\n        </div>\n        <Button>\n          <Plus className=\"h-4 w-4 mr-2\" />\n          Propunere Nouă\n        </Button>\n      </div>\n      \n      {/* Stats */}\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Total</p>\n                <p className=\"text-2xl font-bold\">{stats.total || 0}</p>\n              </div>\n              <FileText className=\"h-8 w-8 text-muted-foreground\" />\n            </div>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Trimise</p>\n                <p className=\"text-2xl font-bold\">{stats.sent || 0}</p>\n              </div>\n              <Send className=\"h-8 w-8 text-blue-500\" />\n            </div>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Acceptate</p>\n                <p className=\"text-2xl font-bold\">{stats.accepted || 0}</p>\n              </div>\n              <CheckCircle className=\"h-8 w-8 text-green-500\" />\n            </div>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm text-muted-foreground\">Rată Conversie</p>\n                <p className=\"text-2xl font-bold\">{stats.conversionRate || 0}%</p>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Filters & Table */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center gap-4\">\n            <div className=\"relative flex-1 max-w-sm\">\n              <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n              <Input\n                placeholder=\"Caută propuneri...\"\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                className=\"pl-9\"\n              />\n            </div>\n            <Tabs value={selectedStatus} onValueChange={setSelectedStatus}>\n              <TabsList>\n                <TabsTrigger value=\"all\">Toate</TabsTrigger>\n                <TabsTrigger value=\"draft\">Draft</TabsTrigger>\n                <TabsTrigger value=\"sent\">Trimise</TabsTrigger>\n                <TabsTrigger value=\"accepted\">Acceptate</TabsTrigger>\n              </TabsList>\n            </Tabs>\n          </div>\n        </CardHeader>\n        <CardContent>\n          <DataTable\n            columns={columns}\n            data={proposalsData?.items || []}\n            isLoading={isLoading}\n          />\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/proposals",
  "restrictii_antihalucinatie": [
    "DISPLAY status badges cu icons",
    "ACTIONS contextuale per status",
    "STATS pentru overview",
    "FILTER și search funcționale",
    "EXPIRE indication pentru validitate"
  ],
  "validare_task": "1. Table cu propuneri\n2. Status badges corecte\n3. Actions dropdown funcțional\n4. Stats cards populate\n5. Search și filtre",
  "outcome": "Pagină Proposals completă pentru management oferte"
}
```

## F3.16.7 Invoices Management Page (#80)

```json
{
  "taskID": "F3.16.7.T001",
  "denumire_task": "Implementare pagină Invoices cu e-Factura status și SPV tracking",
  "context_anterior": "Proposals page implementată. Acum implementăm managementul facturilor cu integrare e-Factura.",
  "descriere_task": "Ești un expert în React și fiscal compliance. Task-ul tău este să creezi pagina de facturi.\n\nCreează fișierul /apps/web/src/pages/invoices/index.tsx:\n\n```tsx\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { DataTable } from '@/components/ui/data-table';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/components/ui/dialog';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { \n  FileText, \n  Upload, \n  Download, \n  RefreshCw,\n  CheckCircle,\n  XCircle,\n  Clock,\n  AlertTriangle,\n  ExternalLink,\n  Search,\n  Filter\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport { ColumnDef } from '@tanstack/react-table';\nimport { format } from 'date-fns';\nimport { ro } from 'date-fns/locale';\n\ninterface Invoice {\n  id: string;\n  invoiceNumber: string;\n  oblioId?: string;\n  contact: {\n    companyName: string;\n    cui: string;\n  };\n  totalWithVat: number;\n  status: 'draft' | 'generated' | 'submitted' | 'accepted' | 'rejected';\n  spvStatus?: 'pending' | 'in_prelucrare' | 'ok' | 'nok';\n  spvUploadIndex?: string;\n  spvResponseXml?: string;\n  createdAt: string;\n  submittedAt?: string;\n}\n\nexport default function InvoicesPage() {\n  const queryClient = useQueryClient();\n  const [selectedInvoice, setSelectedInvoice] = useState<Invoice | null>(null);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedTab, setSelectedTab] = useState('all');\n  \n  const { data: invoicesData, isLoading } = useQuery({\n    queryKey: ['invoices', selectedTab, searchQuery],\n    queryFn: () => apiClient.get('/api/v1/invoices', {\n      params: {\n        status: selectedTab !== 'all' ? selectedTab : undefined,\n        search: searchQuery || undefined\n      }\n    }),\n    refetchInterval: 30000 // Refresh every 30s for SPV status\n  });\n  \n  const submitMutation = useMutation({\n    mutationFn: (invoiceId: string) => \n      apiClient.post(`/api/v1/invoices/${invoiceId}/submit-efactura`),\n    onSuccess: () => queryClient.invalidateQueries(['invoices'])\n  });\n  \n  const refreshSpvMutation = useMutation({\n    mutationFn: (invoiceId: string) => \n      apiClient.post(`/api/v1/invoices/${invoiceId}/refresh-spv`),\n    onSuccess: () => queryClient.invalidateQueries(['invoices'])\n  });\n  \n  const getSpvStatusBadge = (spvStatus?: string) => {\n    if (!spvStatus) return null;\n    const configs: Record<string, { variant: any; icon: any; label: string }> = {\n      pending: { variant: 'secondary', icon: Clock, label: 'În așteptare' },\n      in_prelucrare: { variant: 'outline', icon: RefreshCw, label: 'În prelucrare' },\n      ok: { variant: 'default', icon: CheckCircle, label: 'Acceptată ANAF' },\n      nok: { variant: 'destructive', icon: XCircle, label: 'Respinsă ANAF' }\n    };\n    const config = configs[spvStatus] || configs.pending;\n    const Icon = config.icon;\n    return (\n      <Badge variant={config.variant} className=\"gap-1\">\n        <Icon className={`h-3 w-3 ${spvStatus === 'in_prelucrare' ? 'animate-spin' : ''}`} />\n        {config.label}\n      </Badge>\n    );\n  };\n  \n  const columns: ColumnDef<Invoice>[] = [\n    {\n      accessorKey: 'invoiceNumber',\n      header: 'Număr',\n      cell: ({ row }) => (\n        <span className=\"font-mono font-medium\">{row.original.invoiceNumber}</span>\n      )\n    },\n    {\n      accessorKey: 'contact',\n      header: 'Client',\n      cell: ({ row }) => (\n        <div>\n          <p className=\"font-medium\">{row.original.contact.companyName}</p>\n          <p className=\"text-sm text-muted-foreground\">CUI: {row.original.contact.cui}</p>\n        </div>\n      )\n    },\n    {\n      accessorKey: 'totalWithVat',\n      header: 'Total',\n      cell: ({ row }) => (\n        <span className=\"font-medium\">\n          {row.original.totalWithVat.toLocaleString('ro-RO')} RON\n        </span>\n      )\n    },\n    {\n      accessorKey: 'status',\n      header: 'Status',\n      cell: ({ row }) => (\n        <Badge variant={\n          row.original.status === 'accepted' ? 'default' :\n          row.original.status === 'rejected' ? 'destructive' : 'secondary'\n        }>\n          {row.original.status}\n        </Badge>\n      )\n    },\n    {\n      accessorKey: 'spvStatus',\n      header: 'e-Factura SPV',\n      cell: ({ row }) => getSpvStatusBadge(row.original.spvStatus)\n    },\n    {\n      accessorKey: 'createdAt',\n      header: 'Creat',\n      cell: ({ row }) => (\n        format(new Date(row.original.createdAt), 'dd MMM yyyy', { locale: ro })\n      )\n    },\n    {\n      id: 'actions',\n      cell: ({ row }) => (\n        <div className=\"flex gap-2\">\n          {row.original.status === 'generated' && (\n            <Button\n              size=\"sm\"\n              variant=\"outline\"\n              onClick={() => submitMutation.mutate(row.original.id)}\n              disabled={submitMutation.isPending}\n            >\n              <Upload className=\"h-4 w-4 mr-1\" />\n              Trimite SPV\n            </Button>\n          )}\n          {row.original.spvStatus === 'in_prelucrare' && (\n            <Button\n              size=\"sm\"\n              variant=\"ghost\"\n              onClick={() => refreshSpvMutation.mutate(row.original.id)}\n            >\n              <RefreshCw className=\"h-4 w-4\" />\n            </Button>\n          )}\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            onClick={() => setSelectedInvoice(row.original)}\n          >\n            Detalii\n          </Button>\n        </div>\n      )\n    }\n  ];\n  \n  const stats = invoicesData?.stats || {};\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">Facturi</h1>\n          <p className=\"text-muted-foreground\">\n            Gestionează facturile și integrarea e-Factura ANAF\n          </p>\n        </div>\n      </div>\n      \n      {/* Stats */}\n      <div className=\"grid grid-cols-2 md:grid-cols-5 gap-4\">\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-sm text-muted-foreground\">Total</p>\n            <p className=\"text-2xl font-bold\">{stats.total || 0}</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-sm text-muted-foreground\">Trimise SPV</p>\n            <p className=\"text-2xl font-bold\">{stats.submitted || 0}</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-sm text-muted-foreground\">Acceptate ANAF</p>\n            <p className=\"text-2xl font-bold text-green-600\">{stats.accepted || 0}</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-sm text-muted-foreground\">Respinse</p>\n            <p className=\"text-2xl font-bold text-red-600\">{stats.rejected || 0}</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-sm text-muted-foreground\">În Prelucrare</p>\n            <p className=\"text-2xl font-bold text-orange-500\">{stats.processing || 0}</p>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Alerts for rejected */}\n      {stats.rejected > 0 && (\n        <Card className=\"border-red-200 bg-red-50\">\n          <CardContent className=\"pt-6 flex items-center gap-4\">\n            <AlertTriangle className=\"h-8 w-8 text-red-500\" />\n            <div>\n              <p className=\"font-medium text-red-800\">\n                {stats.rejected} facturi respinse de ANAF\n              </p>\n              <p className=\"text-sm text-red-600\">\n                Verifică erorile și re-trimite după corecții\n              </p>\n            </div>\n          </CardContent>\n        </Card>\n      )}\n      \n      {/* Table */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center gap-4\">\n            <div className=\"relative flex-1 max-w-sm\">\n              <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n              <Input\n                placeholder=\"Caută facturi...\"\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                className=\"pl-9\"\n              />\n            </div>\n            <Tabs value={selectedTab} onValueChange={setSelectedTab}>\n              <TabsList>\n                <TabsTrigger value=\"all\">Toate</TabsTrigger>\n                <TabsTrigger value=\"pending\">În așteptare</TabsTrigger>\n                <TabsTrigger value=\"accepted\">Acceptate</TabsTrigger>\n                <TabsTrigger value=\"rejected\">Respinse</TabsTrigger>\n              </TabsList>\n            </Tabs>\n          </div>\n        </CardHeader>\n        <CardContent>\n          <DataTable\n            columns={columns}\n            data={invoicesData?.items || []}\n            isLoading={isLoading}\n          />\n        </CardContent>\n      </Card>\n      \n      {/* Invoice Detail Dialog */}\n      <Dialog open={!!selectedInvoice} onOpenChange={(open) => !open && setSelectedInvoice(null)}>\n        <DialogContent className=\"max-w-2xl\">\n          <DialogHeader>\n            <DialogTitle>Factura {selectedInvoice?.invoiceNumber}</DialogTitle>\n          </DialogHeader>\n          {selectedInvoice && (\n            <div className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <p className=\"text-sm text-muted-foreground\">Client</p>\n                  <p className=\"font-medium\">{selectedInvoice.contact.companyName}</p>\n                  <p className=\"text-sm\">CUI: {selectedInvoice.contact.cui}</p>\n                </div>\n                <div>\n                  <p className=\"text-sm text-muted-foreground\">Total</p>\n                  <p className=\"text-2xl font-bold\">\n                    {selectedInvoice.totalWithVat.toLocaleString('ro-RO')} RON\n                  </p>\n                </div>\n              </div>\n              \n              <div className=\"p-4 bg-muted rounded-lg\">\n                <p className=\"text-sm font-medium mb-2\">Status e-Factura SPV</p>\n                <div className=\"flex items-center gap-4\">\n                  {getSpvStatusBadge(selectedInvoice.spvStatus)}\n                  {selectedInvoice.spvUploadIndex && (\n                    <span className=\"text-sm text-muted-foreground\">\n                      Index: {selectedInvoice.spvUploadIndex}\n                    </span>\n                  )}\n                </div>\n                {selectedInvoice.spvStatus === 'nok' && selectedInvoice.spvResponseXml && (\n                  <div className=\"mt-4 p-3 bg-red-50 rounded text-sm text-red-800 font-mono whitespace-pre-wrap\">\n                    {selectedInvoice.spvResponseXml}\n                  </div>\n                )}\n              </div>\n              \n              <div className=\"flex gap-2\">\n                <Button variant=\"outline\" className=\"flex-1\">\n                  <Download className=\"h-4 w-4 mr-2\" />\n                  Descarcă PDF\n                </Button>\n                <Button variant=\"outline\" className=\"flex-1\">\n                  <Download className=\"h-4 w-4 mr-2\" />\n                  Descarcă XML\n                </Button>\n                {selectedInvoice.oblioId && (\n                  <Button variant=\"outline\">\n                    <ExternalLink className=\"h-4 w-4 mr-2\" />\n                    Oblio\n                  </Button>\n                )}\n              </div>\n            </div>\n          )}\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/invoices",
  "restrictii_antihalucinatie": [
    "DISPLAY SPV status cu refresh",
    "ALERT pentru facturi respinse",
    "SHOW upload index din ANAF",
    "AUTO-REFRESH la 30s pentru status",
    "ERROR display pentru NOK responses"
  ],
  "validare_task": "1. Table cu toate facturile\n2. SPV status badges corecte\n3. Submit și refresh actions\n4. Detail dialog cu error info\n5. Stats accurate",
  "outcome": "Pagină Invoices completă cu integrare e-Factura"
}
```

## F3.16.8 Analytics Dashboard Page (#81)

```json
{
  "taskID": "F3.16.8.T001",
  "denumire_task": "Implementare pagină Analytics Dashboard cu metrici AI Sales și performance",
  "context_anterior": "Invoices page implementată. Acum implementăm dashboard-ul de analytics pentru AI sales.",
  "descriere_task": "Ești un expert în React și data visualization. Task-ul tău este să creezi dashboard analytics.\n\nCreează fișierul /apps/web/src/pages/analytics/index.tsx:\n\n```tsx\nimport React, { useState } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { \n  TrendingUp, \n  TrendingDown, \n  Bot, \n  MessageSquare,\n  Target,\n  Clock,\n  AlertTriangle,\n  CheckCircle,\n  DollarSign,\n  Users,\n  ArrowUpRight,\n  ArrowDownRight\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api-client';\nimport {\n  LineChart,\n  Line,\n  AreaChart,\n  Area,\n  BarChart,\n  Bar,\n  PieChart,\n  Pie,\n  Cell,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  Legend,\n  ResponsiveContainer\n} from 'recharts';\n\nconst COLORS = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];\n\nexport default function AnalyticsDashboardPage() {\n  const [dateRange, setDateRange] = useState('7d');\n  \n  const { data: analytics, isLoading } = useQuery({\n    queryKey: ['analytics', dateRange],\n    queryFn: () => apiClient.get('/api/v1/analytics/dashboard', {\n      params: { range: dateRange }\n    })\n  });\n  \n  const data = analytics || {};\n  \n  const MetricCard = ({ \n    title, \n    value, \n    change, \n    icon: Icon,\n    format = 'number'\n  }: {\n    title: string;\n    value: number;\n    change?: number;\n    icon: any;\n    format?: 'number' | 'currency' | 'percent' | 'time';\n  }) => {\n    const formatValue = (v: number) => {\n      switch (format) {\n        case 'currency':\n          return `${v.toLocaleString('ro-RO')} RON`;\n        case 'percent':\n          return `${v.toFixed(1)}%`;\n        case 'time':\n          return `${Math.floor(v / 60)}m ${v % 60}s`;\n        default:\n          return v.toLocaleString('ro-RO');\n      }\n    };\n    \n    return (\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"flex items-start justify-between\">\n            <div>\n              <p className=\"text-sm text-muted-foreground\">{title}</p>\n              <p className=\"text-2xl font-bold mt-1\">{formatValue(value)}</p>\n              {change !== undefined && (\n                <div className={`flex items-center gap-1 mt-1 text-sm ${\n                  change >= 0 ? 'text-green-600' : 'text-red-600'\n                }`}>\n                  {change >= 0 ? (\n                    <ArrowUpRight className=\"h-4 w-4\" />\n                  ) : (\n                    <ArrowDownRight className=\"h-4 w-4\" />\n                  )}\n                  <span>{Math.abs(change).toFixed(1)}%</span>\n                  <span className=\"text-muted-foreground\">vs prev</span>\n                </div>\n              )}\n            </div>\n            <div className=\"p-3 bg-primary/10 rounded-lg\">\n              <Icon className=\"h-6 w-6 text-primary\" />\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    );\n  };\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">Analytics AI Sales</h1>\n          <p className=\"text-muted-foreground\">\n            Performance și metrici agent AI\n          </p>\n        </div>\n        \n        <Select value={dateRange} onValueChange={setDateRange}>\n          <SelectTrigger className=\"w-[180px]\">\n            <SelectValue placeholder=\"Perioadă\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"7d\">Ultimele 7 zile</SelectItem>\n            <SelectItem value=\"30d\">Ultimele 30 zile</SelectItem>\n            <SelectItem value=\"90d\">Ultimele 90 zile</SelectItem>\n            <SelectItem value=\"1y\">Ultimul an</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n      \n      {/* KPI Cards */}\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n        <MetricCard\n          title=\"Conversații AI\"\n          value={data.totalConversations || 0}\n          change={data.conversationsChange}\n          icon={MessageSquare}\n        />\n        <MetricCard\n          title=\"Rată Conversie\"\n          value={data.conversionRate || 0}\n          change={data.conversionChange}\n          icon={Target}\n          format=\"percent\"\n        />\n        <MetricCard\n          title=\"Venituri AI\"\n          value={data.aiRevenue || 0}\n          change={data.revenueChange}\n          icon={DollarSign}\n          format=\"currency\"\n        />\n        <MetricCard\n          title=\"Timp Mediu Răspuns\"\n          value={data.avgResponseTime || 0}\n          change={data.responseTimeChange}\n          icon={Clock}\n          format=\"time\"\n        />\n      </div>\n      \n      {/* Charts Row 1 */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n        {/* Conversations Over Time */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Conversații în Timp</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <ResponsiveContainer width=\"100%\" height={300}>\n              <AreaChart data={data.conversationsTimeline || []}>\n                <CartesianGrid strokeDasharray=\"3 3\" />\n                <XAxis dataKey=\"date\" />\n                <YAxis />\n                <Tooltip />\n                <Legend />\n                <Area\n                  type=\"monotone\"\n                  dataKey=\"aiHandled\"\n                  stackId=\"1\"\n                  stroke=\"#3b82f6\"\n                  fill=\"#3b82f6\"\n                  name=\"AI\"\n                />\n                <Area\n                  type=\"monotone\"\n                  dataKey=\"humanHandled\"\n                  stackId=\"1\"\n                  stroke=\"#10b981\"\n                  fill=\"#10b981\"\n                  name=\"Uman\"\n                />\n              </AreaChart>\n            </ResponsiveContainer>\n          </CardContent>\n        </Card>\n        \n        {/* Conversion Funnel */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Funnel Conversie AI</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <ResponsiveContainer width=\"100%\" height={300}>\n              <BarChart data={data.funnelData || []} layout=\"vertical\">\n                <CartesianGrid strokeDasharray=\"3 3\" />\n                <XAxis type=\"number\" />\n                <YAxis dataKey=\"stage\" type=\"category\" width={120} />\n                <Tooltip />\n                <Bar dataKey=\"count\" fill=\"#3b82f6\">\n                  {(data.funnelData || []).map((entry: any, index: number) => (\n                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />\n                  ))}\n                </Bar>\n              </BarChart>\n            </ResponsiveContainer>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Charts Row 2 */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\n        {/* Intent Distribution */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Distribuție Intenții</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <ResponsiveContainer width=\"100%\" height={250}>\n              <PieChart>\n                <Pie\n                  data={data.intentDistribution || []}\n                  cx=\"50%\"\n                  cy=\"50%\"\n                  outerRadius={80}\n                  fill=\"#8884d8\"\n                  dataKey=\"count\"\n                  nameKey=\"intent\"\n                  label\n                >\n                  {(data.intentDistribution || []).map((entry: any, index: number) => (\n                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />\n                  ))}\n                </Pie>\n                <Tooltip />\n                <Legend />\n              </PieChart>\n            </ResponsiveContainer>\n          </CardContent>\n        </Card>\n        \n        {/* Guardrails Stats */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Guardrails Anti-Halucinare</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-4\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <CheckCircle className=\"h-5 w-5 text-green-500\" />\n                  <span>Validări Reușite</span>\n                </div>\n                <span className=\"font-bold\">{data.guardrails?.passed || 0}</span>\n              </div>\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <AlertTriangle className=\"h-5 w-5 text-orange-500\" />\n                  <span>Corecții Automate</span>\n                </div>\n                <span className=\"font-bold\">{data.guardrails?.corrected || 0}</span>\n              </div>\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <AlertTriangle className=\"h-5 w-5 text-red-500\" />\n                  <span>Escalări HITL</span>\n                </div>\n                <span className=\"font-bold\">{data.guardrails?.escalated || 0}</span>\n              </div>\n              <div className=\"pt-2 border-t\">\n                <div className=\"flex justify-between text-sm\">\n                  <span className=\"text-muted-foreground\">Rată Acuratețe</span>\n                  <span className=\"font-bold text-green-600\">\n                    {((data.guardrails?.passed || 0) / \n                      ((data.guardrails?.passed || 0) + (data.guardrails?.corrected || 0) + (data.guardrails?.escalated || 1)) * 100\n                    ).toFixed(1)}%\n                  </span>\n                </div>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n        \n        {/* HITL Stats */}\n        <Card>\n          <CardHeader>\n            <CardTitle>HITL Aprobări</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-4\">\n              <div className=\"flex items-center justify-between\">\n                <span>Pending</span>\n                <Badge variant=\"secondary\">{data.hitl?.pending || 0}</Badge>\n              </div>\n              <div className=\"flex items-center justify-between\">\n                <span>Aprobate</span>\n                <Badge variant=\"default\">{data.hitl?.approved || 0}</Badge>\n              </div>\n              <div className=\"flex items-center justify-between\">\n                <span>Respinse</span>\n                <Badge variant=\"destructive\">{data.hitl?.rejected || 0}</Badge>\n              </div>\n              <div className=\"flex items-center justify-between\">\n                <span>Timp Mediu Aprobare</span>\n                <span className=\"font-medium\">\n                  {Math.floor((data.hitl?.avgApprovalTime || 0) / 60)}m\n                </span>\n              </div>\n              <div className=\"flex items-center justify-between\">\n                <span>SLA Breaches</span>\n                <Badge variant={data.hitl?.slaBreaches > 0 ? 'destructive' : 'outline'}>\n                  {data.hitl?.slaBreaches || 0}\n                </Badge>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Revenue Chart */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Venituri AI vs Total</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <ResponsiveContainer width=\"100%\" height={300}>\n            <LineChart data={data.revenueTimeline || []}>\n              <CartesianGrid strokeDasharray=\"3 3\" />\n              <XAxis dataKey=\"date\" />\n              <YAxis />\n              <Tooltip />\n              <Legend />\n              <Line\n                type=\"monotone\"\n                dataKey=\"aiRevenue\"\n                stroke=\"#3b82f6\"\n                strokeWidth={2}\n                name=\"Venituri AI\"\n              />\n              <Line\n                type=\"monotone\"\n                dataKey=\"totalRevenue\"\n                stroke=\"#10b981\"\n                strokeWidth={2}\n                name=\"Total Venituri\"\n              />\n            </LineChart>\n          </ResponsiveContainer>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/analytics",
  "restrictii_antihalucinatie": [
    "CHARTS cu date reale din API",
    "KPI cards cu change indicators",
    "GUARDRAILS stats pentru monitorizare AI",
    "HITL metrics cu SLA breaches",
    "DATE RANGE selector funcțional"
  ],
  "validare_task": "1. KPI cards cu trends\n2. Charts responsive\n3. Guardrails și HITL stats\n4. Date range filtering\n5. Revenue comparison",
  "outcome": "Pagină Analytics Dashboard completă pentru AI sales performance"
}
```

## F3.16.9 Settings Configuration Pages (#82-85)

```json
{
  "taskID": "F3.16.9.T001",
  "denumire_task": "Implementare pagini Settings pentru configurare AI Agent, Pricing, Channels, și HITL",
  "context_anterior": "Analytics dashboard implementat. Acum implementăm paginile de setări.",
  "descriere_task": "Ești un expert în React și settings interfaces. Task-ul tău este să creezi paginile de configurare.\n\nCreează structura settings cu tabs:\n\n/apps/web/src/pages/settings/index.tsx:\n```tsx\nimport React from 'react';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { AIAgentSettings } from '@/components/settings/AIAgentSettings';\nimport { PricingSettings } from '@/components/settings/PricingSettings';\nimport { ChannelsSettings } from '@/components/settings/ChannelsSettings';\nimport { HITLSettings } from '@/components/settings/HITLSettings';\nimport { IntegrationsSettings } from '@/components/settings/IntegrationsSettings';\n\nexport default function SettingsPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <div>\n        <h1 className=\"text-2xl font-bold\">Setări</h1>\n        <p className=\"text-muted-foreground\">\n          Configurează parametrii AI Sales Agent și integrările\n        </p>\n      </div>\n      \n      <Tabs defaultValue=\"ai-agent\" className=\"space-y-4\">\n        <TabsList>\n          <TabsTrigger value=\"ai-agent\">AI Agent</TabsTrigger>\n          <TabsTrigger value=\"pricing\">Prețuri</TabsTrigger>\n          <TabsTrigger value=\"channels\">Canale</TabsTrigger>\n          <TabsTrigger value=\"hitl\">HITL</TabsTrigger>\n          <TabsTrigger value=\"integrations\">Integrări</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"ai-agent\">\n          <AIAgentSettings />\n        </TabsContent>\n        <TabsContent value=\"pricing\">\n          <PricingSettings />\n        </TabsContent>\n        <TabsContent value=\"channels\">\n          <ChannelsSettings />\n        </TabsContent>\n        <TabsContent value=\"hitl\">\n          <HITLSettings />\n        </TabsContent>\n        <TabsContent value=\"integrations\">\n          <IntegrationsSettings />\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n```\n\n/components/settings/AIAgentSettings.tsx:\n```tsx\nimport React from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent, CardDescription } from '@/components/ui/card';\nimport { Label } from '@/components/ui/label';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Switch } from '@/components/ui/switch';\nimport { Slider } from '@/components/ui/slider';\nimport { Textarea } from '@/components/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { useForm } from 'react-hook-form';\nimport { apiClient } from '@/lib/api-client';\nimport { toast } from 'sonner';\n\ninterface AIAgentConfig {\n  enabled: boolean;\n  modelPrimary: string;\n  modelFallback: string;\n  temperature: number;\n  maxTokens: number;\n  systemPromptTemplate: string;\n  maxRegenerations: number;\n  confidenceThreshold: number;\n  autoHandoverAfterFailures: number;\n}\n\nexport function AIAgentSettings() {\n  const queryClient = useQueryClient();\n  \n  const { data: config, isLoading } = useQuery({\n    queryKey: ['settings', 'ai-agent'],\n    queryFn: () => apiClient.get<AIAgentConfig>('/api/v1/settings/ai-agent')\n  });\n  \n  const { register, handleSubmit, setValue, watch } = useForm<AIAgentConfig>({\n    defaultValues: config\n  });\n  \n  React.useEffect(() => {\n    if (config) {\n      Object.entries(config).forEach(([key, value]) => {\n        setValue(key as keyof AIAgentConfig, value);\n      });\n    }\n  }, [config, setValue]);\n  \n  const mutation = useMutation({\n    mutationFn: (data: AIAgentConfig) => \n      apiClient.put('/api/v1/settings/ai-agent', data),\n    onSuccess: () => {\n      toast.success('Setări salvate cu succes');\n      queryClient.invalidateQueries(['settings', 'ai-agent']);\n    },\n    onError: () => toast.error('Eroare la salvare')\n  });\n  \n  const onSubmit = (data: AIAgentConfig) => mutation.mutate(data);\n  \n  if (isLoading) return <div>Se încarcă...</div>;\n  \n  return (\n    <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Configurare Generală</CardTitle>\n          <CardDescription>\n            Parametri de bază pentru AI Sales Agent\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <Label>Agent AI Activ</Label>\n              <p className=\"text-sm text-muted-foreground\">\n                Activează/dezactivează agentul AI global\n              </p>\n            </div>\n            <Switch\n              checked={watch('enabled')}\n              onCheckedChange={(checked) => setValue('enabled', checked)}\n            />\n          </div>\n          \n          <div className=\"grid grid-cols-2 gap-4\">\n            <div>\n              <Label>Model Primar</Label>\n              <Select\n                value={watch('modelPrimary')}\n                onValueChange={(v) => setValue('modelPrimary', v)}\n              >\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"gpt-4o\">GPT-4o</SelectItem>\n                  <SelectItem value=\"gpt-4o-mini\">GPT-4o Mini</SelectItem>\n                  <SelectItem value=\"claude-3-5-sonnet\">Claude 3.5 Sonnet</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n            <div>\n              <Label>Model Fallback</Label>\n              <Select\n                value={watch('modelFallback')}\n                onValueChange={(v) => setValue('modelFallback', v)}\n              >\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"gpt-4o-mini\">GPT-4o Mini</SelectItem>\n                  <SelectItem value=\"claude-3-haiku\">Claude 3 Haiku</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n      \n      <Card>\n        <CardHeader>\n          <CardTitle>Parametri LLM</CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div>\n            <Label>Temperature: {watch('temperature')}</Label>\n            <Slider\n              value={[watch('temperature') || 0.3]}\n              onValueChange={([v]) => setValue('temperature', v)}\n              min={0}\n              max={1}\n              step={0.1}\n              className=\"mt-2\"\n            />\n            <p className=\"text-sm text-muted-foreground mt-1\">\n              Valori mici = răspunsuri mai deterministe\n            </p>\n          </div>\n          \n          <div>\n            <Label>Max Tokens</Label>\n            <Input\n              type=\"number\"\n              {...register('maxTokens', { valueAsNumber: true })}\n            />\n          </div>\n          \n          <div>\n            <Label>System Prompt Template</Label>\n            <Textarea\n              {...register('systemPromptTemplate')}\n              rows={6}\n              placeholder=\"Ești un agent de vânzări specializat...\"\n            />\n          </div>\n        </CardContent>\n      </Card>\n      \n      <Card>\n        <CardHeader>\n          <CardTitle>Guardrails & Safety</CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div>\n            <Label>Max Regenerări Înainte de HITL</Label>\n            <Input\n              type=\"number\"\n              {...register('maxRegenerations', { valueAsNumber: true })}\n            />\n            <p className=\"text-sm text-muted-foreground mt-1\">\n              După acest număr, escalează automat la HITL\n            </p>\n          </div>\n          \n          <div>\n            <Label>Prag Confidență: {watch('confidenceThreshold')}</Label>\n            <Slider\n              value={[watch('confidenceThreshold') || 0.7]}\n              onValueChange={([v]) => setValue('confidenceThreshold', v)}\n              min={0.5}\n              max={0.95}\n              step={0.05}\n              className=\"mt-2\"\n            />\n          </div>\n          \n          <div>\n            <Label>Auto-Handover După Eșecuri Consecutive</Label>\n            <Input\n              type=\"number\"\n              {...register('autoHandoverAfterFailures', { valueAsNumber: true })}\n            />\n          </div>\n        </CardContent>\n      </Card>\n      \n      <div className=\"flex justify-end\">\n        <Button type=\"submit\" disabled={mutation.isPending}>\n          Salvează Setările\n        </Button>\n      </div>\n    </form>\n  );\n}\n```\n\n/components/settings/HITLSettings.tsx:\n```tsx\nimport React from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardHeader, CardTitle, CardContent, CardDescription } from '@/components/ui/card';\nimport { Label } from '@/components/ui/label';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Switch } from '@/components/ui/switch';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { useForm, useFieldArray } from 'react-hook-form';\nimport { apiClient } from '@/lib/api-client';\nimport { toast } from 'sonner';\n\ninterface HITLConfig {\n  autoApprovalEnabled: boolean;\n  autoApprovalRules: Array<{\n    type: string;\n    maxValue: number;\n    action: 'approve' | 'reject';\n  }>;\n  slaSettings: Array<{\n    type: string;\n    priority: string;\n    slaMinutes: number;\n  }>;\n  escalationLevels: Array<{\n    level: number;\n    slaPercentage: number;\n    notifyRoles: string[];\n  }>;\n  notificationChannels: {\n    email: boolean;\n    slack: boolean;\n    inApp: boolean;\n  };\n}\n\nexport function HITLSettings() {\n  const queryClient = useQueryClient();\n  \n  const { data: config, isLoading } = useQuery({\n    queryKey: ['settings', 'hitl'],\n    queryFn: () => apiClient.get<HITLConfig>('/api/v1/settings/hitl')\n  });\n  \n  const { register, control, handleSubmit, setValue, watch } = useForm<HITLConfig>({\n    defaultValues: config\n  });\n  \n  const { fields: slaFields } = useFieldArray({\n    control,\n    name: 'slaSettings'\n  });\n  \n  React.useEffect(() => {\n    if (config) {\n      Object.entries(config).forEach(([key, value]) => {\n        setValue(key as keyof HITLConfig, value);\n      });\n    }\n  }, [config, setValue]);\n  \n  const mutation = useMutation({\n    mutationFn: (data: HITLConfig) => \n      apiClient.put('/api/v1/settings/hitl', data),\n    onSuccess: () => {\n      toast.success('Setări HITL salvate');\n      queryClient.invalidateQueries(['settings', 'hitl']);\n    }\n  });\n  \n  if (isLoading) return <div>Se încarcă...</div>;\n  \n  return (\n    <form onSubmit={handleSubmit((data) => mutation.mutate(data))} className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Auto-Aprobare</CardTitle>\n          <CardDescription>\n            Configurează reguli pentru aprobări automate\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <Label>Auto-Aprobare Activă</Label>\n              <p className=\"text-sm text-muted-foreground\">\n                Permite aprobarea automată pentru anumite condiții\n              </p>\n            </div>\n            <Switch\n              checked={watch('autoApprovalEnabled')}\n              onCheckedChange={(checked) => setValue('autoApprovalEnabled', checked)}\n            />\n          </div>\n          \n          <Table>\n            <TableHeader>\n              <TableRow>\n                <TableHead>Tip Aprobare</TableHead>\n                <TableHead>Valoare Max</TableHead>\n                <TableHead>Acțiune</TableHead>\n              </TableRow>\n            </TableHeader>\n            <TableBody>\n              {(watch('autoApprovalRules') || []).map((rule, index) => (\n                <TableRow key={index}>\n                  <TableCell>{rule.type}</TableCell>\n                  <TableCell>\n                    <Input\n                      type=\"number\"\n                      {...register(`autoApprovalRules.${index}.maxValue` as const)}\n                      className=\"w-24\"\n                    />\n                  </TableCell>\n                  <TableCell>{rule.action}</TableCell>\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </CardContent>\n      </Card>\n      \n      <Card>\n        <CardHeader>\n          <CardTitle>SLA per Tip și Prioritate</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <Table>\n            <TableHeader>\n              <TableRow>\n                <TableHead>Tip</TableHead>\n                <TableHead>Prioritate</TableHead>\n                <TableHead>SLA (minute)</TableHead>\n              </TableRow>\n            </TableHeader>\n            <TableBody>\n              {slaFields.map((field, index) => (\n                <TableRow key={field.id}>\n                  <TableCell>{watch(`slaSettings.${index}.type`)}</TableCell>\n                  <TableCell>{watch(`slaSettings.${index}.priority`)}</TableCell>\n                  <TableCell>\n                    <Input\n                      type=\"number\"\n                      {...register(`slaSettings.${index}.slaMinutes` as const, { valueAsNumber: true })}\n                      className=\"w-24\"\n                    />\n                  </TableCell>\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </CardContent>\n      </Card>\n      \n      <Card>\n        <CardHeader>\n          <CardTitle>Canale Notificare</CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <Label>Email</Label>\n            <Switch\n              checked={watch('notificationChannels.email')}\n              onCheckedChange={(checked) => setValue('notificationChannels.email', checked)}\n            />\n          </div>\n          <div className=\"flex items-center justify-between\">\n            <Label>Slack</Label>\n            <Switch\n              checked={watch('notificationChannels.slack')}\n              onCheckedChange={(checked) => setValue('notificationChannels.slack', checked)}\n            />\n          </div>\n          <div className=\"flex items-center justify-between\">\n            <Label>In-App</Label>\n            <Switch\n              checked={watch('notificationChannels.inApp')}\n              onCheckedChange={(checked) => setValue('notificationChannels.inApp', checked)}\n            />\n          </div>\n        </CardContent>\n      </Card>\n      \n      <div className=\"flex justify-end\">\n        <Button type=\"submit\" disabled={mutation.isPending}>\n          Salvează Setările HITL\n        </Button>\n      </div>\n    </form>\n  );\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/web/src/pages/settings",
  "restrictii_antihalucinatie": [
    "VALIDATE all numeric inputs",
    "PERSIST settings în database",
    "TOAST notifications pentru feedback",
    "SEPARATE components per tab",
    "TYPE-SAFE forms cu react-hook-form"
  ],
  "validare_task": "1. Settings tabs navigabile\n2. Forms cu validare\n3. Save cu feedback\n4. SLA și auto-approval configurable\n5. Notification channels toggle",
  "outcome": "Pagini Settings complete pentru configurare AI și HITL"
}
```

---

# F3.17 TESTING & QA

## F3.17.1 Unit Tests - Workers Core (#86)

```json
{
  "taskID": "F3.17.1.T001",
  "denumire_task": "Implementare unit tests pentru workers core AI și FSM",
  "context_anterior": "UI/UX implementat. Acum implementăm suita de teste unitare pentru workers.",
  "descriere_task": "Ești un expert în Vitest și testing patterns. Task-ul tău este să creezi unit tests comprehensivi.\n\nCreează structura de teste:\n\n/packages/workers/src/__tests__/ai-orchestration.test.ts:\n```typescript\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { AIOrchestrationWorker } from '../workers/ai-orchestration.worker';\nimport { mockDeep, DeepMockProxy } from 'vitest-mock-extended';\nimport type { BullMQJob } from '../types';\n\n// Mock dependencies\nvi.mock('@/lib/openai', () => ({\n  openai: {\n    chat: {\n      completions: {\n        create: vi.fn()\n      }\n    }\n  }\n}));\n\nvi.mock('@/lib/db', () => ({\n  db: mockDeep()\n}));\n\ndescribe('AIOrchestrationWorker', () => {\n  let worker: AIOrchestrationWorker;\n  let mockJob: DeepMockProxy<BullMQJob>;\n  \n  beforeEach(() => {\n    worker = new AIOrchestrationWorker();\n    mockJob = mockDeep<BullMQJob>();\n    vi.clearAllMocks();\n  });\n  \n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n  \n  describe('processMessage', () => {\n    it('should process incoming message and generate AI response', async () => {\n      mockJob.data = {\n        negotiationId: 'neg-123',\n        messageContent: 'Ce pret aveti la fertilizanti?',\n        channelType: 'whatsapp'\n      };\n      \n      const { openai } = await import('@/lib/openai');\n      (openai.chat.completions.create as any).mockResolvedValue({\n        choices: [{\n          message: {\n            content: 'Avem fertilizanti NPK la 2500 RON/tonă.',\n            tool_calls: []\n          }\n        }],\n        usage: { total_tokens: 150 }\n      });\n      \n      const result = await worker.process(mockJob);\n      \n      expect(result.success).toBe(true);\n      expect(result.response).toContain('fertilizanti');\n      expect(openai.chat.completions.create).toHaveBeenCalledWith(\n        expect.objectContaining({\n          model: expect.any(String),\n          messages: expect.any(Array),\n          tools: expect.any(Array)\n        })\n      );\n    });\n    \n    it('should handle tool calls correctly', async () => {\n      mockJob.data = {\n        negotiationId: 'neg-123',\n        messageContent: 'Vreau sa comand 10 tone de NPK',\n        channelType: 'email'\n      };\n      \n      const { openai } = await import('@/lib/openai');\n      (openai.chat.completions.create as any)\n        .mockResolvedValueOnce({\n          choices: [{\n            message: {\n              content: null,\n              tool_calls: [{\n                id: 'call_1',\n                function: {\n                  name: 'check_stock',\n                  arguments: JSON.stringify({ productSku: 'NPK-001', quantity: 10 })\n                }\n              }]\n            }\n          }]\n        })\n        .mockResolvedValueOnce({\n          choices: [{\n            message: {\n              content: 'Am verificat stocul. Avem disponibile 50 tone NPK.',\n              tool_calls: []\n            }\n          }]\n        });\n      \n      const result = await worker.process(mockJob);\n      \n      expect(result.success).toBe(true);\n      expect(result.toolsUsed).toContain('check_stock');\n    });\n    \n    it('should escalate to HITL after max regenerations', async () => {\n      mockJob.data = {\n        negotiationId: 'neg-123',\n        messageContent: 'Test message',\n        regenerationCount: 3\n      };\n      \n      const result = await worker.process(mockJob);\n      \n      expect(result.escalatedToHITL).toBe(true);\n      expect(result.escalationReason).toContain('max_regenerations');\n    });\n    \n    it('should use fallback model on primary failure', async () => {\n      mockJob.data = {\n        negotiationId: 'neg-123',\n        messageContent: 'Test message'\n      };\n      \n      const { openai } = await import('@/lib/openai');\n      (openai.chat.completions.create as any)\n        .mockRejectedValueOnce(new Error('Rate limit exceeded'))\n        .mockResolvedValueOnce({\n          choices: [{\n            message: { content: 'Fallback response', tool_calls: [] }\n          }]\n        });\n      \n      const result = await worker.process(mockJob);\n      \n      expect(result.success).toBe(true);\n      expect(result.modelUsed).toBe('gpt-4o-mini');\n    });\n  });\n  \n  describe('contextBuilding', () => {\n    it('should build context within token budget', async () => {\n      const context = await worker.buildContext({\n        negotiationId: 'neg-123',\n        clientInfo: { name: 'Test Client', cui: '12345678' },\n        conversationHistory: Array(50).fill({ role: 'user', content: 'Test' }),\n        products: Array(20).fill({ name: 'Product', price: 1000 })\n      });\n      \n      expect(context.totalTokens).toBeLessThanOrEqual(4000);\n      expect(context.truncated).toBe(true);\n    });\n  });\n});\n```\n\n/packages/workers/src/__tests__/negotiation-fsm.test.ts:\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { NegotiationFSM } from '../workers/negotiation-fsm.worker';\nimport { NegotiationState } from '../types';\n\ndescribe('NegotiationFSM', () => {\n  let fsm: NegotiationFSM;\n  \n  beforeEach(() => {\n    fsm = new NegotiationFSM();\n  });\n  \n  describe('state transitions', () => {\n    it('should transition from NEW to NEEDS_DISCOVERY on greeting', () => {\n      const result = fsm.transition({\n        currentState: NegotiationState.NEW,\n        event: 'GREETING_RECEIVED',\n        context: {}\n      });\n      \n      expect(result.newState).toBe(NegotiationState.NEEDS_DISCOVERY);\n    });\n    \n    it('should transition to PRODUCT_PRESENTATION after discovery', () => {\n      const result = fsm.transition({\n        currentState: NegotiationState.NEEDS_DISCOVERY,\n        event: 'NEEDS_IDENTIFIED',\n        context: {\n          identifiedNeeds: ['fertilizanti', 'seminte']\n        }\n      });\n      \n      expect(result.newState).toBe(NegotiationState.PRODUCT_PRESENTATION);\n      expect(result.actions).toContain('SEARCH_PRODUCTS');\n    });\n    \n    it('should transition to PRICE_NEGOTIATION on price inquiry', () => {\n      const result = fsm.transition({\n        currentState: NegotiationState.PRODUCT_PRESENTATION,\n        event: 'PRICE_INQUIRY',\n        context: {\n          selectedProducts: [{ sku: 'NPK-001', quantity: 10 }]\n        }\n      });\n      \n      expect(result.newState).toBe(NegotiationState.PRICE_NEGOTIATION);\n      expect(result.actions).toContain('CALCULATE_PRICE');\n    });\n    \n    it('should require HITL for discount requests above threshold', () => {\n      const result = fsm.transition({\n        currentState: NegotiationState.PRICE_NEGOTIATION,\n        event: 'DISCOUNT_REQUESTED',\n        context: {\n          requestedDiscount: 25,\n          maxAutoDiscount: 10\n        }\n      });\n      \n      expect(result.newState).toBe(NegotiationState.AWAITING_APPROVAL);\n      expect(result.actions).toContain('CREATE_HITL_APPROVAL');\n    });\n    \n    it('should transition to WON on order confirmation', () => {\n      const result = fsm.transition({\n        currentState: NegotiationState.VERBAL_AGREEMENT,\n        event: 'ORDER_CONFIRMED',\n        context: {\n          orderId: 'ord-123'\n        }\n      });\n      \n      expect(result.newState).toBe(NegotiationState.WON);\n      expect(result.actions).toContain('CREATE_INVOICE');\n    });\n    \n    it('should transition to REQUIRES_HUMAN on complex request', () => {\n      const result = fsm.transition({\n        currentState: NegotiationState.PRICE_NEGOTIATION,\n        event: 'COMPLEX_REQUEST',\n        context: {\n          complexity: 'high',\n          reason: 'custom_terms'\n        }\n      });\n      \n      expect(result.newState).toBe(NegotiationState.REQUIRES_HUMAN);\n      expect(result.actions).toContain('REQUEST_HANDOVER');\n    });\n    \n    it('should not allow invalid transitions', () => {\n      expect(() => fsm.transition({\n        currentState: NegotiationState.WON,\n        event: 'GREETING_RECEIVED',\n        context: {}\n      })).toThrow('Invalid transition');\n    });\n  });\n  \n  describe('timeout handling', () => {\n    it('should transition to STALE after inactivity timeout', () => {\n      const result = fsm.checkTimeout({\n        currentState: NegotiationState.PRICE_NEGOTIATION,\n        lastActivityAt: new Date(Date.now() - 48 * 60 * 60 * 1000), // 48h ago\n        timeoutHours: 24\n      });\n      \n      expect(result.shouldTransition).toBe(true);\n      expect(result.newState).toBe(NegotiationState.STALE);\n    });\n  });\n});\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/__tests__",
  "restrictii_antihalucinatie": [
    "MOCK all external dependencies",
    "TEST edge cases și error paths",
    "VERIFY state transitions completeness",
    "CHECK token budget limits",
    "ASSERT HITL escalation rules"
  ],
  "validare_task": "1. All tests pass\n2. Coverage > 80%\n3. Mock isolation complete\n4. FSM transitions verified\n5. Error handling tested",
  "outcome": "Unit tests complete pentru AI și FSM workers"
}
```

## F3.17.2 Unit Tests - Guardrails & HITL (#87)

```json
{
  "taskID": "F3.17.2.T001",
  "denumire_task": "Implementare unit tests pentru guardrails anti-halucinare și HITL system",
  "context_anterior": "AI/FSM tests implementate. Acum testăm guardrails și HITL.",
  "descriere_task": "Ești un expert în testing critical systems. Task-ul tău este să creezi teste pentru safety components.\n\n/packages/workers/src/__tests__/guardrails.test.ts:\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { PriceGuardrail } from '../workers/guardrails/price.guardrail';\nimport { StockGuardrail } from '../workers/guardrails/stock.guardrail';\n\ndescribe('PriceGuardrail', () => {\n  let guardrail: PriceGuardrail;\n  \n  beforeEach(() => {\n    guardrail = new PriceGuardrail();\n  });\n  \n  describe('price extraction', () => {\n    it('should extract prices from AI response', () => {\n      const response = 'Prețul pentru NPK este 2500 RON pe tonă.';\n      const prices = guardrail.extractPrices(response);\n      \n      expect(prices).toContainEqual({\n        value: 2500,\n        unit: 'RON',\n        context: expect.any(String)\n      });\n    });\n    \n    it('should extract multiple prices', () => {\n      const response = 'NPK: 2500 RON/t, Uree: 1800 RON/t, DAP: 3200 RON/t';\n      const prices = guardrail.extractPrices(response);\n      \n      expect(prices).toHaveLength(3);\n    });\n    \n    it('should handle price ranges', () => {\n      const response = 'Prețul variază între 2000 și 2500 RON.';\n      const prices = guardrail.extractPrices(response);\n      \n      expect(prices.some(p => p.isRange)).toBe(true);\n    });\n  });\n  \n  describe('validation', () => {\n    it('should pass when price matches tool result within tolerance', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Prețul este 2500 RON.',\n        toolResults: [{ tool: 'calculate_price', result: { price: 2500 } }],\n        ragContext: [{ price: 2500 }]\n      });\n      \n      expect(result.passed).toBe(true);\n      expect(result.severity).toBe('info');\n    });\n    \n    it('should fail when price differs more than 1%', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Prețul este 2600 RON.',\n        toolResults: [{ tool: 'calculate_price', result: { price: 2500 } }],\n        ragContext: []\n      });\n      \n      expect(result.passed).toBe(false);\n      expect(result.severity).toBe('error');\n      expect(result.variance).toBeGreaterThan(0.01);\n    });\n    \n    it('should detect suspicious round numbers', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Prețul este exact 3000 RON.',\n        toolResults: [],\n        ragContext: []\n      });\n      \n      expect(result.warnings).toContain('suspicious_round_number');\n    });\n    \n    it('should detect uncertainty language', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Prețul ar putea fi în jur de 2500 RON.',\n        toolResults: [{ tool: 'calculate_price', result: { price: 2500 } }],\n        ragContext: []\n      });\n      \n      expect(result.warnings).toContain('uncertainty_detected');\n    });\n    \n    it('should escalate to critical on major discrepancy', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Prețul este 1000 RON.',\n        toolResults: [{ tool: 'calculate_price', result: { price: 2500 } }],\n        ragContext: []\n      });\n      \n      expect(result.severity).toBe('critical');\n      expect(result.shouldEscalateHITL).toBe(true);\n    });\n  });\n  \n  describe('correction prompt generation', () => {\n    it('should generate correction prompt with correct price', () => {\n      const prompt = guardrail.generateCorrectionPrompt({\n        incorrectPrice: 2600,\n        correctPrice: 2500,\n        product: 'NPK Fertilizer'\n      });\n      \n      expect(prompt).toContain('2500');\n      expect(prompt).toContain('NPK');\n      expect(prompt).not.toContain('2600');\n    });\n  });\n});\n\ndescribe('StockGuardrail', () => {\n  let guardrail: StockGuardrail;\n  \n  beforeEach(() => {\n    guardrail = new StockGuardrail();\n  });\n  \n  describe('availability claim extraction', () => {\n    it('should detect availability claims', () => {\n      const response = 'Da, avem 50 tone disponibile în stoc.';\n      const claims = guardrail.extractAvailabilityClaims(response);\n      \n      expect(claims).toContainEqual({\n        quantity: 50,\n        unit: 'tone',\n        available: true\n      });\n    });\n    \n    it('should detect unavailability claims', () => {\n      const response = 'Din păcate, nu mai avem stoc pentru acest produs.';\n      const claims = guardrail.extractAvailabilityClaims(response);\n      \n      expect(claims.some(c => c.available === false)).toBe(true);\n    });\n  });\n  \n  describe('validation', () => {\n    it('should pass when claimed stock matches actual', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Avem 50 tone disponibile.',\n        toolResults: [{ tool: 'check_stock', result: { available: 55 } }]\n      });\n      \n      expect(result.passed).toBe(true);\n    });\n    \n    it('should fail when claiming more stock than available', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Avem 100 tone disponibile.',\n        toolResults: [{ tool: 'check_stock', result: { available: 50 } }]\n      });\n      \n      expect(result.passed).toBe(false);\n      expect(result.severity).toBe('critical');\n    });\n    \n    it('should detect dangerous unconditional promises', () => {\n      const result = guardrail.validate({\n        aiResponse: 'Sigur, putem livra oricât aveți nevoie!',\n        toolResults: [{ tool: 'check_stock', result: { available: 50 } }]\n      });\n      \n      expect(result.warnings).toContain('unconditional_promise');\n      expect(result.severity).toBe('warning');\n    });\n  });\n});\n```\n\n/packages/workers/src/__tests__/hitl.test.ts:\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { HITLService } from '../services/hitl.service';\nimport { mockDeep } from 'vitest-mock-extended';\nimport { db } from '@/lib/db';\n\nvi.mock('@/lib/db', () => ({ db: mockDeep() }));\n\ndescribe('HITLService', () => {\n  let service: HITLService;\n  \n  beforeEach(() => {\n    service = new HITLService();\n    vi.clearAllMocks();\n  });\n  \n  describe('auto-approval rules', () => {\n    it('should auto-approve discounts <= 5%', async () => {\n      const result = await service.evaluateAutoApproval({\n        type: 'discount',\n        requestedValue: 5,\n        context: { negotiationId: 'neg-123' }\n      });\n      \n      expect(result.autoApproved).toBe(true);\n      expect(result.reason).toBe('within_auto_approval_threshold');\n    });\n    \n    it('should auto-reject discounts > 50%', async () => {\n      const result = await service.evaluateAutoApproval({\n        type: 'discount',\n        requestedValue: 55,\n        context: {}\n      });\n      \n      expect(result.autoRejected).toBe(true);\n      expect(result.reason).toBe('exceeds_maximum_threshold');\n    });\n    \n    it('should require manual approval for mid-range discounts', async () => {\n      const result = await service.evaluateAutoApproval({\n        type: 'discount',\n        requestedValue: 15,\n        context: {}\n      });\n      \n      expect(result.autoApproved).toBe(false);\n      expect(result.autoRejected).toBe(false);\n      expect(result.requiresManualApproval).toBe(true);\n    });\n  });\n  \n  describe('SLA calculation', () => {\n    it('should calculate correct SLA for urgent discount', () => {\n      const sla = service.calculateSLA({\n        type: 'discount',\n        priority: 'urgent'\n      });\n      \n      expect(sla.minutes).toBe(15);\n    });\n    \n    it('should calculate correct SLA for low priority content review', () => {\n      const sla = service.calculateSLA({\n        type: 'content_review',\n        priority: 'low'\n      });\n      \n      expect(sla.minutes).toBe(480); // 8 hours\n    });\n  });\n  \n  describe('escalation', () => {\n    it('should escalate to level 1 at 80% SLA', () => {\n      const escalation = service.checkEscalation({\n        slaDeadline: new Date(Date.now() + 3 * 60 * 1000), // 3 min left\n        slaMinutes: 15,\n        currentLevel: 0\n      });\n      \n      expect(escalation.shouldEscalate).toBe(true);\n      expect(escalation.newLevel).toBe(1);\n      expect(escalation.action).toBe('send_reminder');\n    });\n    \n    it('should escalate to level 2 at 90% SLA', () => {\n      const escalation = service.checkEscalation({\n        slaDeadline: new Date(Date.now() + 1.5 * 60 * 1000), // 1.5 min left\n        slaMinutes: 15,\n        currentLevel: 1\n      });\n      \n      expect(escalation.shouldEscalate).toBe(true);\n      expect(escalation.newLevel).toBe(2);\n      expect(escalation.notifyRoles).toContain('manager');\n    });\n    \n    it('should mark breach at 100% SLA', () => {\n      const escalation = service.checkEscalation({\n        slaDeadline: new Date(Date.now() - 60 * 1000), // 1 min past\n        slaMinutes: 15,\n        currentLevel: 2\n      });\n      \n      expect(escalation.breached).toBe(true);\n      expect(escalation.newLevel).toBe(3);\n      expect(escalation.notifyRoles).toContain('admin');\n    });\n  });\n  \n  describe('quorum calculation', () => {\n    it('should approve when required approvals met', () => {\n      const result = service.calculateQuorum({\n        votes: [\n          { decision: 'approve', approverRole: 'manager' },\n          { decision: 'approve', approverRole: 'manager' }\n        ],\n        requiredApprovals: 2\n      });\n      \n      expect(result.status).toBe('approved');\n    });\n    \n    it('should reject on any rejection (rejection overrides)', () => {\n      const result = service.calculateQuorum({\n        votes: [\n          { decision: 'approve', approverRole: 'manager' },\n          { decision: 'reject', approverRole: 'admin' }\n        ],\n        requiredApprovals: 2\n      });\n      \n      expect(result.status).toBe('rejected');\n      expect(result.reason).toBe('rejection_overrides');\n    });\n    \n    it('should remain pending when quorum not met', () => {\n      const result = service.calculateQuorum({\n        votes: [\n          { decision: 'approve', approverRole: 'manager' }\n        ],\n        requiredApprovals: 2\n      });\n      \n      expect(result.status).toBe('pending');\n      expect(result.remainingApprovals).toBe(1);\n    });\n  });\n});\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/workers/src/__tests__",
  "restrictii_antihalucinatie": [
    "TEST all guardrail edge cases",
    "VERIFY SLA calculations precise",
    "CHECK escalation thresholds",
    "ASSERT quorum logic correct",
    "MOCK database calls"
  ],
  "validare_task": "1. Guardrail tests comprehensive\n2. HITL auto-approval tested\n3. SLA calculations verified\n4. Escalation logic correct\n5. Quorum rules tested",
  "outcome": "Unit tests complete pentru guardrails și HITL"
}
```

## F3.17.3 Integration Tests - API Endpoints (#88)

```json
{
  "taskID": "F3.17.3.T001",
  "denumire_task": "Implementare integration tests pentru API endpoints Etapa 3",
  "context_anterior": "Unit tests complete. Acum implementăm integration tests pentru API.",
  "descriere_task": "Ești un expert în API testing. Task-ul tău este să creezi integration tests.\n\n/apps/api/src/__tests__/integration/negotiations.test.ts:\n```typescript\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { createTestServer, createAuthenticatedClient } from '../helpers/test-server';\nimport { db } from '@/lib/db';\nimport { negotiations, contacts, tenants } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\n\ndescribe('Negotiations API', () => {\n  let server: ReturnType<typeof createTestServer>;\n  let client: ReturnType<typeof createAuthenticatedClient>;\n  let testTenantId: string;\n  let testContactId: string;\n  \n  beforeAll(async () => {\n    server = await createTestServer();\n    client = createAuthenticatedClient(server);\n    \n    // Create test tenant\n    const [tenant] = await db.insert(tenants).values({\n      name: 'Test Tenant',\n      settings: {}\n    }).returning();\n    testTenantId = tenant.id;\n    \n    // Create test contact\n    const [contact] = await db.insert(contacts).values({\n      tenantId: testTenantId,\n      companyName: 'Test Company',\n      cui: '12345678',\n      tier: 'silver'\n    }).returning();\n    testContactId = contact.id;\n  });\n  \n  afterAll(async () => {\n    await db.delete(negotiations).where(eq(negotiations.tenantId, testTenantId));\n    await db.delete(contacts).where(eq(contacts.tenantId, testTenantId));\n    await db.delete(tenants).where(eq(tenants.id, testTenantId));\n    await server.close();\n  });\n  \n  describe('POST /api/v1/negotiations', () => {\n    it('should create a new negotiation', async () => {\n      const response = await client.post('/api/v1/negotiations', {\n        contactId: testContactId,\n        channelType: 'whatsapp',\n        initialMessage: 'Bună ziua, vreau să comand fertilizanți'\n      });\n      \n      expect(response.status).toBe(201);\n      expect(response.data).toMatchObject({\n        id: expect.any(String),\n        contactId: testContactId,\n        currentState: 'NEW',\n        aiEnabled: true\n      });\n    });\n    \n    it('should validate required fields', async () => {\n      const response = await client.post('/api/v1/negotiations', {\n        contactId: testContactId\n        // missing channelType\n      });\n      \n      expect(response.status).toBe(400);\n      expect(response.data.errors).toBeDefined();\n    });\n    \n    it('should queue AI processing on creation', async () => {\n      const response = await client.post('/api/v1/negotiations', {\n        contactId: testContactId,\n        channelType: 'email',\n        initialMessage: 'Test message'\n      });\n      \n      expect(response.status).toBe(201);\n      // Verify job was queued\n      const jobs = await server.getQueue('ai-orchestration').getWaiting();\n      expect(jobs.some(j => j.data.negotiationId === response.data.id)).toBe(true);\n    });\n  });\n  \n  describe('GET /api/v1/negotiations/:id', () => {\n    let negotiationId: string;\n    \n    beforeEach(async () => {\n      const [neg] = await db.insert(negotiations).values({\n        tenantId: testTenantId,\n        contactId: testContactId,\n        currentState: 'PRICE_NEGOTIATION',\n        aiEnabled: true,\n        totalValue: 50000,\n        discountPercent: 5\n      }).returning();\n      negotiationId = neg.id;\n    });\n    \n    it('should return negotiation with details', async () => {\n      const response = await client.get(`/api/v1/negotiations/${negotiationId}`);\n      \n      expect(response.status).toBe(200);\n      expect(response.data).toMatchObject({\n        id: negotiationId,\n        currentState: 'PRICE_NEGOTIATION',\n        totalValue: 50000,\n        contact: {\n          companyName: 'Test Company'\n        }\n      });\n    });\n    \n    it('should return 404 for non-existent negotiation', async () => {\n      const response = await client.get('/api/v1/negotiations/non-existent-id');\n      \n      expect(response.status).toBe(404);\n    });\n  });\n  \n  describe('PATCH /api/v1/negotiations/:id', () => {\n    let negotiationId: string;\n    \n    beforeEach(async () => {\n      const [neg] = await db.insert(negotiations).values({\n        tenantId: testTenantId,\n        contactId: testContactId,\n        currentState: 'PRICE_NEGOTIATION',\n        aiEnabled: true\n      }).returning();\n      negotiationId = neg.id;\n    });\n    \n    it('should toggle AI enabled', async () => {\n      const response = await client.patch(`/api/v1/negotiations/${negotiationId}`, {\n        aiEnabled: false\n      });\n      \n      expect(response.status).toBe(200);\n      expect(response.data.aiEnabled).toBe(false);\n    });\n    \n    it('should not allow direct state changes', async () => {\n      const response = await client.patch(`/api/v1/negotiations/${negotiationId}`, {\n        currentState: 'WON'\n      });\n      \n      expect(response.status).toBe(400);\n      expect(response.data.error).toContain('state changes must use FSM');\n    });\n  });\n  \n  describe('POST /api/v1/negotiations/:id/messages', () => {\n    let negotiationId: string;\n    \n    beforeEach(async () => {\n      const [neg] = await db.insert(negotiations).values({\n        tenantId: testTenantId,\n        contactId: testContactId,\n        currentState: 'PRICE_NEGOTIATION',\n        aiEnabled: true\n      }).returning();\n      negotiationId = neg.id;\n    });\n    \n    it('should add user message and queue AI response', async () => {\n      const response = await client.post(`/api/v1/negotiations/${negotiationId}/messages`, {\n        content: 'Ce discount puteți oferi?',\n        role: 'user'\n      });\n      \n      expect(response.status).toBe(201);\n      expect(response.data.role).toBe('user');\n      \n      // Verify AI job queued\n      const jobs = await server.getQueue('ai-orchestration').getWaiting();\n      expect(jobs.some(j => j.data.negotiationId === negotiationId)).toBe(true);\n    });\n    \n    it('should add human override message without queuing AI', async () => {\n      // First disable AI\n      await client.patch(`/api/v1/negotiations/${negotiationId}`, { aiEnabled: false });\n      \n      const response = await client.post(`/api/v1/negotiations/${negotiationId}/messages`, {\n        content: 'Mesaj manual de la agent',\n        role: 'assistant',\n        isHumanOverride: true\n      });\n      \n      expect(response.status).toBe(201);\n      expect(response.data.isHumanOverride).toBe(true);\n    });\n  });\n  \n  describe('POST /api/v1/negotiations/:id/handover', () => {\n    let negotiationId: string;\n    \n    beforeEach(async () => {\n      const [neg] = await db.insert(negotiations).values({\n        tenantId: testTenantId,\n        contactId: testContactId,\n        currentState: 'PRICE_NEGOTIATION',\n        aiEnabled: true\n      }).returning();\n      negotiationId = neg.id;\n    });\n    \n    it('should request human handover', async () => {\n      const response = await client.post(`/api/v1/negotiations/${negotiationId}/handover`, {\n        reason: 'user_request',\n        reasonDetails: 'Clientul vrea să vorbească cu un om'\n      });\n      \n      expect(response.status).toBe(200);\n      expect(response.data.currentState).toBe('REQUIRES_HUMAN');\n      expect(response.data.aiEnabled).toBe(false);\n    });\n  });\n});\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/api/src/__tests__/integration",
  "restrictii_antihalucinatie": [
    "USE real database transactions",
    "CLEANUP after each test",
    "VERIFY queue jobs created",
    "CHECK authorization",
    "TEST error responses"
  ],
  "validare_task": "1. CRUD operations tested\n2. Queue integration verified\n3. Authorization checked\n4. Error handling tested\n5. Database cleanup works",
  "outcome": "Integration tests pentru Negotiations API complete"
}
```

## F3.17.4 Integration Tests - HITL API (#89)

```json
{
  "taskID": "F3.17.4.T001",
  "denumire_task": "Implementare integration tests pentru HITL approval endpoints",
  "context_anterior": "Negotiations API tests complete. Acum testăm HITL API.",
  "descriere_task": "Ești un expert în testing approval workflows. Task-ul tău este să creezi HITL integration tests.\n\n/apps/api/src/__tests__/integration/hitl.test.ts:\n```typescript\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { createTestServer, createAuthenticatedClient } from '../helpers/test-server';\nimport { db } from '@/lib/db';\nimport { hitlApprovals, negotiations, users } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\n\ndescribe('HITL Approvals API', () => {\n  let server: ReturnType<typeof createTestServer>;\n  let managerClient: ReturnType<typeof createAuthenticatedClient>;\n  let agentClient: ReturnType<typeof createAuthenticatedClient>;\n  let testTenantId: string;\n  let testNegotiationId: string;\n  let managerId: string;\n  \n  beforeAll(async () => {\n    server = await createTestServer();\n    \n    // Create test users with different roles\n    const [manager] = await db.insert(users).values({\n      email: 'manager@test.com',\n      role: 'manager',\n      tenantId: testTenantId\n    }).returning();\n    managerId = manager.id;\n    \n    managerClient = createAuthenticatedClient(server, { role: 'manager', userId: managerId });\n    agentClient = createAuthenticatedClient(server, { role: 'agent' });\n  });\n  \n  describe('GET /api/v1/hitl/approvals', () => {\n    beforeEach(async () => {\n      // Create test approvals\n      await db.insert(hitlApprovals).values([\n        {\n          tenantId: testTenantId,\n          negotiationId: testNegotiationId,\n          approvalType: 'discount',\n          requestedValue: { discountPercent: 15 },\n          priority: 'high',\n          status: 'pending'\n        },\n        {\n          tenantId: testTenantId,\n          negotiationId: testNegotiationId,\n          approvalType: 'content_review',\n          requestedValue: { content: 'Test content' },\n          priority: 'low',\n          status: 'pending'\n        }\n      ]);\n    });\n    \n    it('should list pending approvals for manager', async () => {\n      const response = await managerClient.get('/api/v1/hitl/approvals', {\n        params: { status: 'pending' }\n      });\n      \n      expect(response.status).toBe(200);\n      expect(response.data.items.length).toBeGreaterThan(0);\n      expect(response.data.items[0]).toMatchObject({\n        approvalType: expect.any(String),\n        status: 'pending'\n      });\n    });\n    \n    it('should include stats in response', async () => {\n      const response = await managerClient.get('/api/v1/hitl/approvals');\n      \n      expect(response.data.stats).toMatchObject({\n        pending: expect.any(Number),\n        urgent: expect.any(Number)\n      });\n    });\n  });\n  \n  describe('POST /api/v1/hitl/approvals/:id/process', () => {\n    let approvalId: string;\n    \n    beforeEach(async () => {\n      const [approval] = await db.insert(hitlApprovals).values({\n        tenantId: testTenantId,\n        negotiationId: testNegotiationId,\n        approvalType: 'discount',\n        requestedValue: { discountPercent: 15 },\n        currentValue: { discountPercent: 5 },\n        priority: 'high',\n        status: 'pending',\n        slaDeadline: new Date(Date.now() + 60 * 60 * 1000),\n        approverIds: [managerId]\n      }).returning();\n      approvalId = approval.id;\n    });\n    \n    it('should approve discount request', async () => {\n      const response = await managerClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'approve',\n        comment: 'Aprobat pentru client important'\n      });\n      \n      expect(response.status).toBe(200);\n      expect(response.data.status).toBe('approved');\n      expect(response.data.votes).toContainEqual(\n        expect.objectContaining({\n          approverId: managerId,\n          decision: 'approve'\n        })\n      );\n    });\n    \n    it('should reject discount request', async () => {\n      const response = await managerClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'reject',\n        comment: 'Discount prea mare pentru valoarea comenzii'\n      });\n      \n      expect(response.status).toBe(200);\n      expect(response.data.status).toBe('rejected');\n    });\n    \n    it('should approve with modified value', async () => {\n      const response = await managerClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'approve',\n        modifiedValue: { discountPercent: 10 },\n        comment: 'Aprobat cu discount redus'\n      });\n      \n      expect(response.status).toBe(200);\n      expect(response.data.approvedValue.discountPercent).toBe(10);\n    });\n    \n    it('should not allow non-approver to process', async () => {\n      const response = await agentClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'approve'\n      });\n      \n      expect(response.status).toBe(403);\n    });\n    \n    it('should not allow duplicate votes', async () => {\n      // First vote\n      await managerClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'approve'\n      });\n      \n      // Second vote attempt\n      const response = await managerClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'reject'\n      });\n      \n      expect(response.status).toBe(400);\n      expect(response.data.error).toContain('already voted');\n    });\n    \n    it('should resume AI after approval on discount', async () => {\n      // Disable AI first\n      await db.update(negotiations)\n        .set({ aiEnabled: false })\n        .where(eq(negotiations.id, testNegotiationId));\n      \n      await managerClient.post(`/api/v1/hitl/approvals/${approvalId}/process`, {\n        decision: 'approve'\n      });\n      \n      // Check AI was re-enabled\n      const [neg] = await db.select()\n        .from(negotiations)\n        .where(eq(negotiations.id, testNegotiationId));\n      \n      expect(neg.aiEnabled).toBe(true);\n    });\n  });\n});\n```",
  "director_implementare": "/var/www/CerniqAPP/apps/api/src/__tests__/integration",
  "restrictii_antihalucinatie": [
    "TEST role-based access",
    "VERIFY vote deduplication",
    "CHECK SLA tracking",
    "ASSERT AI resume logic",
    "VALIDATE modified values"
  ],
  "validare_task": "1. Approval flow tested\n2. Authorization enforced\n3. Vote logic correct\n4. AI resume works\n5. Modified values handled",
  "outcome": "Integration tests pentru HITL API complete"
}
```

## F3.17.5 E2E Tests - Complete AI Sales Flow (#90)

```json
{
  "taskID": "F3.17.5.T001",
  "denumire_task": "Implementare E2E tests pentru flow complet AI sales cu Playwright",
  "context_anterior": "Integration tests complete. Acum implementăm E2E tests.",
  "descriere_task": "Ești un expert în Playwright E2E testing. Task-ul tău este să creezi teste end-to-end.\n\n/e2e/tests/ai-sales-flow.spec.ts:\n```typescript\nimport { test, expect, Page } from '@playwright/test';\n\ntest.describe('AI Sales Complete Flow', () => {\n  let page: Page;\n  \n  test.beforeAll(async ({ browser }) => {\n    page = await browser.newPage();\n    // Login as sales agent\n    await page.goto('/login');\n    await page.fill('[name=\"email\"]', 'agent@test.com');\n    await page.fill('[name=\"password\"]', 'testpassword');\n    await page.click('button[type=\"submit\"]');\n    await page.waitForURL('/dashboard');\n  });\n  \n  test.afterAll(async () => {\n    await page.close();\n  });\n  \n  test('should complete full negotiation cycle', async () => {\n    // 1. Navigate to AI Dashboard\n    await page.click('text=AI Agent');\n    await expect(page).toHaveURL(/\\/ai-agent/);\n    \n    // 2. Verify dashboard loads\n    await expect(page.locator('text=Conversații Active')).toBeVisible();\n    \n    // 3. Click on active conversation\n    await page.click('[data-testid=\"conversation-item\"]');\n    await expect(page).toHaveURL(/\\/negotiations\\//);\n    \n    // 4. Verify chat interface\n    await expect(page.locator('[data-testid=\"chat-messages\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"ai-status-badge\"]')).toContainText('Activ');\n    \n    // 5. Send a test message (simulating customer)\n    await page.fill('[data-testid=\"message-input\"]', 'Ce pret aveti la NPK?');\n    await page.click('[data-testid=\"send-button\"]');\n    \n    // 6. Wait for AI response\n    await expect(page.locator('[data-testid=\"ai-response\"]').last()).toBeVisible({ timeout: 30000 });\n    \n    // 7. Verify guardrail indicator\n    await expect(page.locator('[data-testid=\"guardrail-status\"]').last()).toContainText('OK');\n  });\n  \n  test('should handle discount approval flow', async () => {\n    // Navigate to a negotiation in price stage\n    await page.goto('/negotiations/test-negotiation-id');\n    \n    // Simulate discount request\n    await page.fill('[data-testid=\"message-input\"]', 'Vreau un discount de 20%');\n    await page.click('[data-testid=\"send-button\"]');\n    \n    // AI should trigger HITL\n    await expect(page.locator('text=Aprobare Pending')).toBeVisible({ timeout: 30000 });\n    \n    // Go to approvals page\n    await page.click('text=Coadă Aprobări');\n    \n    // Find the approval\n    await expect(page.locator('[data-testid=\"approval-item\"]').first()).toBeVisible();\n    \n    // Open approval detail\n    await page.click('text=Procesează');\n    \n    // Verify approval dialog\n    await expect(page.locator('[data-testid=\"approval-dialog\"]')).toBeVisible();\n    await expect(page.locator('text=Aprobare Discount')).toBeVisible();\n    \n    // Approve with modification\n    await page.click('text=Aprobă');\n    await page.fill('[data-testid=\"modified-value-input\"]', '15');\n    await page.fill('[data-testid=\"comment-input\"]', 'Aprobat cu 15% în loc de 20%');\n    await page.click('text=Confirmă Decizia');\n    \n    // Verify approval processed\n    await expect(page.locator('text=Aprobate')).toBeVisible();\n  });\n  \n  test('should handle human handover', async () => {\n    await page.goto('/negotiations/test-negotiation-id');\n    \n    // Click handover button\n    await page.click('[data-testid=\"handover-button\"]');\n    \n    // Fill handover reason\n    await expect(page.locator('[data-testid=\"handover-dialog\"]')).toBeVisible();\n    await page.fill('[data-testid=\"handover-reason\"]', 'Client solicită conversație umană');\n    await page.click('text=Transferă');\n    \n    // Verify AI disabled\n    await expect(page.locator('[data-testid=\"ai-status-badge\"]')).toContainText('Oprit');\n    await expect(page.locator('text=AI Agent dezactivat')).toBeVisible();\n    \n    // Verify can send manual message\n    await page.fill('[data-testid=\"message-input\"]', 'Bună ziua, sunt agentul uman.');\n    await page.click('[data-testid=\"send-button\"]');\n    \n    await expect(page.locator('[data-testid=\"human-message\"]').last()).toBeVisible();\n  });\n  \n  test('should display analytics correctly', async () => {\n    await page.goto('/analytics');\n    \n    // Verify KPI cards\n    await expect(page.locator('text=Conversații AI')).toBeVisible();\n    await expect(page.locator('text=Rată Conversie')).toBeVisible();\n    await expect(page.locator('text=Venituri AI')).toBeVisible();\n    \n    // Verify charts load\n    await expect(page.locator('[data-testid=\"conversations-chart\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"funnel-chart\"]')).toBeVisible();\n    \n    // Change date range\n    await page.click('[data-testid=\"date-range-select\"]');\n    await page.click('text=Ultimele 30 zile');\n    \n    // Verify data updates\n    await expect(page.locator('[data-testid=\"loading-indicator\"]')).toBeHidden();\n  });\n  \n  test('should handle product search with RAG', async () => {\n    await page.goto('/negotiations/test-negotiation-id');\n    \n    // Send product inquiry\n    await page.fill('[data-testid=\"message-input\"]', 'Ce fertilizanti aveti pentru porumb?');\n    await page.click('[data-testid=\"send-button\"]');\n    \n    // Wait for AI response with product suggestions\n    await expect(page.locator('[data-testid=\"ai-response\"]').last()).toBeVisible({ timeout: 30000 });\n    \n    // Verify response contains product information\n    const responseText = await page.locator('[data-testid=\"ai-response\"]').last().textContent();\n    expect(responseText).toMatch(/fertiliz|NPK|uree|porumb/i);\n  });\n});\n\ntest.describe('HITL Approval Queue', () => {\n  test.beforeEach(async ({ page }) => {\n    await page.goto('/login');\n    await page.fill('[name=\"email\"]', 'manager@test.com');\n    await page.fill('[name=\"password\"]', 'testpassword');\n    await page.click('button[type=\"submit\"]');\n  });\n  \n  test('should show urgent approvals prominently', async ({ page }) => {\n    await page.goto('/hitl/approvals');\n    \n    // Verify urgent badge visible\n    await expect(page.locator('[data-testid=\"urgent-count\"]')).toBeVisible();\n    \n    // Verify urgent items have visual indicator\n    const urgentItem = page.locator('[data-testid=\"approval-item\"][data-priority=\"urgent\"]').first();\n    await expect(urgentItem).toHaveClass(/urgent|destructive/);\n  });\n  \n  test('should show SLA countdown', async ({ page }) => {\n    await page.goto('/hitl/approvals');\n    \n    // Find item with SLA\n    const slaIndicator = page.locator('[data-testid=\"sla-indicator\"]').first();\n    await expect(slaIndicator).toBeVisible();\n    \n    // Verify countdown format\n    const text = await slaIndicator.textContent();\n    expect(text).toMatch(/\\d+\\s*(min|h|sec|minute|oră)/i);\n  });\n});\n```",
  "director_implementare": "/var/www/CerniqAPP/e2e/tests",
  "restrictii_antihalucinatie": [
    "TEST complete user flows",
    "VERIFY AI responses appear",
    "CHECK HITL approval process",
    "VALIDATE analytics display",
    "TIMEOUT sufficient for AI"
  ],
  "validare_task": "1. Full negotiation flow works\n2. HITL approval tested\n3. Handover works\n4. Analytics loads\n5. Product search functional",
  "outcome": "E2E tests complete pentru AI sales flow"
}
```

## F3.17.6 Load Tests - AI & Queue Performance (#91)

```json
{
  "taskID": "F3.17.6.T001",
  "denumire_task": "Implementare load tests pentru AI processing și queue performance cu k6",
  "context_anterior": "E2E tests complete. Acum implementăm load tests pentru scalabilitate.",
  "descriere_task": "Ești un expert în k6 load testing. Task-ul tău este să creezi performance tests.\n\n/load-tests/ai-orchestration.js:\n```javascript\nimport http from 'k6/http';\nimport { check, sleep, group } from 'k6';\nimport { Counter, Trend, Rate } from 'k6/metrics';\n\n// Custom metrics\nconst aiResponseTime = new Trend('ai_response_time');\nconst aiSuccessRate = new Rate('ai_success_rate');\nconst guardrailFailures = new Counter('guardrail_failures');\nconst hitlEscalations = new Counter('hitl_escalations');\n\nexport const options = {\n  scenarios: {\n    // Smoke test\n    smoke: {\n      executor: 'constant-vus',\n      vus: 5,\n      duration: '1m',\n      tags: { scenario: 'smoke' }\n    },\n    // Load test\n    load: {\n      executor: 'ramping-vus',\n      startVUs: 0,\n      stages: [\n        { duration: '2m', target: 20 },\n        { duration: '5m', target: 20 },\n        { duration: '2m', target: 50 },\n        { duration: '5m', target: 50 },\n        { duration: '2m', target: 0 }\n      ],\n      tags: { scenario: 'load' }\n    },\n    // Stress test\n    stress: {\n      executor: 'ramping-arrival-rate',\n      startRate: 10,\n      timeUnit: '1s',\n      preAllocatedVUs: 50,\n      maxVUs: 200,\n      stages: [\n        { duration: '2m', target: 20 },\n        { duration: '5m', target: 50 },\n        { duration: '2m', target: 100 },\n        { duration: '5m', target: 100 },\n        { duration: '5m', target: 0 }\n      ],\n      tags: { scenario: 'stress' }\n    }\n  },\n  thresholds: {\n    http_req_duration: ['p(95)<5000'], // 95% under 5s\n    ai_response_time: ['p(95)<10000'], // AI response under 10s\n    ai_success_rate: ['rate>0.95'], // 95% success rate\n    http_req_failed: ['rate<0.05'] // Error rate under 5%\n  }\n};\n\nconst BASE_URL = __ENV.BASE_URL || 'http://localhost:3000';\nconst AUTH_TOKEN = __ENV.AUTH_TOKEN;\n\nexport function setup() {\n  // Create test negotiation for load testing\n  const res = http.post(`${BASE_URL}/api/v1/negotiations`, JSON.stringify({\n    contactId: 'load-test-contact',\n    channelType: 'web_chat',\n    initialMessage: 'Load test initial'\n  }), {\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${AUTH_TOKEN}`\n    }\n  });\n  \n  return { negotiationId: JSON.parse(res.body).id };\n}\n\nexport default function(data) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${AUTH_TOKEN}`\n  };\n  \n  group('AI Message Processing', () => {\n    const startTime = new Date();\n    \n    // Send message\n    const messages = [\n      'Ce produse aveti pentru porumb?',\n      'Cat costa fertilizantul NPK?',\n      'Aveti stoc pentru 50 de tone?',\n      'Pot primi un discount de 10%?',\n      'Vreau sa fac o comanda'\n    ];\n    const message = messages[Math.floor(Math.random() * messages.length)];\n    \n    const sendRes = http.post(\n      `${BASE_URL}/api/v1/negotiations/${data.negotiationId}/messages`,\n      JSON.stringify({ content: message, role: 'user' }),\n      { headers, tags: { name: 'send_message' } }\n    );\n    \n    check(sendRes, {\n      'message sent': (r) => r.status === 201\n    });\n    \n    // Poll for AI response (simulating real-world wait)\n    let attempts = 0;\n    let aiResponded = false;\n    \n    while (attempts < 30 && !aiResponded) { // Max 30s wait\n      sleep(1);\n      \n      const getRes = http.get(\n        `${BASE_URL}/api/v1/negotiations/${data.negotiationId}/messages?limit=1`,\n        { headers, tags: { name: 'poll_response' } }\n      );\n      \n      if (getRes.status === 200) {\n        const messages = JSON.parse(getRes.body).items;\n        if (messages.length > 0 && messages[0].role === 'assistant') {\n          aiResponded = true;\n          \n          const endTime = new Date();\n          aiResponseTime.add(endTime - startTime);\n          aiSuccessRate.add(1);\n          \n          // Check guardrail status\n          if (messages[0].guardrailPassed === false) {\n            guardrailFailures.add(1);\n          }\n          \n          // Check HITL escalation\n          if (messages[0].escalatedToHITL) {\n            hitlEscalations.add(1);\n          }\n        }\n      }\n      attempts++;\n    }\n    \n    if (!aiResponded) {\n      aiSuccessRate.add(0);\n    }\n  });\n  \n  group('Product Search RAG', () => {\n    const searchRes = http.get(\n      `${BASE_URL}/api/v1/products/search?q=fertilizant%20porumb&limit=10`,\n      { headers, tags: { name: 'product_search' } }\n    );\n    \n    check(searchRes, {\n      'search successful': (r) => r.status === 200,\n      'results returned': (r) => JSON.parse(r.body).items.length > 0\n    });\n  });\n  \n  group('HITL Queue Operations', () => {\n    // Get pending approvals\n    const queueRes = http.get(\n      `${BASE_URL}/api/v1/hitl/approvals?status=pending`,\n      { headers, tags: { name: 'hitl_queue' } }\n    );\n    \n    check(queueRes, {\n      'queue accessible': (r) => r.status === 200\n    });\n  });\n  \n  sleep(1); // Pacing\n}\n\nexport function teardown(data) {\n  // Cleanup test negotiation\n  http.del(`${BASE_URL}/api/v1/negotiations/${data.negotiationId}`, null, {\n    headers: {\n      'Authorization': `Bearer ${AUTH_TOKEN}`\n    }\n  });\n}\n```\n\n/load-tests/queue-stress.js:\n```javascript\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\nimport { Counter, Gauge } from 'k6/metrics';\n\nconst queueDepth = new Gauge('queue_depth');\nconst jobsProcessed = new Counter('jobs_processed');\n\nexport const options = {\n  scenarios: {\n    queue_burst: {\n      executor: 'constant-arrival-rate',\n      rate: 100, // 100 requests per second\n      timeUnit: '1s',\n      duration: '5m',\n      preAllocatedVUs: 100,\n      maxVUs: 500\n    }\n  },\n  thresholds: {\n    http_req_duration: ['p(99)<2000'],\n    queue_depth: ['max<10000']\n  }\n};\n\nexport default function() {\n  // Simulate high-volume message ingestion\n  const res = http.post(`${__ENV.BASE_URL}/api/v1/webhooks/whatsapp`, \n    JSON.stringify({\n      from: `+4072${Math.floor(Math.random() * 10000000)}`,\n      body: 'Test message for queue stress',\n      timestamp: new Date().toISOString()\n    }),\n    { headers: { 'Content-Type': 'application/json' } }\n  );\n  \n  check(res, { 'queued successfully': (r) => r.status === 202 });\n  \n  // Monitor queue depth\n  const metricsRes = http.get(`${__ENV.BASE_URL}/api/v1/admin/queue-metrics`);\n  if (metricsRes.status === 200) {\n    const metrics = JSON.parse(metricsRes.body);\n    queueDepth.add(metrics.aiOrchestration.waiting);\n    jobsProcessed.add(metrics.aiOrchestration.completed);\n  }\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/load-tests",
  "restrictii_antihalucinatie": [
    "MEASURE AI response times",
    "TRACK guardrail failures",
    "MONITOR queue depth",
    "CHECK error rates",
    "VALIDATE throughput"
  ],
  "validare_task": "1. Smoke/load/stress scenarios work\n2. Custom metrics tracked\n3. Thresholds appropriate\n4. Queue stress tested\n5. Performance baseline established",
  "outcome": "Load tests complete pentru AI și queue performance"
}
```

---

## F3.18 INTEGRARE ȘI DEPLOYMENT

### F3.18.1 Docker Configuration (#92)

```json
{
  "taskID": "F3.18.1.T001",
  "denumire_task": "Configurare Docker pentru servicii Etapa 3",
  "context_anterior": "Testing complet. Acum pregătim deployment-ul containerizat.",
  "descriere_task": "Ești un expert în Docker și containerizare. Task-ul tău este să creezi configurația Docker pentru Etapa 3.\n\nCreează docker-compose.etapa3.yaml:\n```yaml\n# docker-compose.etapa3.yaml\n# Etapa 3 - AI Sales Agent Services\nversion: '3.9'\n\nservices:\n  # ==========================================\n  # AI ORCHESTRATION WORKERS\n  # ==========================================\n  \n  worker-ai-orchestration:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.ai\n      args:\n        NODE_ENV: production\n    image: cerniq/worker-ai-orchestration:${VERSION:-latest}\n    container_name: cerniq-worker-ai-orchestration\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      qdrant:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - QDRANT_URL=http://qdrant:6333\n      - OPENAI_API_KEY=${OPENAI_API_KEY}\n      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}\n      - PRIMARY_MODEL=${PRIMARY_MODEL:-gpt-4o}\n      - FALLBACK_MODEL=${FALLBACK_MODEL:-gpt-4o-mini}\n      - MAX_TOKENS=${MAX_TOKENS:-4096}\n      - TEMPERATURE=${TEMPERATURE:-0.7}\n      - MAX_REGENERATIONS=${MAX_REGENERATIONS:-3}\n      - WORKER_CONCURRENCY=${AI_WORKER_CONCURRENCY:-5}\n      - QUEUE_NAME=ai-orchestration\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n      - OTEL_EXPORTER_OTLP_ENDPOINT=http://signoz:4317\n    volumes:\n      - ./logs/workers/ai:/app/logs\n      - ./config/prompts:/app/config/prompts:ro\n    networks:\n      - cerniq-internal\n    deploy:\n      resources:\n        limits:\n          cpus: '2.0'\n          memory: 4G\n        reservations:\n          cpus: '0.5'\n          memory: 1G\n    healthcheck:\n      test: [\"CMD\", \"node\", \"/app/healthcheck.js\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n    labels:\n      - \"com.cerniq.service=worker-ai-orchestration\"\n      - \"com.cerniq.etapa=3\"\n      - \"prometheus.scrape=true\"\n      - \"prometheus.port=9090\"\n\n  worker-negotiation-fsm:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.workers\n    image: cerniq/worker-negotiation-fsm:${VERSION:-latest}\n    container_name: cerniq-worker-negotiation-fsm\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - WORKER_CONCURRENCY=${FSM_WORKER_CONCURRENCY:-10}\n      - QUEUE_NAME=negotiation-fsm\n      - FSM_TIMEOUT_HOURS=${FSM_TIMEOUT_HOURS:-24}\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n      - OTEL_EXPORTER_OTLP_ENDPOINT=http://signoz:4317\n    volumes:\n      - ./logs/workers/fsm:/app/logs\n    networks:\n      - cerniq-internal\n    deploy:\n      resources:\n        limits:\n          cpus: '1.0'\n          memory: 1G\n        reservations:\n          cpus: '0.25'\n          memory: 256M\n    healthcheck:\n      test: [\"CMD\", \"node\", \"/app/healthcheck.js\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  worker-guardrails:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.workers\n    image: cerniq/worker-guardrails:${VERSION:-latest}\n    container_name: cerniq-worker-guardrails\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - WORKER_CONCURRENCY=${GUARDRAILS_CONCURRENCY:-8}\n      - QUEUE_NAME=guardrails-validation\n      - PRICE_VARIANCE_THRESHOLD=${PRICE_VARIANCE_THRESHOLD:-0.01}\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    volumes:\n      - ./logs/workers/guardrails:/app/logs\n    networks:\n      - cerniq-internal\n    deploy:\n      resources:\n        limits:\n          cpus: '1.0'\n          memory: 1G\n\n  worker-hitl:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.workers\n    image: cerniq/worker-hitl:${VERSION:-latest}\n    container_name: cerniq-worker-hitl\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - WORKER_CONCURRENCY=${HITL_CONCURRENCY:-5}\n      - QUEUE_NAME=hitl-processing\n      - HITL_SLA_CRITICAL_MINUTES=${HITL_SLA_CRITICAL:-30}\n      - HITL_SLA_HIGH_MINUTES=${HITL_SLA_HIGH:-120}\n      - HITL_SLA_NORMAL_MINUTES=${HITL_SLA_NORMAL:-480}\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    volumes:\n      - ./logs/workers/hitl:/app/logs\n    networks:\n      - cerniq-internal\n\n  # ==========================================\n  # DOCUMENT GENERATION WORKERS\n  # ==========================================\n  \n  worker-document-gen:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.documents\n    image: cerniq/worker-document-gen:${VERSION:-latest}\n    container_name: cerniq-worker-document-gen\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      minio:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - MINIO_ENDPOINT=minio:9000\n      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}\n      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}\n      - MINIO_BUCKET=documents\n      - WORKER_CONCURRENCY=${DOC_GEN_CONCURRENCY:-3}\n      - QUEUE_NAME=document-generation\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    volumes:\n      - ./logs/workers/documents:/app/logs\n      - ./templates:/app/templates:ro\n    networks:\n      - cerniq-internal\n    deploy:\n      resources:\n        limits:\n          cpus: '1.0'\n          memory: 2G\n\n  worker-oblio:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.workers\n    image: cerniq/worker-oblio:${VERSION:-latest}\n    container_name: cerniq-worker-oblio\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - OBLIO_API_KEY=${OBLIO_API_KEY}\n      - OBLIO_API_SECRET=${OBLIO_API_SECRET}\n      - OBLIO_CIF=${COMPANY_CIF}\n      - WORKER_CONCURRENCY=${OBLIO_CONCURRENCY:-3}\n      - QUEUE_NAME=oblio-invoicing\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    volumes:\n      - ./logs/workers/oblio:/app/logs\n    networks:\n      - cerniq-internal\n      - cerniq-external\n\n  worker-efactura:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.workers\n    image: cerniq/worker-efactura:${VERSION:-latest}\n    container_name: cerniq-worker-efactura\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - ANAF_OAUTH_CLIENT_ID=${ANAF_OAUTH_CLIENT_ID}\n      - ANAF_OAUTH_CLIENT_SECRET=${ANAF_OAUTH_CLIENT_SECRET}\n      - ANAF_SPV_ENDPOINT=${ANAF_SPV_ENDPOINT:-https://api.anaf.ro/prod/FCTEL/rest}\n      - COMPANY_CIF=${COMPANY_CIF}\n      - WORKER_CONCURRENCY=${EFACTURA_CONCURRENCY:-2}\n      - QUEUE_NAME=efactura-submission\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    volumes:\n      - ./logs/workers/efactura:/app/logs\n      - ./certs/anaf:/app/certs:ro\n    networks:\n      - cerniq-internal\n      - cerniq-external\n    secrets:\n      - anaf_certificate\n\n  # ==========================================\n  # RAG & VECTOR SERVICES\n  # ==========================================\n  \n  worker-rag-embedding:\n    build:\n      context: ./packages/workers\n      dockerfile: Dockerfile.rag\n    image: cerniq/worker-rag-embedding:${VERSION:-latest}\n    container_name: cerniq-worker-rag-embedding\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      qdrant:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - QDRANT_URL=http://qdrant:6333\n      - QDRANT_COLLECTION=products\n      - OPENAI_API_KEY=${OPENAI_API_KEY}\n      - EMBEDDING_MODEL=${EMBEDDING_MODEL:-text-embedding-3-small}\n      - EMBEDDING_DIMENSIONS=${EMBEDDING_DIMENSIONS:-1536}\n      - CHUNK_SIZE=${CHUNK_SIZE:-512}\n      - CHUNK_OVERLAP=${CHUNK_OVERLAP:-50}\n      - WORKER_CONCURRENCY=${RAG_CONCURRENCY:-3}\n      - QUEUE_NAME=rag-embedding\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    volumes:\n      - ./logs/workers/rag:/app/logs\n    networks:\n      - cerniq-internal\n    deploy:\n      resources:\n        limits:\n          cpus: '1.0'\n          memory: 2G\n\n  qdrant:\n    image: qdrant/qdrant:v1.12.6\n    container_name: cerniq-qdrant\n    restart: unless-stopped\n    ports:\n      - \"127.0.0.1:6333:6333\"\n      - \"127.0.0.1:6334:6334\"\n    volumes:\n      - qdrant_data:/qdrant/storage\n      - ./config/qdrant:/qdrant/config:ro\n    environment:\n      - QDRANT__SERVICE__GRPC_PORT=6334\n      - QDRANT__SERVICE__HTTP_PORT=6333\n      - QDRANT__STORAGE__ON_DISK_PAYLOAD=true\n    networks:\n      - cerniq-internal\n    deploy:\n      resources:\n        limits:\n          cpus: '2.0'\n          memory: 4G\n        reservations:\n          cpus: '0.5'\n          memory: 1G\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:6333/readyz\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # ==========================================\n  # MCP SERVER\n  # ==========================================\n  \n  mcp-server:\n    build:\n      context: ./packages/mcp-server\n      dockerfile: Dockerfile\n    image: cerniq/mcp-server:${VERSION:-latest}\n    container_name: cerniq-mcp-server\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      qdrant:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://cerniq:${DB_PASSWORD}@postgres:5432/cerniq_prod\n      - REDIS_URL=redis://redis:6379\n      - QDRANT_URL=http://qdrant:6333\n      - MCP_SERVER_PORT=3100\n      - MCP_AUTH_TOKEN=${MCP_AUTH_TOKEN}\n      - LOG_LEVEL=${LOG_LEVEL:-info}\n    ports:\n      - \"127.0.0.1:3100:3100\"\n    volumes:\n      - ./logs/mcp:/app/logs\n    networks:\n      - cerniq-internal\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3100/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n# ==========================================\n# VOLUMES\n# ==========================================\nvolumes:\n  qdrant_data:\n    driver: local\n    driver_opts:\n      type: none\n      o: bind\n      device: /data/qdrant\n\n# ==========================================\n# NETWORKS\n# ==========================================\nnetworks:\n  cerniq-internal:\n    external: true\n  cerniq-external:\n    external: true\n\n# ==========================================\n# SECRETS\n# ==========================================\nsecrets:\n  anaf_certificate:\n    file: ./certs/anaf/certificate.p12\n```",
  "director_implementare": "/var/www/CerniqAPP/docker",
  "restrictii_antihalucinatie": [
    "USE exact version tags",
    "CONFIGURE resource limits",
    "IMPLEMENT health checks",
    "SEPARATE networks properly",
    "SECURE secrets handling"
  ],
  "validare_task": "1. All services defined\n2. Health checks working\n3. Resource limits appropriate\n4. Networks separated\n5. Secrets secure",
  "outcome": "Docker configuration complet pentru Etapa 3"
}
```

### F3.18.2 Environment Configuration (#93)

```json
{
  "taskID": "F3.18.2.T001",
  "denumire_task": "Configurare environment variables și secrets pentru Etapa 3",
  "context_anterior": "Docker compose definit. Acum configurăm variabilele de mediu.",
  "descriere_task": "Ești un expert în securitate și configuration management. Task-ul tău este să definești toate environment variables.\n\nCreează .env.etapa3.example:\n```bash\n# ============================================\n# ETAPA 3 - AI SALES AGENT CONFIGURATION\n# ============================================\n# Copy to .env.etapa3 and fill in values\n# NEVER commit .env.etapa3 to version control\n# ============================================\n\n# ============================================\n# AI MODEL CONFIGURATION\n# ============================================\n\n# OpenAI Configuration\nOPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxx\nOPENAI_ORG_ID=org-xxxxxxxxxxxx\n\n# Anthropic Configuration (fallback)\nANTHROPIC_API_KEY=sk-ant-xxxxxxxxxxxx\n\n# Model Selection\nPRIMARY_MODEL=gpt-4o\nFALLBACK_MODEL=gpt-4o-mini\nEMBEDDING_MODEL=text-embedding-3-small\n\n# Model Parameters\nMAX_TOKENS=4096\nTEMPERATURE=0.7\nTOP_P=0.9\nFREQUENCY_PENALTY=0.0\nPRESENCE_PENALTY=0.0\n\n# AI Safety Parameters\nMAX_REGENERATIONS=3\nCONFIDENCE_THRESHOLD=0.8\nAUTO_HANDOVER_THRESHOLD=0.6\n\n# ============================================\n# RAG CONFIGURATION\n# ============================================\n\n# Qdrant Vector Database\nQDRANT_URL=http://qdrant:6333\nQDRANT_COLLECTION=products\nQDRANT_API_KEY=\n\n# Embedding Configuration\nEMBEDDING_DIMENSIONS=1536\nCHUNK_SIZE=512\nCHUNK_OVERLAP=50\n\n# Hybrid Search Weights\nSEMANTIC_WEIGHT=0.7\nKEYWORD_WEIGHT=0.3\nTOP_K_RESULTS=10\n\n# ============================================\n# HITL CONFIGURATION\n# ============================================\n\n# SLA Configuration (minutes)\nHITL_SLA_CRITICAL=30\nHITL_SLA_HIGH=120\nHITL_SLA_NORMAL=480\nHITL_SLA_LOW=1440\n\n# Auto-Approval Rules\nAUTO_APPROVE_MAX_DISCOUNT_PERCENT=5\nAUTO_REJECT_MIN_DISCOUNT_PERCENT=50\nAUTO_APPROVE_MAX_CREDIT_DAYS=30\n\n# Escalation Configuration\nESCALATION_LEVEL_1_PERCENT=80\nESCALATION_LEVEL_2_PERCENT=90\nESCALATION_LEVEL_3_PERCENT=100\n\n# Quorum Configuration\nQUORUM_REQUIRED=2\nQUORUM_REJECTION_OVERRIDE=true\n\n# ============================================\n# GUARDRAILS CONFIGURATION\n# ============================================\n\n# Price Validation\nPRICE_VARIANCE_THRESHOLD=0.01\nMAX_DISCOUNT_WITHOUT_APPROVAL=10\nSUSPICIOUS_ROUND_NUMBER_DETECTION=true\n\n# Stock Validation\nSTOCK_SAFETY_BUFFER_PERCENT=10\nALLOW_BACKORDER=false\nREQUIRE_STOCK_CHECK=true\n\n# Compliance Validation\nFORBIDDEN_TERMS=garantie 100%,promitem,cel mai bun pret\nREQUIRE_LEGAL_DISCLAIMERS=true\n\n# ============================================\n# NEGOTIATION FSM CONFIGURATION\n# ============================================\n\n# Timeout Configuration (hours)\nFSM_TIMEOUT_NEW=48\nFSM_TIMEOUT_DISCOVERY=72\nFSM_TIMEOUT_NEGOTIATION=24\nFSM_TIMEOUT_AGREEMENT=12\n\n# State Transition Settings\nALLOW_SKIP_DISCOVERY=false\nREQUIRE_VERBAL_AGREEMENT=true\nAUTO_CLOSE_STALE=true\n\n# ============================================\n# INVOICING CONFIGURATION\n# ============================================\n\n# Oblio Configuration\nOBLIO_API_KEY=xxxxxxxxxxxx\nOBLIO_API_SECRET=xxxxxxxxxxxx\nOBLIO_CIF=RO12345678\nOBLIO_SERIES_NAME=CRQ\nOBLIO_WORKSTATION_NAME=Sediu\n\n# ANAF e-Factura Configuration\nANAF_OAUTH_CLIENT_ID=xxxxxxxxxxxx\nANAF_OAUTH_CLIENT_SECRET=xxxxxxxxxxxx\nANAF_SPV_ENDPOINT=https://api.anaf.ro/prod/FCTEL/rest\nANAF_TOKEN_ENDPOINT=https://logincert.anaf.ro/anaf-oauth2/v1/token\nANAF_CERTIFICATE_PATH=/app/certs/certificate.p12\nANAF_CERTIFICATE_PASSWORD=xxxxxxxxxxxx\n\n# Company Information\nCOMPANY_CIF=RO12345678\nCOMPANY_NAME=Compania Agricola SRL\nCOMPANY_ADDRESS=Str. Exemplu nr. 1, Bucuresti\nCOMPANY_REG_COM=J40/1234/2020\nCOMPANY_BANK_ACCOUNT=RO12XXXX0000000012345678\nCOMPANY_BANK_NAME=Banca Transilvania\n\n# ============================================\n# DOCUMENT GENERATION CONFIGURATION\n# ============================================\n\n# MinIO Object Storage\nMINIO_ENDPOINT=minio:9000\nMINIO_ACCESS_KEY=xxxxxxxxxxxx\nMINIO_SECRET_KEY=xxxxxxxxxxxx\nMINIO_BUCKET=documents\nMINIO_USE_SSL=false\n\n# Template Paths\nTEMPLATE_DIR=/app/templates\nOFFER_TEMPLATE=offer_template.docx\nINVOICE_TEMPLATE=invoice_template.docx\nCONTRACT_TEMPLATE=contract_template.docx\n\n# PDF Generation\nPDF_QUALITY=high\nPDF_INCLUDE_WATERMARK=false\n\n# ============================================\n# MCP SERVER CONFIGURATION\n# ============================================\n\nMCP_SERVER_PORT=3100\nMCP_AUTH_TOKEN=xxxxxxxxxxxx\nMCP_ENABLE_TOOLS=search_products,get_pricing,check_stock,get_client,create_proposal\nMCP_RATE_LIMIT_PER_MINUTE=100\n\n# ============================================\n# WORKER CONCURRENCY SETTINGS\n# ============================================\n\nAI_WORKER_CONCURRENCY=5\nFSM_WORKER_CONCURRENCY=10\nGUARDRAILS_CONCURRENCY=8\nHITL_CONCURRENCY=5\nDOC_GEN_CONCURRENCY=3\nOBLIO_CONCURRENCY=3\nEFACTURA_CONCURRENCY=2\nRAG_CONCURRENCY=3\n\n# ============================================\n# QUEUE CONFIGURATION\n# ============================================\n\n# BullMQ Settings\nBULLMQ_PREFIX=cerniq:etapa3\nBULLMQ_DEFAULT_ATTEMPTS=3\nBULLMQ_BACKOFF_TYPE=exponential\nBULLMQ_BACKOFF_DELAY=1000\n\n# Queue-specific Settings\nAI_QUEUE_TIMEOUT_MS=60000\nGUARDRAILS_QUEUE_TIMEOUT_MS=30000\nHITL_QUEUE_TIMEOUT_MS=300000\nDOC_GEN_QUEUE_TIMEOUT_MS=120000\n\n# ============================================\n# NOTIFICATION CHANNELS\n# ============================================\n\n# Email Notifications\nSMTP_HOST=smtp.example.com\nSMTP_PORT=587\nSMTP_USER=notifications@cerniq.app\nSMTP_PASSWORD=xxxxxxxxxxxx\nSMTP_FROM=Cerniq AI <notifications@cerniq.app>\n\n# Slack Notifications\nSLACK_WEBHOOK_URL=https://hooks.slack.com/services/xxx/xxx/xxx\nSLACK_CHANNEL=#cerniq-alerts\n\n# WebSocket Configuration\nWS_ENABLED=true\nWS_HEARTBEAT_INTERVAL=30000\n\n# ============================================\n# MONITORING & OBSERVABILITY\n# ============================================\n\n# OpenTelemetry\nOTEL_EXPORTER_OTLP_ENDPOINT=http://signoz:4317\nOTEL_SERVICE_NAME=cerniq-etapa3\nOTEL_TRACES_SAMPLER=parentbased_traceidratio\nOTEL_TRACES_SAMPLER_ARG=0.1\n\n# Prometheus Metrics\nMETRICS_PORT=9090\nMETRICS_PATH=/metrics\n\n# Logging\nLOG_LEVEL=info\nLOG_FORMAT=json\nLOG_INCLUDE_TIMESTAMP=true\n\n# ============================================\n# FEATURE FLAGS\n# ============================================\n\nFEATURE_AI_ENABLED=true\nFEATURE_HITL_REQUIRED=true\nFEATURE_AUTO_APPROVAL=true\nFEATURE_EFACTURA_ENABLED=true\nFEATURE_MCP_ENABLED=true\nFEATURE_WEBSOCKET_ENABLED=true\n\n# ============================================\n# RATE LIMITING\n# ============================================\n\n# API Rate Limits (per minute)\nRATE_LIMIT_NEGOTIATIONS_CREATE=10\nRATE_LIMIT_MESSAGES_SEND=60\nRATE_LIMIT_PRODUCTS_SEARCH=100\nRATE_LIMIT_HITL_PROCESS=30\n\n# AI Cost Caps (daily)\nAI_DAILY_COST_CAP_USD=100\nAI_MONTHLY_COST_CAP_USD=2000\nAI_ALERT_THRESHOLD_PERCENT=80\n```",
  "director_implementare": "/var/www/CerniqAPP",
  "restrictii_antihalucinatie": [
    "NEVER commit actual secrets",
    "USE example values only",
    "DOCUMENT all variables",
    "GROUP logically",
    "INCLUDE sensible defaults"
  ],
  "validare_task": "1. All variables documented\n2. Groups logical\n3. Defaults sensible\n4. Security considered\n5. Example file complete",
  "outcome": "Environment configuration template complet"
}
```

### F3.18.3 Database Migrations (#94)

```json
{
  "taskID": "F3.18.3.T001",
  "denumire_task": "Migrări database pentru Etapa 3",
  "context_anterior": "Environment configurat. Acum pregătim migrările database.",
  "descriere_task": "Ești un expert în Drizzle ORM și PostgreSQL migrations. Task-ul tău este să creezi migrările pentru Etapa 3.\n\nCreează /packages/database/drizzle/migrations/0030_etapa3_init.sql:\n```sql\n-- Migration: 0030_etapa3_init\n-- Description: Initialize Etapa 3 AI Sales Agent tables\n-- Date: 2026-01-XX\n-- Author: Cerniq Development Team\n\nBEGIN;\n\n-- ============================================\n-- PRODUCT KNOWLEDGE SCHEMA\n-- ============================================\n\n-- Product Categories Extension\nALTER TABLE products ADD COLUMN IF NOT EXISTS \n  embedding_status VARCHAR(20) DEFAULT 'pending'\n  CHECK (embedding_status IN ('pending', 'processing', 'completed', 'failed'));\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  embedding_updated_at TIMESTAMPTZ;\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  search_keywords TSVECTOR;\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  ai_summary TEXT;\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  safety_data_sheet_url VARCHAR(500);\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  application_instructions TEXT;\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  compatible_crops JSONB DEFAULT '[]';\n\nALTER TABLE products ADD COLUMN IF NOT EXISTS\n  seasonality JSONB DEFAULT '{}';\n\n-- Product Embeddings Table\nCREATE TABLE IF NOT EXISTS product_embeddings (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,\n  chunk_index INTEGER NOT NULL,\n  chunk_text TEXT NOT NULL,\n  embedding_vector VECTOR(1536),\n  metadata JSONB DEFAULT '{}',\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  \n  UNIQUE(product_id, chunk_index)\n);\n\nCREATE INDEX idx_product_embeddings_tenant ON product_embeddings(tenant_id);\nCREATE INDEX idx_product_embeddings_product ON product_embeddings(product_id);\nCREATE INDEX idx_product_embeddings_vector ON product_embeddings \n  USING ivfflat (embedding_vector vector_cosine_ops) WITH (lists = 100);\n\n-- ============================================\n-- AI CONVERSATIONS SCHEMA\n-- ============================================\n\n-- AI Conversations Table\nCREATE TABLE IF NOT EXISTS ai_conversations (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  negotiation_id UUID REFERENCES negotiations(id),\n  contact_id UUID REFERENCES contacts(id),\n  channel_type VARCHAR(20) NOT NULL CHECK (channel_type IN ('whatsapp', 'email', 'web', 'phone')),\n  external_thread_id VARCHAR(255),\n  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'paused', 'closed', 'archived')),\n  ai_enabled BOOLEAN DEFAULT true,\n  assigned_agent_id UUID REFERENCES users(id),\n  context_summary TEXT,\n  total_messages INTEGER DEFAULT 0,\n  total_ai_responses INTEGER DEFAULT 0,\n  total_tokens_used INTEGER DEFAULT 0,\n  total_cost_usd NUMERIC(10, 4) DEFAULT 0,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  closed_at TIMESTAMPTZ,\n  \n  UNIQUE(tenant_id, external_thread_id)\n);\n\nCREATE INDEX idx_ai_conversations_tenant ON ai_conversations(tenant_id);\nCREATE INDEX idx_ai_conversations_negotiation ON ai_conversations(negotiation_id);\nCREATE INDEX idx_ai_conversations_contact ON ai_conversations(contact_id);\nCREATE INDEX idx_ai_conversations_status ON ai_conversations(tenant_id, status);\nCREATE INDEX idx_ai_conversations_channel ON ai_conversations(tenant_id, channel_type);\n\n-- AI Messages Table\nCREATE TABLE IF NOT EXISTS ai_messages (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  conversation_id UUID NOT NULL REFERENCES ai_conversations(id) ON DELETE CASCADE,\n  role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),\n  content TEXT NOT NULL,\n  tool_calls JSONB DEFAULT '[]',\n  tool_results JSONB DEFAULT '[]',\n  model_used VARCHAR(50),\n  tokens_input INTEGER,\n  tokens_output INTEGER,\n  cost_usd NUMERIC(10, 6),\n  latency_ms INTEGER,\n  guardrail_results JSONB DEFAULT '{}',\n  hitl_required BOOLEAN DEFAULT false,\n  hitl_approval_id UUID,\n  regeneration_count INTEGER DEFAULT 0,\n  is_edited BOOLEAN DEFAULT false,\n  edited_by UUID REFERENCES users(id),\n  edited_at TIMESTAMPTZ,\n  original_content TEXT,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  \n  CONSTRAINT fk_hitl_approval FOREIGN KEY (hitl_approval_id) \n    REFERENCES hitl_approvals(id) ON DELETE SET NULL\n);\n\nCREATE INDEX idx_ai_messages_conversation ON ai_messages(conversation_id);\nCREATE INDEX idx_ai_messages_tenant ON ai_messages(tenant_id);\nCREATE INDEX idx_ai_messages_created ON ai_messages(conversation_id, created_at);\nCREATE INDEX idx_ai_messages_hitl ON ai_messages(hitl_approval_id) WHERE hitl_approval_id IS NOT NULL;\n\n-- ============================================\n-- NEGOTIATION FSM SCHEMA\n-- ============================================\n\n-- Extend negotiations table\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  fsm_state VARCHAR(30) DEFAULT 'new'\n  CHECK (fsm_state IN (\n    'new', 'needs_discovery', 'product_presentation', 'price_negotiation',\n    'verbal_agreement', 'proposal_sent', 'awaiting_approval', 'won',\n    'lost', 'stale', 'requires_human'\n  ));\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  fsm_context JSONB DEFAULT '{}';\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  ai_confidence_score NUMERIC(3, 2);\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  identified_needs JSONB DEFAULT '[]';\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  recommended_products JSONB DEFAULT '[]';\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  pricing_snapshot JSONB;\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  discount_applied NUMERIC(5, 2) DEFAULT 0;\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  last_ai_activity_at TIMESTAMPTZ;\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  handover_reason TEXT;\n\nALTER TABLE negotiations ADD COLUMN IF NOT EXISTS\n  handover_at TIMESTAMPTZ;\n\nCREATE INDEX idx_negotiations_fsm_state ON negotiations(tenant_id, fsm_state);\nCREATE INDEX idx_negotiations_ai_activity ON negotiations(tenant_id, last_ai_activity_at);\n\n-- FSM Transition History\nCREATE TABLE IF NOT EXISTS fsm_transitions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  negotiation_id UUID NOT NULL REFERENCES negotiations(id) ON DELETE CASCADE,\n  from_state VARCHAR(30) NOT NULL,\n  to_state VARCHAR(30) NOT NULL,\n  event_type VARCHAR(50) NOT NULL,\n  event_data JSONB DEFAULT '{}',\n  triggered_by VARCHAR(20) CHECK (triggered_by IN ('ai', 'human', 'system', 'timeout')),\n  user_id UUID REFERENCES users(id),\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_fsm_transitions_negotiation ON fsm_transitions(negotiation_id);\nCREATE INDEX idx_fsm_transitions_tenant ON fsm_transitions(tenant_id);\nCREATE INDEX idx_fsm_transitions_created ON fsm_transitions(negotiation_id, created_at);\n\n-- ============================================\n-- GUARDRAILS SCHEMA\n-- ============================================\n\nCREATE TABLE IF NOT EXISTS guardrail_validations (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  message_id UUID NOT NULL REFERENCES ai_messages(id) ON DELETE CASCADE,\n  guardrail_type VARCHAR(30) NOT NULL \n    CHECK (guardrail_type IN ('price', 'stock', 'compliance', 'intent', 'safety')),\n  status VARCHAR(20) NOT NULL \n    CHECK (status IN ('passed', 'warning', 'failed', 'corrected')),\n  severity VARCHAR(20) \n    CHECK (severity IN ('low', 'medium', 'high', 'critical')),\n  original_value TEXT,\n  expected_value TEXT,\n  actual_value TEXT,\n  variance_percent NUMERIC(10, 4),\n  correction_applied TEXT,\n  details JSONB DEFAULT '{}',\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_guardrail_validations_message ON guardrail_validations(message_id);\nCREATE INDEX idx_guardrail_validations_tenant ON guardrail_validations(tenant_id);\nCREATE INDEX idx_guardrail_validations_type ON guardrail_validations(tenant_id, guardrail_type);\nCREATE INDEX idx_guardrail_validations_status ON guardrail_validations(tenant_id, status);\n\n-- ============================================\n-- PRICING & PROPOSALS SCHEMA\n-- ============================================\n\nCREATE TABLE IF NOT EXISTS proposals (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  negotiation_id UUID NOT NULL REFERENCES negotiations(id),\n  contact_id UUID NOT NULL REFERENCES contacts(id),\n  document_number VARCHAR(50) NOT NULL,\n  status VARCHAR(20) DEFAULT 'draft'\n    CHECK (status IN ('draft', 'sent', 'viewed', 'accepted', 'rejected', 'expired')),\n  version INTEGER DEFAULT 1,\n  valid_until DATE NOT NULL,\n  subtotal NUMERIC(12, 2) NOT NULL,\n  discount_percent NUMERIC(5, 2) DEFAULT 0,\n  discount_amount NUMERIC(12, 2) DEFAULT 0,\n  tax_percent NUMERIC(5, 2) DEFAULT 19,\n  tax_amount NUMERIC(12, 2) NOT NULL,\n  total NUMERIC(12, 2) NOT NULL,\n  currency VARCHAR(3) DEFAULT 'RON',\n  payment_terms TEXT,\n  delivery_terms TEXT,\n  notes TEXT,\n  document_url VARCHAR(500),\n  pdf_url VARCHAR(500),\n  sent_at TIMESTAMPTZ,\n  viewed_at TIMESTAMPTZ,\n  responded_at TIMESTAMPTZ,\n  created_by UUID REFERENCES users(id),\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  \n  UNIQUE(tenant_id, document_number)\n);\n\nCREATE INDEX idx_proposals_tenant ON proposals(tenant_id);\nCREATE INDEX idx_proposals_negotiation ON proposals(negotiation_id);\nCREATE INDEX idx_proposals_contact ON proposals(contact_id);\nCREATE INDEX idx_proposals_status ON proposals(tenant_id, status);\n\nCREATE TABLE IF NOT EXISTS proposal_items (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  proposal_id UUID NOT NULL REFERENCES proposals(id) ON DELETE CASCADE,\n  product_id UUID REFERENCES products(id),\n  sku VARCHAR(50),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  quantity NUMERIC(12, 3) NOT NULL,\n  unit VARCHAR(20) NOT NULL,\n  unit_price NUMERIC(12, 2) NOT NULL,\n  discount_percent NUMERIC(5, 2) DEFAULT 0,\n  line_total NUMERIC(12, 2) NOT NULL,\n  sort_order INTEGER DEFAULT 0,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_proposal_items_proposal ON proposal_items(proposal_id);\nCREATE INDEX idx_proposal_items_product ON proposal_items(product_id);\n\n-- ============================================\n-- INVOICING SCHEMA\n-- ============================================\n\nCREATE TABLE IF NOT EXISTS invoices (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  negotiation_id UUID REFERENCES negotiations(id),\n  proposal_id UUID REFERENCES proposals(id),\n  contact_id UUID NOT NULL REFERENCES contacts(id),\n  invoice_number VARCHAR(50) NOT NULL,\n  invoice_date DATE NOT NULL,\n  due_date DATE NOT NULL,\n  status VARCHAR(20) DEFAULT 'draft'\n    CHECK (status IN ('draft', 'issued', 'sent', 'paid', 'overdue', 'cancelled')),\n  subtotal NUMERIC(12, 2) NOT NULL,\n  discount_amount NUMERIC(12, 2) DEFAULT 0,\n  tax_amount NUMERIC(12, 2) NOT NULL,\n  total NUMERIC(12, 2) NOT NULL,\n  currency VARCHAR(3) DEFAULT 'RON',\n  payment_method VARCHAR(50),\n  payment_reference VARCHAR(100),\n  paid_at TIMESTAMPTZ,\n  paid_amount NUMERIC(12, 2),\n  \n  -- Oblio Integration\n  oblio_doc_id VARCHAR(100),\n  oblio_series VARCHAR(20),\n  oblio_number INTEGER,\n  oblio_link VARCHAR(500),\n  oblio_synced_at TIMESTAMPTZ,\n  \n  -- e-Factura Integration\n  efactura_id VARCHAR(100),\n  efactura_upload_index VARCHAR(50),\n  efactura_status VARCHAR(30)\n    CHECK (efactura_status IN ('pending', 'in_prelucrare', 'ok', 'nok', 'eroare_validare')),\n  efactura_download_id VARCHAR(100),\n  efactura_error_message TEXT,\n  efactura_xml_url VARCHAR(500),\n  efactura_submitted_at TIMESTAMPTZ,\n  efactura_response_at TIMESTAMPTZ,\n  \n  pdf_url VARCHAR(500),\n  xml_url VARCHAR(500),\n  notes TEXT,\n  created_by UUID REFERENCES users(id),\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  \n  UNIQUE(tenant_id, invoice_number)\n);\n\nCREATE INDEX idx_invoices_tenant ON invoices(tenant_id);\nCREATE INDEX idx_invoices_negotiation ON invoices(negotiation_id);\nCREATE INDEX idx_invoices_contact ON invoices(contact_id);\nCREATE INDEX idx_invoices_status ON invoices(tenant_id, status);\nCREATE INDEX idx_invoices_efactura ON invoices(tenant_id, efactura_status);\nCREATE INDEX idx_invoices_due ON invoices(tenant_id, due_date) WHERE status NOT IN ('paid', 'cancelled');\n\nCREATE TABLE IF NOT EXISTS invoice_items (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,\n  product_id UUID REFERENCES products(id),\n  sku VARCHAR(50),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  quantity NUMERIC(12, 3) NOT NULL,\n  unit VARCHAR(20) NOT NULL,\n  unit_price NUMERIC(12, 2) NOT NULL,\n  tax_percent NUMERIC(5, 2) DEFAULT 19,\n  line_total NUMERIC(12, 2) NOT NULL,\n  sort_order INTEGER DEFAULT 0,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_invoice_items_invoice ON invoice_items(invoice_id);\n\n-- ============================================\n-- EXTEND HITL SCHEMA FOR ETAPA 3\n-- ============================================\n\n-- Add Etapa 3 specific approval types\nALTER TABLE hitl_approvals \n  DROP CONSTRAINT IF EXISTS hitl_approvals_approval_type_check;\n  \nALTER TABLE hitl_approvals \n  ADD CONSTRAINT hitl_approvals_approval_type_check \n  CHECK (approval_type IN (\n    -- Etapa 1\n    'email_validation', 'phone_validation', 'company_merge', 'data_enrichment',\n    -- Etapa 2  \n    'message_content', 'template_selection', 'send_timing', 'sequence_override',\n    -- Etapa 3\n    'ai_response', 'discount_approval', 'credit_terms', 'proposal_content',\n    'invoice_issue', 'price_override', 'stock_override', 'handover_request'\n  ));\n\n-- ============================================\n-- AI ANALYTICS SCHEMA\n-- ============================================\n\nCREATE TABLE IF NOT EXISTS ai_analytics_daily (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID NOT NULL REFERENCES tenants(id),\n  date DATE NOT NULL,\n  \n  -- Conversation Metrics\n  total_conversations INTEGER DEFAULT 0,\n  new_conversations INTEGER DEFAULT 0,\n  closed_conversations INTEGER DEFAULT 0,\n  avg_conversation_duration_minutes NUMERIC(10, 2),\n  \n  -- Message Metrics\n  total_messages INTEGER DEFAULT 0,\n  ai_messages INTEGER DEFAULT 0,\n  human_messages INTEGER DEFAULT 0,\n  avg_response_time_seconds NUMERIC(10, 2),\n  \n  -- AI Performance\n  total_ai_calls INTEGER DEFAULT 0,\n  successful_ai_calls INTEGER DEFAULT 0,\n  failed_ai_calls INTEGER DEFAULT 0,\n  total_tokens_used INTEGER DEFAULT 0,\n  total_cost_usd NUMERIC(10, 4) DEFAULT 0,\n  avg_confidence_score NUMERIC(3, 2),\n  \n  -- Guardrails\n  guardrail_checks INTEGER DEFAULT 0,\n  guardrail_passes INTEGER DEFAULT 0,\n  guardrail_corrections INTEGER DEFAULT 0,\n  guardrail_escalations INTEGER DEFAULT 0,\n  \n  -- HITL\n  hitl_requests INTEGER DEFAULT 0,\n  hitl_approved INTEGER DEFAULT 0,\n  hitl_rejected INTEGER DEFAULT 0,\n  hitl_modified INTEGER DEFAULT 0,\n  avg_hitl_response_time_minutes NUMERIC(10, 2),\n  \n  -- Conversion\n  negotiations_started INTEGER DEFAULT 0,\n  negotiations_won INTEGER DEFAULT 0,\n  negotiations_lost INTEGER DEFAULT 0,\n  total_revenue NUMERIC(14, 2) DEFAULT 0,\n  \n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  \n  UNIQUE(tenant_id, date)\n);\n\nCREATE INDEX idx_ai_analytics_daily_tenant ON ai_analytics_daily(tenant_id);\nCREATE INDEX idx_ai_analytics_daily_date ON ai_analytics_daily(tenant_id, date);\n\n-- ============================================\n-- FUNCTIONS\n-- ============================================\n\n-- Function to update AI conversation stats\nCREATE OR REPLACE FUNCTION update_ai_conversation_stats()\nRETURNS TRIGGER AS $$\nBEGIN\n  UPDATE ai_conversations\n  SET \n    total_messages = total_messages + 1,\n    total_ai_responses = CASE WHEN NEW.role = 'assistant' THEN total_ai_responses + 1 ELSE total_ai_responses END,\n    total_tokens_used = total_tokens_used + COALESCE(NEW.tokens_input, 0) + COALESCE(NEW.tokens_output, 0),\n    total_cost_usd = total_cost_usd + COALESCE(NEW.cost_usd, 0),\n    updated_at = NOW()\n  WHERE id = NEW.conversation_id;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_ai_conversation_stats\nAFTER INSERT ON ai_messages\nFOR EACH ROW\nEXECUTE FUNCTION update_ai_conversation_stats();\n\n-- Function to update product search vectors\nCREATE OR REPLACE FUNCTION update_product_search_vector()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.search_keywords := \n    setweight(to_tsvector('romanian', COALESCE(NEW.name, '')), 'A') ||\n    setweight(to_tsvector('romanian', COALESCE(NEW.description, '')), 'B') ||\n    setweight(to_tsvector('romanian', COALESCE(NEW.sku, '')), 'A') ||\n    setweight(to_tsvector('romanian', COALESCE(NEW.brand, '')), 'B');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_product_search_vector\nBEFORE INSERT OR UPDATE OF name, description, sku, brand ON products\nFOR EACH ROW\nEXECUTE FUNCTION update_product_search_vector();\n\n-- ============================================\n-- ENABLE EXTENSIONS\n-- ============================================\n\nCREATE EXTENSION IF NOT EXISTS vector;\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\n\nCOMMIT;\n```",
  "director_implementare": "/var/www/CerniqAPP/packages/database/drizzle/migrations",
  "restrictii_antihalucinatie": [
    "USE transactions for safety",
    "ADD indexes for performance",
    "IMPLEMENT proper constraints",
    "CREATE triggers for automation",
    "MAINTAIN referential integrity"
  ],
  "validare_task": "1. Migration runs without errors\n2. All tables created\n3. Indexes optimal\n4. Constraints enforced\n5. Functions working",
  "outcome": "Database migration complet pentru Etapa 3"
}
```

### F3.18.4 CI/CD Pipeline (#95)

```json
{
  "taskID": "F3.18.4.T001",
  "denumire_task": "Pipeline CI/CD pentru Etapa 3",
  "context_anterior": "Database migrations definite. Acum configurăm CI/CD.",
  "descriere_task": "Ești un expert în GitHub Actions și CI/CD. Task-ul tău este să creezi pipeline-ul pentru Etapa 3.\n\nCreează .github/workflows/etapa3-ci.yaml:\n```yaml\nname: Etapa 3 - AI Sales Agent CI/CD\n\non:\n  push:\n    branches: [main, develop]\n    paths:\n      - 'packages/workers/src/etapa3/**'\n      - 'packages/api/src/routes/etapa3/**'\n      - 'packages/frontend/src/pages/etapa3/**'\n      - 'packages/mcp-server/**'\n      - 'docker/etapa3/**'\n      - '.github/workflows/etapa3-ci.yaml'\n  pull_request:\n    branches: [main, develop]\n    paths:\n      - 'packages/workers/src/etapa3/**'\n      - 'packages/api/src/routes/etapa3/**'\n      - 'packages/frontend/src/pages/etapa3/**'\n      - 'packages/mcp-server/**'\n\nenv:\n  NODE_VERSION: '24.x'\n  PNPM_VERSION: '9'\n  REGISTRY: ghcr.io\n  IMAGE_PREFIX: ghcr.io/${{ github.repository }}\n\njobs:\n  # ==========================================\n  # LINT & TYPE CHECK\n  # ==========================================\n  lint:\n    name: Lint & Type Check\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup pnpm\n        uses: pnpm/action-setup@v3\n        with:\n          version: ${{ env.PNPM_VERSION }}\n          \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'pnpm'\n          \n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n        \n      - name: Run ESLint\n        run: pnpm lint:etapa3\n        \n      - name: Run TypeScript check\n        run: pnpm typecheck:etapa3\n        \n      - name: Check formatting\n        run: pnpm format:check\n\n  # ==========================================\n  # UNIT TESTS\n  # ==========================================\n  unit-tests:\n    name: Unit Tests\n    runs-on: ubuntu-latest\n    needs: lint\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup pnpm\n        uses: pnpm/action-setup@v3\n        with:\n          version: ${{ env.PNPM_VERSION }}\n          \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'pnpm'\n          \n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n        \n      - name: Run unit tests\n        run: pnpm test:etapa3:unit --coverage\n        \n      - name: Upload coverage\n        uses: codecov/codecov-action@v4\n        with:\n          files: ./coverage/etapa3/lcov.info\n          flags: etapa3-unit\n          fail_ci_if_error: false\n\n  # ==========================================\n  # INTEGRATION TESTS\n  # ==========================================\n  integration-tests:\n    name: Integration Tests\n    runs-on: ubuntu-latest\n    needs: lint\n    services:\n      postgres:\n        image: postgres:18\n        env:\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: test\n          POSTGRES_DB: cerniq_test\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n          \n      redis:\n        image: redis:7-alpine\n        ports:\n          - 6379:6379\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n          \n      qdrant:\n        image: qdrant/qdrant:v1.12.6\n        ports:\n          - 6333:6333\n        options: >-\n          --health-cmd \"curl -f http://localhost:6333/readyz\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n          \n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup pnpm\n        uses: pnpm/action-setup@v3\n        with:\n          version: ${{ env.PNPM_VERSION }}\n          \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'pnpm'\n          \n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n        \n      - name: Run migrations\n        run: pnpm db:migrate:test\n        env:\n          DATABASE_URL: postgresql://test:test@localhost:5432/cerniq_test\n          \n      - name: Run integration tests\n        run: pnpm test:etapa3:integration\n        env:\n          DATABASE_URL: postgresql://test:test@localhost:5432/cerniq_test\n          REDIS_URL: redis://localhost:6379\n          QDRANT_URL: http://localhost:6333\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_TEST }}\n\n  # ==========================================\n  # E2E TESTS\n  # ==========================================\n  e2e-tests:\n    name: E2E Tests\n    runs-on: ubuntu-latest\n    needs: [unit-tests, integration-tests]\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup pnpm\n        uses: pnpm/action-setup@v3\n        with:\n          version: ${{ env.PNPM_VERSION }}\n          \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'pnpm'\n          \n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n        \n      - name: Install Playwright browsers\n        run: pnpm exec playwright install --with-deps chromium\n        \n      - name: Start services\n        run: docker compose -f docker-compose.test.yaml up -d\n        \n      - name: Wait for services\n        run: |\n          timeout 60 bash -c 'until curl -f http://localhost:3000/health; do sleep 2; done'\n          \n      - name: Run E2E tests\n        run: pnpm test:etapa3:e2e\n        env:\n          BASE_URL: http://localhost:3000\n          \n      - name: Upload test artifacts\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: playwright-report\n          path: playwright-report/\n          retention-days: 7\n          \n      - name: Stop services\n        if: always()\n        run: docker compose -f docker-compose.test.yaml down\n\n  # ==========================================\n  # BUILD DOCKER IMAGES\n  # ==========================================\n  build:\n    name: Build Docker Images\n    runs-on: ubuntu-latest\n    needs: [unit-tests, integration-tests]\n    permissions:\n      contents: read\n      packages: write\n    strategy:\n      matrix:\n        service:\n          - worker-ai-orchestration\n          - worker-negotiation-fsm\n          - worker-guardrails\n          - worker-hitl\n          - worker-document-gen\n          - worker-oblio\n          - worker-efactura\n          - worker-rag-embedding\n          - mcp-server\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n        \n      - name: Login to GHCR\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n          \n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.IMAGE_PREFIX }}/${{ matrix.service }}\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=sha,prefix=\n            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}\n            \n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          file: docker/etapa3/Dockerfile.${{ matrix.service }}\n          push: ${{ github.event_name == 'push' }}\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n\n  # ==========================================\n  # DEPLOY TO STAGING\n  # ==========================================\n  deploy-staging:\n    name: Deploy to Staging\n    runs-on: ubuntu-latest\n    needs: [build, e2e-tests]\n    if: github.ref == 'refs/heads/develop'\n    environment: staging\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Deploy to staging\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.STAGING_HOST }}\n          username: ${{ secrets.STAGING_USER }}\n          key: ${{ secrets.STAGING_SSH_KEY }}\n          script: |\n            cd /opt/cerniq\n            docker compose -f docker-compose.etapa3.yaml pull\n            docker compose -f docker-compose.etapa3.yaml up -d\n            docker system prune -f\n            \n      - name: Verify deployment\n        run: |\n          sleep 30\n          curl -f https://staging.cerniq.app/api/health || exit 1\n          \n      - name: Notify Slack\n        if: always()\n        uses: slackapi/slack-github-action@v1.26.0\n        with:\n          payload: |\n            {\n              \"text\": \"Etapa 3 deployed to staging: ${{ job.status }}\",\n              \"blocks\": [\n                {\n                  \"type\": \"section\",\n                  \"text\": {\n                    \"type\": \"mrkdwn\",\n                    \"text\": \"*Etapa 3 Staging Deployment*\\nStatus: ${{ job.status }}\\nCommit: ${{ github.sha }}\"\n                  }\n                }\n              ]\n            }\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n\n  # ==========================================\n  # DEPLOY TO PRODUCTION\n  # ==========================================\n  deploy-production:\n    name: Deploy to Production\n    runs-on: ubuntu-latest\n    needs: [build, e2e-tests]\n    if: github.ref == 'refs/heads/main'\n    environment: production\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Deploy to production\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.PROD_HOST }}\n          username: ${{ secrets.PROD_USER }}\n          key: ${{ secrets.PROD_SSH_KEY }}\n          script: |\n            cd /opt/cerniq\n            \n            # Backup current state\n            docker compose -f docker-compose.etapa3.yaml config > backup/etapa3-$(date +%Y%m%d-%H%M%S).yaml\n            \n            # Pull new images\n            docker compose -f docker-compose.etapa3.yaml pull\n            \n            # Rolling update workers\n            for service in worker-ai-orchestration worker-guardrails worker-hitl; do\n              docker compose -f docker-compose.etapa3.yaml up -d --no-deps $service\n              sleep 10\n              docker compose -f docker-compose.etapa3.yaml exec $service /app/healthcheck.js || exit 1\n            done\n            \n            # Update remaining services\n            docker compose -f docker-compose.etapa3.yaml up -d\n            \n            # Cleanup\n            docker system prune -f\n            \n      - name: Verify deployment\n        run: |\n          sleep 60\n          curl -f https://app.cerniq.app/api/health || exit 1\n          curl -f https://app.cerniq.app/api/etapa3/health || exit 1\n          \n      - name: Run smoke tests\n        run: |\n          pnpm test:smoke:production\n        env:\n          BASE_URL: https://app.cerniq.app\n          \n      - name: Notify Slack\n        if: always()\n        uses: slackapi/slack-github-action@v1.26.0\n        with:\n          payload: |\n            {\n              \"text\": \"🚀 Etapa 3 deployed to production: ${{ job.status }}\",\n              \"blocks\": [\n                {\n                  \"type\": \"section\",\n                  \"text\": {\n                    \"type\": \"mrkdwn\",\n                    \"text\": \"*🚀 Etapa 3 Production Deployment*\\nStatus: ${{ job.status }}\\nCommit: `${{ github.sha }}`\\nWorkflow: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>\"\n                  }\n                }\n              ]\n            }\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n```",
  "director_implementare": "/var/www/CerniqAPP/.github/workflows",
  "restrictii_antihalucinatie": [
    "USE matrix builds for services",
    "IMPLEMENT proper health checks",
    "CONFIGURE rolling deployments",
    "SEPARATE environments properly",
    "NOTIFY on all outcomes"
  ],
  "validare_task": "1. Pipeline runs successfully\n2. Tests pass\n3. Images built\n4. Deployments work\n5. Notifications sent",
  "outcome": "CI/CD pipeline complet pentru Etapa 3"
}
```

### F3.18.5 Deployment Runbook (#96)

```json
{
  "taskID": "F3.18.5.T001",
  "denumire_task": "Runbook deployment pentru Etapa 3",
  "context_anterior": "CI/CD configurat. Acum documentăm procedurile de deployment.",
  "descriere_task": "Ești un expert în DevOps și operational procedures. Task-ul tău este să creezi deployment runbook.\n\n## Pre-Deployment Checklist\n\n### 1. Verificări Înainte de Deploy\n\n```bash\n#!/bin/bash\n# pre-deploy-check.sh\n\nset -e\n\necho \"=== Etapa 3 Pre-Deployment Checks ===\"\necho \"Date: $(date)\"\necho \"\"\n\n# 1. Check current system status\necho \"[1/10] Checking current system health...\"\ncurl -sf http://localhost:3000/api/health > /dev/null || { echo \"FAIL: API not healthy\"; exit 1; }\necho \"✓ API healthy\"\n\n# 2. Check database connectivity\necho \"[2/10] Checking database connection...\"\ndocker exec cerniq-postgres pg_isready -U cerniq || { echo \"FAIL: Database not ready\"; exit 1; }\necho \"✓ Database connected\"\n\n# 3. Check Redis connectivity\necho \"[3/10] Checking Redis connection...\"\ndocker exec cerniq-redis redis-cli ping > /dev/null || { echo \"FAIL: Redis not responding\"; exit 1; }\necho \"✓ Redis connected\"\n\n# 4. Check Qdrant connectivity\necho \"[4/10] Checking Qdrant connection...\"\ncurl -sf http://localhost:6333/readyz > /dev/null || { echo \"FAIL: Qdrant not ready\"; exit 1; }\necho \"✓ Qdrant connected\"\n\n# 5. Check disk space\necho \"[5/10] Checking disk space...\"\nDISK_USAGE=$(df -h /data | awk 'NR==2 {print $5}' | tr -d '%')\nif [ \"$DISK_USAGE\" -gt 85 ]; then\n  echo \"WARNING: Disk usage at ${DISK_USAGE}%\"\nfi\necho \"✓ Disk space: ${DISK_USAGE}% used\"\n\n# 6. Check memory\necho \"[6/10] Checking memory...\"\nMEM_AVAILABLE=$(free -g | awk '/Mem:/ {print $7}')\nif [ \"$MEM_AVAILABLE\" -lt 10 ]; then\n  echo \"WARNING: Low memory available: ${MEM_AVAILABLE}GB\"\nfi\necho \"✓ Memory available: ${MEM_AVAILABLE}GB\"\n\n# 7. Check pending HITL approvals\necho \"[7/10] Checking pending HITL approvals...\"\nPENDING_HITL=$(docker exec cerniq-postgres psql -U cerniq -d cerniq_prod -t -c \\\n  \"SELECT COUNT(*) FROM hitl_approvals WHERE status = 'pending'\")\nif [ \"$PENDING_HITL\" -gt 10 ]; then\n  echo \"WARNING: ${PENDING_HITL} pending HITL approvals\"\nfi\necho \"✓ Pending HITL: ${PENDING_HITL}\"\n\n# 8. Check active negotiations\necho \"[8/10] Checking active negotiations...\"\nACTIVE_NEG=$(docker exec cerniq-postgres psql -U cerniq -d cerniq_prod -t -c \\\n  \"SELECT COUNT(*) FROM negotiations WHERE fsm_state NOT IN ('won', 'lost', 'stale')\")\necho \"✓ Active negotiations: ${ACTIVE_NEG}\"\n\n# 9. Check queue depth\necho \"[9/10] Checking queue depth...\"\nQUEUE_DEPTH=$(docker exec cerniq-redis redis-cli LLEN bull:ai-orchestration:waiting 2>/dev/null || echo \"0\")\nif [ \"$QUEUE_DEPTH\" -gt 100 ]; then\n  echo \"WARNING: High queue depth: ${QUEUE_DEPTH}\"\nfi\necho \"✓ Queue depth: ${QUEUE_DEPTH}\"\n\n# 10. Backup verification\necho \"[10/10] Verifying recent backup...\"\nLAST_BACKUP=$(ls -t /data/backups/*.backup 2>/dev/null | head -1)\nif [ -z \"$LAST_BACKUP\" ]; then\n  echo \"WARNING: No backup found\"\nelse\n  BACKUP_AGE=$(( ($(date +%s) - $(stat -c %Y \"$LAST_BACKUP\")) / 3600 ))\n  if [ \"$BACKUP_AGE\" -gt 24 ]; then\n    echo \"WARNING: Last backup is ${BACKUP_AGE} hours old\"\n  fi\n  echo \"✓ Last backup: ${LAST_BACKUP} (${BACKUP_AGE}h ago)\"\nfi\n\necho \"\"\necho \"=== Pre-Deployment Checks Complete ===\"\necho \"Ready for deployment: YES\"\n```\n\n### 2. Deployment Procedure\n\n```bash\n#!/bin/bash\n# deploy-etapa3.sh\n\nset -e\n\nVERSION=${1:-latest}\nTIMESTAMP=$(date +%Y%m%d-%H%M%S)\nLOG_FILE=\"/var/log/cerniq/deploy-etapa3-${TIMESTAMP}.log\"\n\nexec > >(tee -a \"$LOG_FILE\") 2>&1\n\necho \"=== Etapa 3 Deployment Started ===\"\necho \"Version: ${VERSION}\"\necho \"Timestamp: ${TIMESTAMP}\"\necho \"Log: ${LOG_FILE}\"\necho \"\"\n\n# Step 1: Pre-deployment checks\necho \"[Step 1/8] Running pre-deployment checks...\"\n./pre-deploy-check.sh\n\n# Step 2: Create backup\necho \"[Step 2/8] Creating pre-deployment backup...\"\npg_dump -h localhost -U cerniq -d cerniq_prod -F c -f \"/data/backups/pre-deploy-${TIMESTAMP}.backup\"\necho \"✓ Backup created\"\n\n# Step 3: Pull new images\necho \"[Step 3/8] Pulling new Docker images...\"\ncd /opt/cerniq\ndocker compose -f docker-compose.etapa3.yaml pull\necho \"✓ Images pulled\"\n\n# Step 4: Run migrations\necho \"[Step 4/8] Running database migrations...\"\ndocker compose -f docker-compose.etapa3.yaml run --rm \\\n  worker-ai-orchestration npm run db:migrate\necho \"✓ Migrations complete\"\n\n# Step 5: Deploy workers (rolling)\necho \"[Step 5/8] Deploying workers (rolling update)...\"\n\nWORKERS=(\n  \"worker-guardrails\"\n  \"worker-hitl\"\n  \"worker-negotiation-fsm\"\n  \"worker-ai-orchestration\"\n  \"worker-rag-embedding\"\n  \"worker-document-gen\"\n  \"worker-oblio\"\n  \"worker-efactura\"\n)\n\nfor worker in \"${WORKERS[@]}\"; do\n  echo \"  Updating ${worker}...\"\n  docker compose -f docker-compose.etapa3.yaml up -d --no-deps \"$worker\"\n  sleep 5\n  \n  # Wait for health check\n  for i in {1..30}; do\n    if docker compose -f docker-compose.etapa3.yaml exec -T \"$worker\" \\\n       node /app/healthcheck.js 2>/dev/null; then\n      echo \"  ✓ ${worker} healthy\"\n      break\n    fi\n    if [ $i -eq 30 ]; then\n      echo \"  ✗ ${worker} failed health check\"\n      ./rollback-etapa3.sh \"$TIMESTAMP\"\n      exit 1\n    fi\n    sleep 2\n  done\ndone\n\n# Step 6: Deploy MCP server\necho \"[Step 6/8] Deploying MCP server...\"\ndocker compose -f docker-compose.etapa3.yaml up -d --no-deps mcp-server\nsleep 10\ncurl -sf http://localhost:3100/health > /dev/null || { echo \"MCP server unhealthy\"; exit 1; }\necho \"✓ MCP server deployed\"\n\n# Step 7: Verify deployment\necho \"[Step 7/8] Verifying deployment...\"\n./verify-etapa3.sh\n\n# Step 8: Cleanup\necho \"[Step 8/8] Cleaning up...\"\ndocker system prune -f --volumes\necho \"✓ Cleanup complete\"\n\necho \"\"\necho \"=== Etapa 3 Deployment Complete ===\"\necho \"Duration: $SECONDS seconds\"\necho \"Log: ${LOG_FILE}\"\n```\n\n### 3. Rollback Procedure\n\n```bash\n#!/bin/bash\n# rollback-etapa3.sh\n\nset -e\n\nBACKUP_TIMESTAMP=${1:-$(ls -t /data/backups/pre-deploy-*.backup | head -1 | grep -oP 'pre-deploy-\\K[0-9-]+')}\n\necho \"=== Etapa 3 Rollback Started ===\"\necho \"Rolling back to: ${BACKUP_TIMESTAMP}\"\necho \"\"\n\n# Step 1: Stop workers\necho \"[Step 1/4] Stopping workers...\"\ndocker compose -f docker-compose.etapa3.yaml stop \\\n  worker-ai-orchestration \\\n  worker-negotiation-fsm \\\n  worker-guardrails \\\n  worker-hitl\n\n# Step 2: Restore database\necho \"[Step 2/4] Restoring database...\"\nBACKUP_FILE=\"/data/backups/pre-deploy-${BACKUP_TIMESTAMP}.backup\"\nif [ ! -f \"$BACKUP_FILE\" ]; then\n  echo \"ERROR: Backup file not found: ${BACKUP_FILE}\"\n  exit 1\nfi\n\npg_restore -h localhost -U cerniq -d cerniq_prod -c \"$BACKUP_FILE\"\necho \"✓ Database restored\"\n\n# Step 3: Restore previous images\necho \"[Step 3/4] Restoring previous Docker images...\"\nPREV_COMPOSE=\"/data/backups/etapa3-${BACKUP_TIMESTAMP}.yaml\"\nif [ -f \"$PREV_COMPOSE\" ]; then\n  docker compose -f \"$PREV_COMPOSE\" pull\n  docker compose -f \"$PREV_COMPOSE\" up -d\nelse\n  echo \"WARNING: Previous compose file not found, using current\"\n  docker compose -f docker-compose.etapa3.yaml up -d\nfi\n\n# Step 4: Verify rollback\necho \"[Step 4/4] Verifying rollback...\"\nsleep 30\n./verify-etapa3.sh\n\necho \"\"\necho \"=== Etapa 3 Rollback Complete ===\"\n```\n\n### 4. Verification Script\n\n```bash\n#!/bin/bash\n# verify-etapa3.sh\n\nset -e\n\necho \"=== Etapa 3 Verification ===\"\n\n# Check all workers are running\necho \"[1/5] Checking worker containers...\"\nWORKERS=(\n  \"cerniq-worker-ai-orchestration\"\n  \"cerniq-worker-negotiation-fsm\"\n  \"cerniq-worker-guardrails\"\n  \"cerniq-worker-hitl\"\n)\n\nfor worker in \"${WORKERS[@]}\"; do\n  STATUS=$(docker inspect -f '{{.State.Status}}' \"$worker\" 2>/dev/null || echo \"not found\")\n  if [ \"$STATUS\" != \"running\" ]; then\n    echo \"✗ ${worker}: ${STATUS}\"\n    exit 1\n  fi\n  echo \"✓ ${worker}: running\"\ndone\n\n# Check API endpoints\necho \"[2/5] Checking API endpoints...\"\nENDPOINTS=(\n  \"http://localhost:3000/api/health\"\n  \"http://localhost:3000/api/etapa3/negotiations\"\n  \"http://localhost:3100/health\"\n)\n\nfor endpoint in \"${ENDPOINTS[@]}\"; do\n  HTTP_CODE=$(curl -sf -o /dev/null -w '%{http_code}' \"$endpoint\" || echo \"000\")\n  if [ \"$HTTP_CODE\" -lt 200 ] || [ \"$HTTP_CODE\" -ge 400 ]; then\n    echo \"✗ ${endpoint}: HTTP ${HTTP_CODE}\"\n    exit 1\n  fi\n  echo \"✓ ${endpoint}: HTTP ${HTTP_CODE}\"\ndone\n\n# Check queue processing\necho \"[3/5] Checking queue processing...\"\nTEST_JOB_ID=$(curl -sf -X POST http://localhost:3000/api/etapa3/test/queue \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"type\": \"health_check\"}' | jq -r '.jobId')\n\nsleep 5\nJOB_STATUS=$(curl -sf \"http://localhost:3000/api/etapa3/test/queue/${TEST_JOB_ID}\" | jq -r '.status')\nif [ \"$JOB_STATUS\" != \"completed\" ]; then\n  echo \"✗ Queue test job: ${JOB_STATUS}\"\n  exit 1\nfi\necho \"✓ Queue processing: working\"\n\n# Check AI model connectivity\necho \"[4/5] Checking AI model connectivity...\"\nAI_TEST=$(curl -sf -X POST http://localhost:3000/api/etapa3/test/ai \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"prompt\": \"test\"}' | jq -r '.success')\nif [ \"$AI_TEST\" != \"true\" ]; then\n  echo \"✗ AI model connectivity: failed\"\n  exit 1\nfi\necho \"✓ AI model connectivity: working\"\n\n# Check Qdrant collections\necho \"[5/5] Checking Qdrant collections...\"\nCOLLECTION_STATUS=$(curl -sf http://localhost:6333/collections/products | jq -r '.status')\nif [ \"$COLLECTION_STATUS\" != \"ok\" ]; then\n  echo \"✗ Qdrant collection: ${COLLECTION_STATUS}\"\n  exit 1\nfi\necho \"✓ Qdrant collection: ok\"\n\necho \"\"\necho \"=== All Verifications Passed ===\"\n```",
  "director_implementare": "/var/www/CerniqAPP/scripts/deployment",
  "restrictii_antihalucinatie": [
    "ALWAYS backup before deploy",
    "USE rolling updates for workers",
    "IMPLEMENT health checks",
    "HAVE rollback ready",
    "VERIFY after deployment"
  ],
  "validare_task": "1. Pre-checks complete\n2. Deployment scripted\n3. Rollback tested\n4. Verification automated\n5. Logging comprehensive",
  "outcome": "Deployment runbook complet pentru Etapa 3"
}
```

### F3.18.6 Rollback Procedures (#97)

```json
{
  "taskID": "F3.18.6.T001",
  "denumire_task": "Proceduri complete de rollback pentru Etapa 3",
  "context_anterior": "Deployment runbook creat. Acum documentăm procedurile detaliate de rollback.",
  "descriere_task": "Ești un expert în disaster recovery și rollback procedures. Task-ul tău este să creezi proceduri complete de rollback.\n\n## Rollback Strategy Overview\n\n### 1. Rollback Levels\n\n```typescript\n// rollback-types.ts\nexport enum RollbackLevel {\n  PARTIAL = 'partial',      // Single component rollback\n  COMPONENT = 'component',   // Full component group rollback\n  FULL = 'full'             // Complete system rollback\n}\n\nexport enum RollbackTrigger {\n  MANUAL = 'manual',                    // Operator triggered\n  AUTO_HEALTH = 'auto_health',          // Health check failure\n  AUTO_ERROR_RATE = 'auto_error_rate',  // High error rate\n  AUTO_LATENCY = 'auto_latency'         // Latency threshold exceeded\n}\n\nexport interface RollbackDecision {\n  trigger: RollbackTrigger;\n  level: RollbackLevel;\n  components: string[];\n  timestamp: Date;\n  operator?: string;\n  reason: string;\n  estimatedDowntime: number; // minutes\n}\n\n// Automatic rollback thresholds\nexport const ROLLBACK_THRESHOLDS = {\n  errorRate: {\n    threshold: 0.10,        // 10% error rate\n    windowMinutes: 5,\n    minRequests: 100\n  },\n  latencyP99: {\n    threshold: 10000,       // 10s p99 latency\n    windowMinutes: 5\n  },\n  healthCheckFailures: {\n    consecutive: 3,         // 3 consecutive failures\n    intervalSeconds: 30\n  },\n  queueBacklog: {\n    threshold: 10000,       // 10k pending jobs\n    windowMinutes: 10\n  }\n};\n```\n\n### 2. Component-Level Rollback\n\n```bash\n#!/bin/bash\n# rollback-component.sh\n\nset -e\n\nCOMPONENT=${1:?\"Component name required\"}\nVERSION=${2:-\"previous\"}\n\necho \"=== Component Rollback: ${COMPONENT} ===\"\necho \"Target version: ${VERSION}\"\necho \"\"\n\n# Map component to container name\ndeclare -A COMPONENT_MAP=(\n  [\"ai-orchestration\"]=\"cerniq-worker-ai-orchestration\"\n  [\"negotiation-fsm\"]=\"cerniq-worker-negotiation-fsm\"\n  [\"guardrails\"]=\"cerniq-worker-guardrails\"\n  [\"hitl\"]=\"cerniq-worker-hitl\"\n  [\"rag-embedding\"]=\"cerniq-worker-rag-embedding\"\n  [\"document-gen\"]=\"cerniq-worker-document-gen\"\n  [\"oblio\"]=\"cerniq-worker-oblio\"\n  [\"efactura\"]=\"cerniq-worker-efactura\"\n  [\"mcp-server\"]=\"cerniq-mcp-server\"\n)\n\nCONTAINER=${COMPONENT_MAP[$COMPONENT]}\nif [ -z \"$CONTAINER\" ]; then\n  echo \"ERROR: Unknown component: ${COMPONENT}\"\n  echo \"Available: ${!COMPONENT_MAP[@]}\"\n  exit 1\nfi\n\n# Step 1: Get previous image\nif [ \"$VERSION\" = \"previous\" ]; then\n  PREV_IMAGE=$(docker inspect \"$CONTAINER\" --format='{{.Config.Image}}' | sed 's/:.*/:previous/')\nelse\n  PREV_IMAGE=\"cerniq/${COMPONENT}:${VERSION}\"\nfi\necho \"[1/5] Target image: ${PREV_IMAGE}\"\n\n# Step 2: Pause queue processing\necho \"[2/5] Pausing queue processing...\"\ndocker exec cerniq-redis redis-cli SET \"pause:${COMPONENT}\" 1 EX 300\nsleep 5\n\n# Step 3: Stop current container\necho \"[3/5] Stopping current container...\"\ndocker stop \"$CONTAINER\" || true\n\n# Step 4: Start with previous image\necho \"[4/5] Starting with previous image...\"\ndocker compose -f docker-compose.etapa3.yaml run -d --name \"${CONTAINER}-rollback\" \\\n  -e \"IMAGE_TAG=${VERSION}\" \\\n  \"$COMPONENT\"\n\n# Wait for health\nfor i in {1..30}; do\n  if docker exec \"${CONTAINER}-rollback\" node /app/healthcheck.js 2>/dev/null; then\n    echo \"✓ Container healthy\"\n    break\n  fi\n  if [ $i -eq 30 ]; then\n    echo \"✗ Rollback container unhealthy\"\n    exit 1\n  fi\n  sleep 2\ndone\n\n# Step 5: Resume queue processing\necho \"[5/5] Resuming queue processing...\"\ndocker exec cerniq-redis redis-cli DEL \"pause:${COMPONENT}\"\n\necho \"\"\necho \"=== Component Rollback Complete ===\"\necho \"Component: ${COMPONENT}\"\necho \"Container: ${CONTAINER}-rollback\"\necho \"Image: ${PREV_IMAGE}\"\n```\n\n### 3. Database Rollback\n\n```bash\n#!/bin/bash\n# rollback-database.sh\n\nset -e\n\nBACKUP_FILE=${1:?\"Backup file required\"}\nTARGET_DB=${2:-\"cerniq_prod\"}\n\necho \"=== Database Rollback ===\"\necho \"Backup: ${BACKUP_FILE}\"\necho \"Target: ${TARGET_DB}\"\necho \"\"\n\n# Verify backup exists\nif [ ! -f \"$BACKUP_FILE\" ]; then\n  echo \"ERROR: Backup file not found: ${BACKUP_FILE}\"\n  exit 1\nfi\n\n# Confirm rollback\nread -p \"This will DESTROY current data in ${TARGET_DB}. Continue? (yes/no): \" CONFIRM\nif [ \"$CONFIRM\" != \"yes\" ]; then\n  echo \"Rollback cancelled\"\n  exit 0\nfi\n\n# Step 1: Stop all workers\necho \"[1/6] Stopping all workers...\"\ndocker compose -f docker-compose.etapa3.yaml stop \\\n  worker-ai-orchestration \\\n  worker-negotiation-fsm \\\n  worker-guardrails \\\n  worker-hitl \\\n  worker-rag-embedding \\\n  worker-document-gen\n\n# Step 2: Wait for active transactions\necho \"[2/6] Waiting for active transactions...\"\nfor i in {1..60}; do\n  ACTIVE=$(docker exec cerniq-postgres psql -U cerniq -d \"$TARGET_DB\" -t -c \\\n    \"SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active' AND datname = '${TARGET_DB}'\")\n  ACTIVE=$(echo $ACTIVE | xargs)\n  if [ \"$ACTIVE\" -le 1 ]; then\n    break\n  fi\n  echo \"  Waiting... (${ACTIVE} active connections)\"\n  sleep 5\ndone\n\n# Step 3: Terminate remaining connections\necho \"[3/6] Terminating connections...\"\ndocker exec cerniq-postgres psql -U cerniq -d postgres -c \\\n  \"SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${TARGET_DB}' AND pid <> pg_backend_pid();\"\n\n# Step 4: Create safety backup\necho \"[4/6] Creating safety backup...\"\nSAFETY_BACKUP=\"/data/backups/safety-$(date +%Y%m%d-%H%M%S).backup\"\npg_dump -h localhost -U cerniq -d \"$TARGET_DB\" -F c -f \"$SAFETY_BACKUP\"\necho \"  Safety backup: ${SAFETY_BACKUP}\"\n\n# Step 5: Restore from backup\necho \"[5/6] Restoring database...\"\ndocker exec cerniq-postgres dropdb -U cerniq \"$TARGET_DB\" --if-exists\ndocker exec cerniq-postgres createdb -U cerniq \"$TARGET_DB\"\npg_restore -h localhost -U cerniq -d \"$TARGET_DB\" -v \"$BACKUP_FILE\"\necho \"✓ Database restored\"\n\n# Step 6: Restart workers\necho \"[6/6] Restarting workers...\"\ndocker compose -f docker-compose.etapa3.yaml start \\\n  worker-ai-orchestration \\\n  worker-negotiation-fsm \\\n  worker-guardrails \\\n  worker-hitl \\\n  worker-rag-embedding \\\n  worker-document-gen\n\necho \"\"\necho \"=== Database Rollback Complete ===\"\necho \"Safety backup saved: ${SAFETY_BACKUP}\"\n```\n\n### 4. Queue Data Recovery\n\n```typescript\n// queue-recovery.ts\nimport { Queue, Job } from 'bullmq';\nimport { redis } from '@/lib/redis';\nimport { db } from '@/lib/database';\nimport { jobAuditLog } from '@/schema/etapa3';\n\ninterface RecoveryOptions {\n  fromTimestamp: Date;\n  toTimestamp: Date;\n  queues: string[];\n  replayMode: 'immediate' | 'scheduled' | 'manual';\n}\n\nexport async function recoverQueueJobs(options: RecoveryOptions): Promise<{\n  recovered: number;\n  failed: number;\n  skipped: number;\n}> {\n  const stats = { recovered: 0, failed: 0, skipped: 0 };\n  \n  for (const queueName of options.queues) {\n    console.log(`Recovering jobs for queue: ${queueName}`);\n    \n    // Get jobs from audit log\n    const auditedJobs = await db\n      .select()\n      .from(jobAuditLog)\n      .where(\n        and(\n          eq(jobAuditLog.queue_name, queueName),\n          gte(jobAuditLog.created_at, options.fromTimestamp),\n          lte(jobAuditLog.created_at, options.toTimestamp),\n          inArray(jobAuditLog.status, ['failed', 'lost'])\n        )\n      );\n    \n    console.log(`  Found ${auditedJobs.length} jobs to recover`);\n    \n    const queue = new Queue(queueName, { connection: redis });\n    \n    for (const auditJob of auditedJobs) {\n      try {\n        // Check if job already exists\n        const existingJob = await queue.getJob(auditJob.job_id);\n        if (existingJob) {\n          console.log(`  Skipping existing job: ${auditJob.job_id}`);\n          stats.skipped++;\n          continue;\n        }\n        \n        // Recreate job based on replay mode\n        const jobOptions: any = {\n          jobId: `${auditJob.job_id}-recovery`,\n          attempts: 3,\n          backoff: { type: 'exponential', delay: 5000 }\n        };\n        \n        if (options.replayMode === 'scheduled') {\n          jobOptions.delay = 60000; // 1 minute delay\n        }\n        \n        await queue.add(\n          auditJob.job_name,\n          JSON.parse(auditJob.job_data),\n          jobOptions\n        );\n        \n        stats.recovered++;\n        console.log(`  ✓ Recovered job: ${auditJob.job_id}`);\n        \n      } catch (error) {\n        console.error(`  ✗ Failed to recover job ${auditJob.job_id}:`, error);\n        stats.failed++;\n      }\n    }\n    \n    await queue.close();\n  }\n  \n  return stats;\n}\n\n// CLI interface\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  \n  recoverQueueJobs({\n    fromTimestamp: new Date(args[0] || Date.now() - 3600000),\n    toTimestamp: new Date(args[1] || Date.now()),\n    queues: (args[2] || 'ai-orchestration,guardrails,hitl').split(','),\n    replayMode: (args[3] as any) || 'scheduled'\n  }).then(stats => {\n    console.log('\\nRecovery Complete:');\n    console.log(`  Recovered: ${stats.recovered}`);\n    console.log(`  Failed: ${stats.failed}`);\n    console.log(`  Skipped: ${stats.skipped}`);\n    process.exit(stats.failed > 0 ? 1 : 0);\n  });\n}\n```\n\n### 5. Automatic Rollback Monitor\n\n```typescript\n// auto-rollback-monitor.ts\nimport { EventEmitter } from 'events';\nimport { redis } from '@/lib/redis';\nimport { ROLLBACK_THRESHOLDS, RollbackDecision, RollbackLevel, RollbackTrigger } from './rollback-types';\n\nexport class AutoRollbackMonitor extends EventEmitter {\n  private checkInterval: NodeJS.Timeout | null = null;\n  private metrics: Map<string, number[]> = new Map();\n  \n  constructor(\n    private readonly config = ROLLBACK_THRESHOLDS\n  ) {\n    super();\n  }\n  \n  start(intervalMs: number = 30000): void {\n    console.log('Auto-rollback monitor started');\n    \n    this.checkInterval = setInterval(() => {\n      this.checkAllThresholds();\n    }, intervalMs);\n    \n    // Initial check\n    this.checkAllThresholds();\n  }\n  \n  stop(): void {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n  }\n  \n  private async checkAllThresholds(): Promise<void> {\n    const checks = await Promise.all([\n      this.checkErrorRate(),\n      this.checkLatency(),\n      this.checkHealthChecks(),\n      this.checkQueueBacklog()\n    ]);\n    \n    const triggered = checks.filter(c => c !== null);\n    \n    if (triggered.length > 0) {\n      // Emit most severe trigger\n      const decision = this.selectMostSevere(triggered as RollbackDecision[]);\n      this.emit('rollback-triggered', decision);\n    }\n  }\n  \n  private async checkErrorRate(): Promise<RollbackDecision | null> {\n    const key = 'metrics:error_rate:5m';\n    const errorRate = parseFloat(await redis.get(key) || '0');\n    const requestCount = parseInt(await redis.get('metrics:request_count:5m') || '0');\n    \n    if (requestCount >= this.config.errorRate.minRequests &&\n        errorRate >= this.config.errorRate.threshold) {\n      return {\n        trigger: RollbackTrigger.AUTO_ERROR_RATE,\n        level: RollbackLevel.COMPONENT,\n        components: ['ai-orchestration', 'guardrails'],\n        timestamp: new Date(),\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(this.config.errorRate.threshold * 100)}%`,\n        estimatedDowntime: 5\n      };\n    }\n    \n    return null;\n  }\n  \n  private async checkLatency(): Promise<RollbackDecision | null> {\n    const key = 'metrics:latency_p99:5m';\n    const latencyP99 = parseFloat(await redis.get(key) || '0');\n    \n    if (latencyP99 >= this.config.latencyP99.threshold) {\n      return {\n        trigger: RollbackTrigger.AUTO_LATENCY,\n        level: RollbackLevel.PARTIAL,\n        components: ['ai-orchestration'],\n        timestamp: new Date(),\n        reason: `P99 latency ${latencyP99}ms exceeds threshold ${this.config.latencyP99.threshold}ms`,\n        estimatedDowntime: 2\n      };\n    }\n    \n    return null;\n  }\n  \n  private async checkHealthChecks(): Promise<RollbackDecision | null> {\n    const failures = parseInt(await redis.get('health:consecutive_failures') || '0');\n    \n    if (failures >= this.config.healthCheckFailures.consecutive) {\n      return {\n        trigger: RollbackTrigger.AUTO_HEALTH,\n        level: RollbackLevel.FULL,\n        components: ['all'],\n        timestamp: new Date(),\n        reason: `${failures} consecutive health check failures`,\n        estimatedDowntime: 15\n      };\n    }\n    \n    return null;\n  }\n  \n  private async checkQueueBacklog(): Promise<RollbackDecision | null> {\n    const queues = ['ai-orchestration', 'guardrails', 'hitl'];\n    let totalBacklog = 0;\n    \n    for (const queue of queues) {\n      const waiting = parseInt(await redis.llen(`bull:${queue}:waiting`) || '0');\n      totalBacklog += waiting;\n    }\n    \n    if (totalBacklog >= this.config.queueBacklog.threshold) {\n      return {\n        trigger: RollbackTrigger.AUTO_ERROR_RATE,\n        level: RollbackLevel.COMPONENT,\n        components: queues,\n        timestamp: new Date(),\n        reason: `Queue backlog ${totalBacklog} exceeds threshold ${this.config.queueBacklog.threshold}`,\n        estimatedDowntime: 10\n      };\n    }\n    \n    return null;\n  }\n  \n  private selectMostSevere(decisions: RollbackDecision[]): RollbackDecision {\n    const severity = {\n      [RollbackLevel.FULL]: 3,\n      [RollbackLevel.COMPONENT]: 2,\n      [RollbackLevel.PARTIAL]: 1\n    };\n    \n    return decisions.sort((a, b) => \n      severity[b.level] - severity[a.level]\n    )[0];\n  }\n}\n\n// Usage\nconst monitor = new AutoRollbackMonitor();\nmonitor.on('rollback-triggered', async (decision: RollbackDecision) => {\n  console.log('\\n⚠️ AUTO-ROLLBACK TRIGGERED');\n  console.log(`Trigger: ${decision.trigger}`);\n  console.log(`Level: ${decision.level}`);\n  console.log(`Components: ${decision.components.join(', ')}`);\n  console.log(`Reason: ${decision.reason}`);\n  console.log(`Estimated downtime: ${decision.estimatedDowntime} minutes`);\n  \n  // Send alert\n  await sendSlackAlert({\n    channel: '#cerniq-alerts',\n    text: `🚨 Auto-rollback triggered: ${decision.reason}`,\n    attachments: [{\n      color: 'danger',\n      fields: [\n        { title: 'Level', value: decision.level, short: true },\n        { title: 'Components', value: decision.components.join(', '), short: true },\n        { title: 'Estimated Downtime', value: `${decision.estimatedDowntime} min`, short: true }\n      ]\n    }]\n  });\n  \n  // Execute rollback if not in dry-run mode\n  if (process.env.AUTO_ROLLBACK_ENABLED === 'true') {\n    await executeRollback(decision);\n  }\n});\n\nmonitor.start();\n```",
  "director_implementare": "/var/www/CerniqAPP/scripts/rollback",
  "restrictii_antihalucinatie": [
    "BACKUP before any rollback",
    "STOP workers before DB rollback",
    "VERIFY health after rollback",
    "LOG all rollback actions",
    "TEST rollback procedures"
  ],
  "validare_task": "1. Component rollback tested\n2. Database rollback safe\n3. Queue recovery working\n4. Auto-monitor functional\n5. Alerts configured",
  "outcome": "Proceduri complete de rollback pentru Etapa 3"
}
```

### F3.18.7 Post-Deployment Verification (#98)

```json
{
  "taskID": "F3.18.7.T001",
  "denumire_task": "Verificare post-deployment pentru Etapa 3",
  "context_anterior": "Rollback procedures definite. Acum documentăm verificările post-deployment.",
  "descriere_task": "Ești un expert în QA și deployment verification. Task-ul tău este să creezi verificări comprehensive post-deployment.\n\n## Post-Deployment Verification Suite\n\n### 1. Automated Verification Script\n\n```typescript\n// post-deployment-verification.ts\nimport { db } from '@/lib/database';\nimport { redis } from '@/lib/redis';\nimport { qdrant } from '@/lib/qdrant';\n\ninterface VerificationResult {\n  category: string;\n  check: string;\n  status: 'pass' | 'fail' | 'warn';\n  message: string;\n  duration: number;\n}\n\ninterface VerificationReport {\n  deploymentId: string;\n  timestamp: Date;\n  results: VerificationResult[];\n  summary: {\n    total: number;\n    passed: number;\n    failed: number;\n    warnings: number;\n  };\n  overallStatus: 'success' | 'partial' | 'failure';\n}\n\nexport async function runPostDeploymentVerification(\n  deploymentId: string\n): Promise<VerificationReport> {\n  const results: VerificationResult[] = [];\n  \n  // Category 1: Infrastructure\n  results.push(...await verifyInfrastructure());\n  \n  // Category 2: Database\n  results.push(...await verifyDatabase());\n  \n  // Category 3: Queue System\n  results.push(...await verifyQueues());\n  \n  // Category 4: AI Services\n  results.push(...await verifyAIServices());\n  \n  // Category 5: API Endpoints\n  results.push(...await verifyAPIEndpoints());\n  \n  // Category 6: Business Logic\n  results.push(...await verifyBusinessLogic());\n  \n  // Category 7: HITL System\n  results.push(...await verifyHITLSystem());\n  \n  // Category 8: Integrations\n  results.push(...await verifyIntegrations());\n  \n  // Generate summary\n  const summary = {\n    total: results.length,\n    passed: results.filter(r => r.status === 'pass').length,\n    failed: results.filter(r => r.status === 'fail').length,\n    warnings: results.filter(r => r.status === 'warn').length\n  };\n  \n  const overallStatus = summary.failed > 0 ? 'failure' :\n                        summary.warnings > 0 ? 'partial' : 'success';\n  \n  return {\n    deploymentId,\n    timestamp: new Date(),\n    results,\n    summary,\n    overallStatus\n  };\n}\n\nasync function verifyInfrastructure(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  // Check PostgreSQL\n  const pgStart = Date.now();\n  try {\n    await db.execute(sql`SELECT 1`);\n    results.push({\n      category: 'Infrastructure',\n      check: 'PostgreSQL connectivity',\n      status: 'pass',\n      message: 'Database connection successful',\n      duration: Date.now() - pgStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Infrastructure',\n      check: 'PostgreSQL connectivity',\n      status: 'fail',\n      message: `Database connection failed: ${error.message}`,\n      duration: Date.now() - pgStart\n    });\n  }\n  \n  // Check Redis\n  const redisStart = Date.now();\n  try {\n    await redis.ping();\n    results.push({\n      category: 'Infrastructure',\n      check: 'Redis connectivity',\n      status: 'pass',\n      message: 'Redis connection successful',\n      duration: Date.now() - redisStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Infrastructure',\n      check: 'Redis connectivity',\n      status: 'fail',\n      message: `Redis connection failed: ${error.message}`,\n      duration: Date.now() - redisStart\n    });\n  }\n  \n  // Check Qdrant\n  const qdrantStart = Date.now();\n  try {\n    const collections = await qdrant.getCollections();\n    const hasProducts = collections.collections.some(c => c.name === 'products');\n    results.push({\n      category: 'Infrastructure',\n      check: 'Qdrant connectivity',\n      status: hasProducts ? 'pass' : 'warn',\n      message: hasProducts ? 'Qdrant connected with products collection' : 'Qdrant connected but products collection missing',\n      duration: Date.now() - qdrantStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Infrastructure',\n      check: 'Qdrant connectivity',\n      status: 'fail',\n      message: `Qdrant connection failed: ${error.message}`,\n      duration: Date.now() - qdrantStart\n    });\n  }\n  \n  // Check disk space\n  const diskStart = Date.now();\n  const diskUsage = await getDiskUsage();\n  results.push({\n    category: 'Infrastructure',\n    check: 'Disk space',\n    status: diskUsage < 80 ? 'pass' : diskUsage < 90 ? 'warn' : 'fail',\n    message: `Disk usage: ${diskUsage}%`,\n    duration: Date.now() - diskStart\n  });\n  \n  // Check memory\n  const memStart = Date.now();\n  const memAvailable = await getAvailableMemory();\n  results.push({\n    category: 'Infrastructure',\n    check: 'Available memory',\n    status: memAvailable > 10 ? 'pass' : memAvailable > 5 ? 'warn' : 'fail',\n    message: `Available memory: ${memAvailable}GB`,\n    duration: Date.now() - memStart\n  });\n  \n  return results;\n}\n\nasync function verifyDatabase(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  // Check schema version\n  const schemaStart = Date.now();\n  try {\n    const migrations = await db.execute(\n      sql`SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1`\n    );\n    const latestVersion = migrations.rows[0]?.version || 'unknown';\n    results.push({\n      category: 'Database',\n      check: 'Schema version',\n      status: 'pass',\n      message: `Latest migration: ${latestVersion}`,\n      duration: Date.now() - schemaStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Database',\n      check: 'Schema version',\n      status: 'fail',\n      message: `Cannot verify schema: ${error.message}`,\n      duration: Date.now() - schemaStart\n    });\n  }\n  \n  // Check table existence\n  const tablesStart = Date.now();\n  const requiredTables = [\n    'products', 'product_embeddings', 'negotiations', 'negotiation_messages',\n    'proposals', 'invoices', 'hitl_approvals', 'hitl_votes', 'guardrail_logs'\n  ];\n  \n  for (const table of requiredTables) {\n    try {\n      await db.execute(sql`SELECT 1 FROM ${sql.identifier(table)} LIMIT 1`);\n      results.push({\n        category: 'Database',\n        check: `Table: ${table}`,\n        status: 'pass',\n        message: `Table ${table} exists and accessible`,\n        duration: Date.now() - tablesStart\n      });\n    } catch (error) {\n      results.push({\n        category: 'Database',\n        check: `Table: ${table}`,\n        status: 'fail',\n        message: `Table ${table} not accessible: ${error.message}`,\n        duration: Date.now() - tablesStart\n      });\n    }\n  }\n  \n  // Check indexes\n  const indexStart = Date.now();\n  const indexCheck = await db.execute(sql`\n    SELECT COUNT(*) as count FROM pg_indexes \n    WHERE schemaname = 'public' AND tablename IN ('negotiations', 'hitl_approvals')\n  `);\n  const indexCount = indexCheck.rows[0]?.count || 0;\n  results.push({\n    category: 'Database',\n    check: 'Index health',\n    status: indexCount >= 10 ? 'pass' : 'warn',\n    message: `Found ${indexCount} indexes on critical tables`,\n    duration: Date.now() - indexStart\n  });\n  \n  return results;\n}\n\nasync function verifyQueues(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  const queues = [\n    'ai-orchestration',\n    'guardrails',\n    'hitl-approvals',\n    'negotiation-fsm',\n    'document-generation'\n  ];\n  \n  for (const queueName of queues) {\n    const start = Date.now();\n    try {\n      const waiting = await redis.llen(`bull:${queueName}:waiting`);\n      const active = await redis.llen(`bull:${queueName}:active`);\n      const failed = await redis.llen(`bull:${queueName}:failed`);\n      \n      const status = failed > 100 ? 'warn' : 'pass';\n      results.push({\n        category: 'Queues',\n        check: `Queue: ${queueName}`,\n        status,\n        message: `Waiting: ${waiting}, Active: ${active}, Failed: ${failed}`,\n        duration: Date.now() - start\n      });\n    } catch (error) {\n      results.push({\n        category: 'Queues',\n        check: `Queue: ${queueName}`,\n        status: 'fail',\n        message: `Cannot access queue: ${error.message}`,\n        duration: Date.now() - start\n      });\n    }\n  }\n  \n  return results;\n}\n\nasync function verifyAIServices(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  // Check OpenAI connectivity\n  const openaiStart = Date.now();\n  try {\n    const response = await fetch('https://api.openai.com/v1/models', {\n      headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY}` }\n    });\n    \n    if (response.ok) {\n      results.push({\n        category: 'AI Services',\n        check: 'OpenAI API',\n        status: 'pass',\n        message: 'OpenAI API accessible',\n        duration: Date.now() - openaiStart\n      });\n    } else {\n      results.push({\n        category: 'AI Services',\n        check: 'OpenAI API',\n        status: 'fail',\n        message: `OpenAI API returned ${response.status}`,\n        duration: Date.now() - openaiStart\n      });\n    }\n  } catch (error) {\n    results.push({\n      category: 'AI Services',\n      check: 'OpenAI API',\n      status: 'fail',\n      message: `OpenAI API error: ${error.message}`,\n      duration: Date.now() - openaiStart\n    });\n  }\n  \n  // Check MCP Server\n  const mcpStart = Date.now();\n  try {\n    const response = await fetch('http://localhost:3100/health');\n    if (response.ok) {\n      const health = await response.json();\n      results.push({\n        category: 'AI Services',\n        check: 'MCP Server',\n        status: 'pass',\n        message: `MCP Server healthy, ${health.tools_count || 0} tools available`,\n        duration: Date.now() - mcpStart\n      });\n    } else {\n      results.push({\n        category: 'AI Services',\n        check: 'MCP Server',\n        status: 'fail',\n        message: `MCP Server returned ${response.status}`,\n        duration: Date.now() - mcpStart\n      });\n    }\n  } catch (error) {\n    results.push({\n      category: 'AI Services',\n      check: 'MCP Server',\n      status: 'fail',\n      message: `MCP Server error: ${error.message}`,\n      duration: Date.now() - mcpStart\n    });\n  }\n  \n  return results;\n}\n\nasync function verifyAPIEndpoints(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  const endpoints = [\n    { path: '/api/health', method: 'GET', expectedStatus: 200 },\n    { path: '/api/etapa3/negotiations', method: 'GET', expectedStatus: 200 },\n    { path: '/api/etapa3/products', method: 'GET', expectedStatus: 200 },\n    { path: '/api/etapa3/hitl/approvals', method: 'GET', expectedStatus: 200 },\n    { path: '/api/etapa3/analytics/dashboard', method: 'GET', expectedStatus: 200 }\n  ];\n  \n  for (const endpoint of endpoints) {\n    const start = Date.now();\n    try {\n      const response = await fetch(`http://localhost:3000${endpoint.path}`, {\n        method: endpoint.method,\n        headers: { 'Authorization': `Bearer ${process.env.TEST_TOKEN}` }\n      });\n      \n      const status = response.status === endpoint.expectedStatus ? 'pass' : 'fail';\n      results.push({\n        category: 'API Endpoints',\n        check: `${endpoint.method} ${endpoint.path}`,\n        status,\n        message: `HTTP ${response.status} (expected ${endpoint.expectedStatus})`,\n        duration: Date.now() - start\n      });\n    } catch (error) {\n      results.push({\n        category: 'API Endpoints',\n        check: `${endpoint.method} ${endpoint.path}`,\n        status: 'fail',\n        message: `Request failed: ${error.message}`,\n        duration: Date.now() - start\n      });\n    }\n  }\n  \n  return results;\n}\n\nasync function verifyBusinessLogic(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  // Test FSM state machine\n  const fsmStart = Date.now();\n  try {\n    const validTransitions = [\n      { from: 'new', to: 'needs_discovery' },\n      { from: 'needs_discovery', to: 'product_presentation' },\n      { from: 'product_presentation', to: 'price_negotiation' },\n      { from: 'price_negotiation', to: 'won' }\n    ];\n    \n    // Verify FSM rules loaded\n    const fsmConfig = await redis.get('fsm:config');\n    results.push({\n      category: 'Business Logic',\n      check: 'FSM Configuration',\n      status: fsmConfig ? 'pass' : 'warn',\n      message: fsmConfig ? 'FSM configuration loaded' : 'FSM configuration not cached',\n      duration: Date.now() - fsmStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Business Logic',\n      check: 'FSM Configuration',\n      status: 'fail',\n      message: `FSM check failed: ${error.message}`,\n      duration: Date.now() - fsmStart\n    });\n  }\n  \n  // Test guardrail rules\n  const guardrailStart = Date.now();\n  try {\n    const rulesCount = await db.execute(\n      sql`SELECT COUNT(*) as count FROM guardrail_rules WHERE active = true`\n    );\n    const count = rulesCount.rows[0]?.count || 0;\n    results.push({\n      category: 'Business Logic',\n      check: 'Guardrail Rules',\n      status: count > 0 ? 'pass' : 'warn',\n      message: `${count} active guardrail rules`,\n      duration: Date.now() - guardrailStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Business Logic',\n      check: 'Guardrail Rules',\n      status: 'fail',\n      message: `Guardrail check failed: ${error.message}`,\n      duration: Date.now() - guardrailStart\n    });\n  }\n  \n  return results;\n}\n\nasync function verifyHITLSystem(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  // Check pending approvals count\n  const pendingStart = Date.now();\n  try {\n    const pending = await db.execute(\n      sql`SELECT COUNT(*) as count FROM hitl_approvals WHERE status = 'pending'`\n    );\n    const count = pending.rows[0]?.count || 0;\n    \n    results.push({\n      category: 'HITL System',\n      check: 'Pending Approvals',\n      status: count < 100 ? 'pass' : count < 500 ? 'warn' : 'fail',\n      message: `${count} pending approvals`,\n      duration: Date.now() - pendingStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'HITL System',\n      check: 'Pending Approvals',\n      status: 'fail',\n      message: `HITL check failed: ${error.message}`,\n      duration: Date.now() - pendingStart\n    });\n  }\n  \n  // Check SLA breaches\n  const slaStart = Date.now();\n  try {\n    const breaches = await db.execute(sql`\n      SELECT COUNT(*) as count FROM hitl_approvals \n      WHERE status = 'pending' \n      AND sla_deadline < NOW()\n    `);\n    const count = breaches.rows[0]?.count || 0;\n    \n    results.push({\n      category: 'HITL System',\n      check: 'SLA Breaches',\n      status: count === 0 ? 'pass' : count < 10 ? 'warn' : 'fail',\n      message: `${count} SLA breaches`,\n      duration: Date.now() - slaStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'HITL System',\n      check: 'SLA Breaches',\n      status: 'fail',\n      message: `SLA check failed: ${error.message}`,\n      duration: Date.now() - slaStart\n    });\n  }\n  \n  return results;\n}\n\nasync function verifyIntegrations(): Promise<VerificationResult[]> {\n  const results: VerificationResult[] = [];\n  \n  // Check ANAF connectivity (test endpoint)\n  const anafStart = Date.now();\n  try {\n    const response = await fetch('https://api.anaf.ro/test/PlatitorTvaRest/api/v8/ws/tva');\n    results.push({\n      category: 'Integrations',\n      check: 'ANAF API',\n      status: response.ok ? 'pass' : 'warn',\n      message: `ANAF API status: ${response.status}`,\n      duration: Date.now() - anafStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Integrations',\n      check: 'ANAF API',\n      status: 'warn',\n      message: `ANAF API check failed: ${error.message}`,\n      duration: Date.now() - anafStart\n    });\n  }\n  \n  // Check Oblio connectivity\n  const oblioStart = Date.now();\n  try {\n    const response = await fetch('https://www.oblio.eu/api/v1/nomenclature/companies', {\n      headers: { 'Authorization': `Bearer ${process.env.OBLIO_API_KEY}` }\n    });\n    results.push({\n      category: 'Integrations',\n      check: 'Oblio API',\n      status: response.ok ? 'pass' : 'warn',\n      message: `Oblio API status: ${response.status}`,\n      duration: Date.now() - oblioStart\n    });\n  } catch (error) {\n    results.push({\n      category: 'Integrations',\n      check: 'Oblio API',\n      status: 'warn',\n      message: `Oblio API check failed: ${error.message}`,\n      duration: Date.now() - oblioStart\n    });\n  }\n  \n  return results;\n}\n\n// Generate HTML report\nexport function generateHTMLReport(report: VerificationReport): string {\n  const statusColors = {\n    pass: '#22c55e',\n    warn: '#eab308',\n    fail: '#ef4444'\n  };\n  \n  const overallColors = {\n    success: '#22c55e',\n    partial: '#eab308',\n    failure: '#ef4444'\n  };\n  \n  return `\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>Post-Deployment Verification Report</title>\n      <style>\n        body { font-family: system-ui; margin: 40px; }\n        .header { border-bottom: 2px solid #e5e7eb; padding-bottom: 20px; margin-bottom: 20px; }\n        .summary { display: flex; gap: 20px; margin-bottom: 30px; }\n        .stat { padding: 20px; border-radius: 8px; background: #f9fafb; }\n        .stat-value { font-size: 32px; font-weight: bold; }\n        .category { margin-bottom: 30px; }\n        .category-title { font-size: 18px; font-weight: 600; margin-bottom: 10px; }\n        .check { display: flex; justify-content: space-between; padding: 10px; border-radius: 4px; margin-bottom: 5px; }\n        .check.pass { background: #f0fdf4; }\n        .check.warn { background: #fefce8; }\n        .check.fail { background: #fef2f2; }\n        .badge { padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 500; }\n      </style>\n    </head>\n    <body>\n      <div class=\"header\">\n        <h1>Post-Deployment Verification Report</h1>\n        <p>Deployment ID: ${report.deploymentId}</p>\n        <p>Timestamp: ${report.timestamp.toISOString()}</p>\n        <p>Overall Status: <span style=\"color: ${overallColors[report.overallStatus]}; font-weight: bold;\">\n          ${report.overallStatus.toUpperCase()}\n        </span></p>\n      </div>\n      \n      <div class=\"summary\">\n        <div class=\"stat\">\n          <div class=\"stat-value\" style=\"color: #22c55e;\">${report.summary.passed}</div>\n          <div>Passed</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"stat-value\" style=\"color: #eab308;\">${report.summary.warnings}</div>\n          <div>Warnings</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"stat-value\" style=\"color: #ef4444;\">${report.summary.failed}</div>\n          <div>Failed</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"stat-value\">${report.summary.total}</div>\n          <div>Total</div>\n        </div>\n      </div>\n      \n      ${generateCategorySections(report.results)}\n    </body>\n    </html>\n  `;\n}\n```",
  "director_implementare": "/var/www/CerniqAPP/scripts/verification",
  "restrictii_antihalucinatie": [
    "VERIFY all critical systems",
    "CHECK integrations connectivity",
    "VALIDATE business logic",
    "GENERATE comprehensive report",
    "AUTOMATE verification process"
  ],
  "validare_task": "1. Infrastructure checks pass\n2. Database verified\n3. Queues operational\n4. AI services connected\n5. HITL system functional",
  "outcome": "Verificări post-deployment complete pentru Etapa 3"
}
```

### F3.18.8 Go-Live Checklist (#99)

```json
{
  "taskID": "F3.18.8.T001",
  "denumire_task": "Go-Live Checklist complet pentru Etapa 3",
  "context_anterior": "Post-deployment verification definită. Acum creăm checklist-ul complet de go-live.",
  "descriere_task": "Ești un expert în release management și go-live procedures. Task-ul tău este să creezi checklist-ul complet de go-live.\n\n## Go-Live Checklist - Etapa 3 AI Sales Agent\n\n### Pre-Go-Live Checklist (T-7 Days)\n\n#### 1. Documentation Review\n- [ ] All technical documentation reviewed and approved\n- [ ] API documentation complete and published\n- [ ] Runbooks reviewed by operations team\n- [ ] User guides prepared for support team\n- [ ] Training materials ready for sales team\n\n#### 2. Code Freeze & Testing\n- [ ] Code freeze implemented (no new features)\n- [ ] All unit tests passing (>80% coverage)\n- [ ] Integration tests passing\n- [ ] E2E tests passing on staging\n- [ ] Performance tests meet SLA requirements\n- [ ] Security scan completed with no critical issues\n- [ ] Penetration test report reviewed\n\n#### 3. Infrastructure Preparation\n- [ ] Production environment provisioned\n- [ ] Database migrations tested in staging\n- [ ] Backup systems configured and tested\n- [ ] Monitoring dashboards configured\n- [ ] Alert thresholds set\n- [ ] SSL certificates valid (>30 days)\n- [ ] DNS records prepared\n\n#### 4. External Dependencies\n- [ ] OpenAI API key production-ready\n- [ ] Oblio production credentials configured\n- [ ] ANAF e-Factura SPV certificates installed\n- [ ] Email service (Sendgrid/SES) configured\n- [ ] WhatsApp Business API ready\n- [ ] Qdrant production cluster sized\n\n### Pre-Go-Live Checklist (T-1 Day)\n\n#### 5. Final Verification\n- [ ] Staging environment mirrors production\n- [ ] All secrets rotated and secured\n- [ ] Feature flags configured\n- [ ] Rate limits configured\n- [ ] Queue workers scaled appropriately\n- [ ] Load balancer configured\n- [ ] CDN configured (if applicable)\n\n#### 6. Team Readiness\n- [ ] On-call schedule confirmed\n- [ ] Escalation paths documented\n- [ ] War room scheduled\n- [ ] Rollback plan reviewed with team\n- [ ] Communication channels ready (Slack, email)\n- [ ] Status page prepared\n\n#### 7. Business Readiness\n- [ ] Stakeholders notified of go-live\n- [ ] Support team trained\n- [ ] Customer communication prepared\n- [ ] Legal/compliance approval obtained\n- [ ] GDPR compliance verified\n- [ ] Data processing agreements in place\n\n### Go-Live Day Checklist (D-Day)\n\n#### 8. Morning Checks (T-2h)\n```bash\n#!/bin/bash\n# go-live-morning-checks.sh\n\necho \"=== Go-Live Morning Checks ===\"\necho \"Date: $(date)\"\necho \"\"\n\n# Check all systems healthy\necho \"[1/8] System Health...\"\ncurl -sf http://localhost:3000/api/health || exit 1\necho \"✓ API healthy\"\n\n# Check database\necho \"[2/8] Database...\"\ndocker exec cerniq-postgres pg_isready || exit 1\necho \"✓ Database ready\"\n\n# Check queues empty/minimal\necho \"[3/8] Queue Depth...\"\nQUEUE_DEPTH=$(docker exec cerniq-redis redis-cli LLEN bull:ai-orchestration:waiting)\nif [ \"$QUEUE_DEPTH\" -gt 100 ]; then\n  echo \"⚠ High queue depth: $QUEUE_DEPTH\"\nfi\necho \"✓ Queue depth: $QUEUE_DEPTH\"\n\n# Check disk space\necho \"[4/8] Disk Space...\"\ndf -h /data\necho \"✓ Disk checked\"\n\n# Check memory\necho \"[5/8] Memory...\"\nfree -h\necho \"✓ Memory checked\"\n\n# Check OpenAI API\necho \"[6/8] OpenAI API...\"\ncurl -sf https://api.openai.com/v1/models \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" > /dev/null || exit 1\necho \"✓ OpenAI accessible\"\n\n# Check Oblio API\necho \"[7/8] Oblio API...\"\ncurl -sf https://www.oblio.eu/api/v1/health \\\n  -H \"Authorization: Bearer $OBLIO_API_KEY\" > /dev/null\necho \"✓ Oblio accessible\"\n\n# Check backup\necho \"[8/8] Backup...\"\nls -la /data/backups/*.backup | tail -1\necho \"✓ Backup verified\"\n\necho \"\"\necho \"=== All Morning Checks Passed ===\"\n```\n\n#### 9. Deployment Window\n- [ ] Announce maintenance window\n- [ ] Enable maintenance mode (optional)\n- [ ] Run pre-deployment checks\n- [ ] Create pre-deployment backup\n- [ ] Deploy database migrations\n- [ ] Deploy workers (rolling)\n- [ ] Deploy API\n- [ ] Verify all containers running\n- [ ] Run post-deployment verification\n- [ ] Disable maintenance mode\n\n#### 10. Smoke Tests\n```typescript\n// go-live-smoke-tests.ts\n\nasync function runSmokeTests(): Promise<boolean> {\n  const results: { test: string; passed: boolean }[] = [];\n  \n  // Test 1: Create negotiation\n  console.log('[1/5] Testing negotiation creation...');\n  try {\n    const response = await fetch('/api/etapa3/negotiations', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },\n      body: JSON.stringify({\n        contact_id: TEST_CONTACT_ID,\n        channel: 'test'\n      })\n    });\n    results.push({ test: 'Create Negotiation', passed: response.ok });\n  } catch (e) {\n    results.push({ test: 'Create Negotiation', passed: false });\n  }\n  \n  // Test 2: Send message & AI response\n  console.log('[2/5] Testing AI response...');\n  try {\n    const response = await fetch(`/api/etapa3/negotiations/${TEST_NEG_ID}/messages`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },\n      body: JSON.stringify({\n        content: 'Ce produse aveți pentru porumb?',\n        sender: 'contact'\n      })\n    });\n    // Wait for AI response\n    await sleep(15000);\n    const messages = await fetch(`/api/etapa3/negotiations/${TEST_NEG_ID}/messages`);\n    const data = await messages.json();\n    const hasAIResponse = data.some(m => m.sender === 'ai_agent');\n    results.push({ test: 'AI Response', passed: hasAIResponse });\n  } catch (e) {\n    results.push({ test: 'AI Response', passed: false });\n  }\n  \n  // Test 3: Product search (RAG)\n  console.log('[3/5] Testing product search...');\n  try {\n    const response = await fetch('/api/etapa3/products/search?q=erbicid+porumb');\n    const data = await response.json();\n    results.push({ test: 'Product Search (RAG)', passed: data.results?.length > 0 });\n  } catch (e) {\n    results.push({ test: 'Product Search (RAG)', passed: false });\n  }\n  \n  // Test 4: HITL approval creation\n  console.log('[4/5] Testing HITL system...');\n  try {\n    // Trigger a high discount to create HITL approval\n    const approval = await fetch(`/api/etapa3/hitl/approvals?negotiation_id=${TEST_NEG_ID}`);\n    results.push({ test: 'HITL System', passed: approval.ok });\n  } catch (e) {\n    results.push({ test: 'HITL System', passed: false });\n  }\n  \n  // Test 5: Analytics endpoint\n  console.log('[5/5] Testing analytics...');\n  try {\n    const response = await fetch('/api/etapa3/analytics/dashboard');\n    results.push({ test: 'Analytics Dashboard', passed: response.ok });\n  } catch (e) {\n    results.push({ test: 'Analytics Dashboard', passed: false });\n  }\n  \n  // Print results\n  console.log('\\n=== Smoke Test Results ===');\n  results.forEach(r => {\n    console.log(`${r.passed ? '✓' : '✗'} ${r.test}`);\n  });\n  \n  const allPassed = results.every(r => r.passed);\n  console.log(`\\nOverall: ${allPassed ? 'PASSED' : 'FAILED'}`);\n  \n  return allPassed;\n}\n```\n\n#### 11. Monitoring Activation\n- [ ] Verify Grafana dashboards loading\n- [ ] Verify SigNoz traces appearing\n- [ ] Verify Prometheus metrics collecting\n- [ ] Verify alerts firing correctly\n- [ ] Enable PagerDuty/Slack alerts\n- [ ] Start real-time monitoring in war room\n\n### Post-Go-Live Checklist (D+1)\n\n#### 12. 24-Hour Review\n- [ ] Review all metrics from first 24 hours\n- [ ] Check error rates (target <1%)\n- [ ] Check response times (target p99 <5s)\n- [ ] Check AI response quality (sample review)\n- [ ] Review HITL approval queue\n- [ ] Check guardrail activation rate\n- [ ] Review any incidents\n- [ ] Document lessons learned\n\n#### 13. Stakeholder Communication\n- [ ] Send go-live success/status email\n- [ ] Update status page\n- [ ] Notify support team of any known issues\n- [ ] Schedule post-mortem (if incidents)\n- [ ] Plan Phase 2 improvements\n\n### Rollback Decision Matrix\n\n| Scenario | Impact | Action | Timeframe |\n|----------|--------|--------|----------|\n| API returning 500s >10% | High | Immediate rollback | <15 min |\n| AI responses hallucinating | Critical | Disable AI, enable human-only | <5 min |\n| Database corruption | Critical | Full rollback | <30 min |\n| Single worker failing | Low | Component rollback | <10 min |\n| High latency (>10s p99) | Medium | Scale workers or rollback | <20 min |\n| HITL queue backing up | Medium | Disable auto-escalation, manual clear | <30 min |\n| External API down (ANAF) | Low | Enable fallback mode | Immediate |\n\n### Emergency Contacts\n\n| Role | Name | Phone | Availability |\n|------|------|-------|-------------|\n| Tech Lead | [Name] | [Phone] | 24/7 |\n| DevOps | [Name] | [Phone] | 24/7 |\n| Database Admin | [Name] | [Phone] | Business hours |\n| Product Owner | [Name] | [Phone] | Business hours |\n| ANAF Support | Support Line | [Phone] | Business hours |\n| Oblio Support | Support Line | [Phone] | Business hours |\n\n### Success Criteria\n\n```typescript\ninterface GoLiveSuccessCriteria {\n  technical: {\n    uptime: number;           // Target: 99.9%\n    errorRate: number;        // Target: <1%\n    p99Latency: number;       // Target: <5000ms\n    aiResponseTime: number;   // Target: <10000ms\n  };\n  business: {\n    conversationsStarted: number;  // Target: >0\n    aiResponsesGenerated: number;  // Target: >0\n    guardrailsWorking: boolean;    // All passing\n    hitlSystemOperational: boolean; // Processing approvals\n  };\n  integration: {\n    anafConnected: boolean;\n    oblioConnected: boolean;\n    emailDelivering: boolean;\n    whatsappConnected: boolean;\n  };\n}\n\nexport const GO_LIVE_SUCCESS: GoLiveSuccessCriteria = {\n  technical: {\n    uptime: 99.9,\n    errorRate: 1,\n    p99Latency: 5000,\n    aiResponseTime: 10000\n  },\n  business: {\n    conversationsStarted: 1,\n    aiResponsesGenerated: 1,\n    guardrailsWorking: true,\n    hitlSystemOperational: true\n  },\n  integration: {\n    anafConnected: true,\n    oblioConnected: true,\n    emailDelivering: true,\n    whatsappConnected: true\n  }\n};\n```",
  "director_implementare": "/var/www/CerniqAPP/docs/go-live",
  "restrictii_antihalucinatie": [
    "COMPLETE all checklist items",
    "VERIFY before deployment",
    "HAVE rollback ready",
    "MONITOR after go-live",
    "DOCUMENT everything"
  ],
  "validare_task": "1. Pre-go-live complete\n2. Deployment successful\n3. Smoke tests passing\n4. Monitoring active\n5. Success criteria met",
  "outcome": "Go-Live Checklist complet pentru Etapa 3"
}
```

---

## F3.19 Summary și Metrici Finale

### 19.1 Statistici Implementare

```yaml
etapa3_statistics:
  total_tasks: 99
  tasks_by_category:
    database_schema: 1
    product_knowledge: 6
    hybrid_search_rag: 5
    ai_orchestration: 5
    negotiation_fsm: 7
    pricing_discount: 5
    stock_inventory: 3
    oblio_integration: 3
    efactura_spv: 3
    document_generation: 4
    handover_channel: 4
    intent_detection: 2
    mcp_server: 2
    guardrails: 3
    hitl_system: 3
    frontend_uiux: 20
    testing_qa: 6
    integration_deployment: 8
  
  estimated_effort:
    senior_developer_weeks: 16-20
    total_story_points: 450
    risk_level: high
    complexity: very_high
  
  dependencies:
    etapa1: "Data enrichment pipeline (Bronze/Silver/Gold)"
    etapa2: "Cold outreach infrastructure (channels, templates)"
    external:
      - "OpenAI API (GPT-4o)"
      - ""
      - "ANAF e-Factura SPV"
      - "Oblio.eu facturare"
      - "WhatsApp Business API"
      - "Email service (SendGrid/SES)"
```

### 19.2 Arhitectura Finală Etapa 3

```text
┌────────────────────────────────────────────────────────────────────┐
│                        ETAPA 3: AI SALES AGENT                     │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  ┌──────────────┐    ┌──────────────┐    ┌─────────────────┐       │
│  │   Frontend   │◄──►│   API Layer  │◄──►│  Queue System   │       │
│  │(React 19.2.3)│    │  (Fastify)   │    │   (BullMQ)      │       │
│  └──────────────┘    └──────────────┘    └───────┬─────────┘       │
│                                                  │                 │
│  ┌───────────────────────────────────────────────┼─────────────┐   │
│  │                    WORKER LAYER               │             │   │
│  │                                               │             │   │
│  │  ┌────────────────┐    ┌────────────────┐     │             │   │
│  │  │ AI Orchestrator│◄──►│  MCP Server    │     │             │   │
│  │  │   (Core)       │    │  (Tools)       │     │             │   │
│  │  └───────┬────────┘    └────────────────┘     │             │   │
│  │          │                                    │             │   │
│  │  ┌───────▼────────┐    ┌────────────────┐     │             │   │
│  │  │  Guardrails    │◄──►│   HITL System  │     │             │   │
│  │  │  (Anti-halluc) │    │  (Approvals)   │     │             │   │
│  │  └───────┬────────┘    └────────────────┘     │             │   │
│  │          │                                    │             │   │
│  │  ┌───────▼────────┐    ┌────────────────┐     │             │   │
│  │  │ Negotiation FSM│◄──►│ Pricing Engine │     │             │   │
│  │  │  (States)      │    │ (Discounts)    │     │             │   │
│  │  └───────┬────────┘    └────────────────┘     │             │   │
│  │          │                                    │             │   │
│  │  ┌───────▼────────┐    ┌────────────────┐     │             │   │
│  │  │ Document Gen   │◄──►│ Invoice Worker │     │             │   │
│  │  │ (Proposals)    │    │ (Oblio/ANAF)   │     │             │   │
│  │  └────────────────┘    └────────────────┘     │             │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    DATA LAYER                               │   │
│  │                                                             │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │   │
│  │  │  PostgreSQL  │  │    Redis     │  │   pgvector   │       │   │
│  │  │  (Primary)   │  │   (Cache)    │  │  (Vectors)   │       │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘       │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 19.3 Fluxul Principal de Procesare

```text
Contact Message → API Gateway → BullMQ Queue
                                    │
                    ┌───────────────▼───────────────┐
                    │     AI Orchestration Worker   │
                    │                               │
                    │  1. Load context (FSM state)  │
                    │  2. Build prompt (RAG search) │
                    │  3. Call LLM (OpenAI)         │
                    │  4. Parse tool calls          │
                    │  5. Execute tools (MCP)       │
                    │  6. Generate response         │
                    └───────────────┬───────────────┘
                                    │
                    ┌───────────────▼───────────────┐
                    │       Guardrails Worker       │
                    │                               │
                    │  1. Validate prices           │
                    │  2. Check stock claims        │
                    │  3. Detect hallucinations     │
                    │  4. Verify compliance         │
                    └───────────────┬───────────────┘
                                    │
                         ┌──────────┴──────────┐
                         │                     │
                    [PASS]                [FAIL/CRITICAL]
                         │                     │
                         ▼                     ▼
                    Send Response     ┌────────────────┐
                    Update FSM State  │  HITL Worker   │
                                      │                │
                                      │ Create approval│
                                      │ Notify approver│
                                      │ Wait decision  │
                                      └───────┬────────┘
                                              │
                                    ┌─────────┴─────────┐
                                    │                   │
                               [APPROVED]          [REJECTED]
                                    │                   │
                                    ▼                   ▼
                               Send Response      Regenerate with
                               (possibly modified) correction prompt
```

### 19.4 KPI și Metrici de Succes

```typescript
interface Etapa3KPIs {
  // Performance KPIs
  performance: {
    aiResponseTime: { target: 8000, unit: 'ms', measurement: 'p95' };
    apiLatency: { target: 500, unit: 'ms', measurement: 'p99' };
    queueProcessingTime: { target: 5000, unit: 'ms', measurement: 'avg' };
    systemUptime: { target: 99.9, unit: '%', measurement: 'monthly' };
  };
  
  // Quality KPIs
  quality: {
    guardrailPassRate: { target: 95, unit: '%', measurement: 'weekly' };
    hitlEscalationRate: { target: 10, unit: '%', measurement: 'weekly' };
    aiAccuracyRate: { target: 98, unit: '%', measurement: 'sampled' };
    hallucinationRate: { target: 0.5, unit: '%', measurement: 'weekly' };
  };
  
  // Business KPIs
  business: {
    conversionRate: { target: 15, unit: '%', measurement: 'monthly' };
    averageDealSize: { target: 5000, unit: 'EUR', measurement: 'monthly' };
    responseTime: { target: 30, unit: 'seconds', measurement: 'avg' };
    customerSatisfaction: { target: 4.5, unit: '/5', measurement: 'survey' };
  };
  
  // Operational KPIs
  operational: {
    errorRate: { target: 1, unit: '%', measurement: 'daily' };
    slaComplianceRate: { target: 95, unit: '%', measurement: 'weekly' };
    backlogSize: { target: 50, unit: 'items', measurement: 'realtime' };
    incidentResponseTime: { target: 15, unit: 'minutes', measurement: 'avg' };
  };
}
```

### 19.5 Riscuri și Mitigări

| Risc | Probabilitate | Impact | Mitigare |
| ---- | ------------- | ------ | -------- |
| AI Hallucinations | Medium | Critical | Multi-layer guardrails, HITL mandatory for critical |
| OpenAI API Downtime | Low | High | Fallback model (Claude), cached responses |
| ANAF SPV Failures | Medium | Medium | Queue retry, manual fallback |
| High HITL Backlog | Medium | Medium | Auto-approval rules, SLA escalation |
| Data Privacy Breach | Low | Critical | Encryption, audit logs, GDPR compliance |
| Performance Degradation | Medium | Medium | Auto-scaling, queue throttling |
| Integration Failures | Medium | Medium | Circuit breakers, graceful degradation |

### 19.6 Roadmap Post-Implementare

```yaml
phase_1_stabilization: # Weeks 1-4
  focus: "Stability and monitoring"
  activities:
    - Monitor guardrail effectiveness
    - Tune HITL thresholds
    - Optimize AI prompts
    - Fix edge cases
    
phase_2_optimization: # Weeks 5-8
  focus: "Performance and quality"
  activities:
    - Fine-tune AI responses
    - Reduce hallucination rate
    - Optimize response times
    - Implement caching strategies
    
phase_3_expansion: # Weeks 9-12
  focus: "Feature expansion"
  activities:
    - Add more product categories
    - Implement advanced negotiations
    - Expand channel support
    - Add analytics features
    
phase_4_automation: # Weeks 13-16
  focus: "Full automation"
  activities:
    - Reduce HITL dependency
    - Implement auto-learning
    - Add predictive features
    - Expand integrations
```

### 19.7 Documente Referință Complete

| Document | Descriere | Linii | Status |
| -------- | --------- | ----- | ------ |
| etapa3-plan-implementare.md | Plan detaliat de implementare | ~2000 | ✅ |
| etapa3-standards.md | Standarde tehnice și coding | ~4000 | ✅ |
| etapa3-standards-procedures.md | Proceduri operaționale | ~1200 | ✅ |
| etapa3-hitl-system.md | Sistem HITL complet | ~15000 | ✅ |
| etapa3-api-endpoints.md | Documentație API | ~2500 | ✅ |
| etapa3-monitoring-observability.md | Monitoring și alerting | ~8000 | ✅ |
| etapa3-runbook-operational.md | Runbook operațional | ~2500 | ✅ |
| etapa3-runbook-monitoring.md | Runbook monitoring | ~1200 | ✅ |
| etapa3-testing-strategy.md | Strategie de testare | ~1200 | ✅ |
| etapa3-adrs.md | Architecture Decision Records | ~1000 | ✅ |
| etapa3-migrations.md | Database migrations | ~1800 | ✅ |
| etapa3-schema-*.md | Database schemas (3 files) | ~3500 | ✅ |
| etapa3-ui-*.md | Frontend UI/UX (6 files) | ~60000 | ✅ |
| etapa3-workers-*.md | Worker documentation (14 files) | ~80000 | ✅ |

**Total Documentație Etapa 3: ~180,000+ linii de cod și documentație**

---

## Anexă A: Referințe și Dependențe

### A.1 Dependențe Externe

```yaml
external_dependencies:
  openai:
    service: "OpenAI API"
    models: ["gpt-4o", "gpt-4o-mini"]
    pricing: "Pay per token"
    sla: "99.9% uptime"
    fallback: "Claude 3.5 Sonnet"
    
  qdrant:
    service: "PostgreSQL + pgvector"
    version: "1.12.x"
    purpose: "Vector similarity search"
    collections: ["products", "conversations"]
    
  anaf:
    service: "ANAF e-Factura SPV"
    endpoint: "https://api.anaf.ro/prod/FCTEL/rest"
    auth: "Certificate-based"
    sandbox: "https://api.anaf.ro/test/FCTEL/rest"
    
  oblio:
    service: "Oblio.eu Invoice API"
    version: "v1"
    purpose: "Invoice management"
    auth: "API Key + Secret"
    
  whatsapp:
    service: "WhatsApp Business API"
    provider: "Meta Cloud API"
    purpose: "Channel integration"
    
  email:
    service: "SendGrid / Amazon SES"
    purpose: "Email notifications"
    templates: true
```

### A.2 Versiuni Tehnologii

```yaml
technology_versions:
  runtime:
    node: "24.12.0 LTS"
    npm: "10.9.2"
    pnpm: "9.x"
    
  framework:
    fastify: "5.6.2"
    react: "19.x"
    typescript: "5.7.x"
    
  database:
    postgresql: "18.1"
    redis: "8.4.0"
    qdrant: "1.12.x"
    drizzle: "0.39.x"
    
  queue:
    bullmq: "5.x"
    
  testing:
    vitest: "3.x"
    playwright: "1.49.x"
    k6: "0.55.x"
    
  monitoring:
    signoz: "latest"
    prometheus: "2.x"
    grafana: "11.x"
```

### A.3 Integrări Etape Anterioare

```yaml
etapa1_integration:
  database_tables:
    - contacts_bronze
    - contacts_silver
    - contacts_gold
    - company_data
    - enrichment_logs
  services:
    - Data enrichment pipeline
    - Scoring algorithms
    - Deduplication
    
etapa2_integration:
  database_tables:
    - outreach_campaigns
    - outreach_messages
    - channel_configs
    - templates
  services:
    - Channel orchestration
    - Template rendering
    - Message tracking
```

---

## Anexă B: Changelog

### Version History

| Version | Data | Modificări |
| ------- | ---- | ---------- |
| 1.0.0 | 2026-01-19 | Versiune inițială completă |

### Contributors

- **Author**: Claude AI Assistant
- **Project**: Cerniq App - B2B Agricultural Sales Platform
- **Owner**: Alex

---

## Anexă C: Glosar de Termeni

| Termen | Definiție |
| ------ | --------- |
| **FSM** | Finite State Machine - mașină de stări pentru negocieri |
| **HITL** | Human-in-the-Loop - intervenție umană în procesare |
| **RAG** | Retrieval Augmented Generation - căutare semantică + LLM |
| **MCP** | Model Context Protocol - protocol pentru tools AI |
| **SPV** | Serviciul de Predare Verificare - sistem ANAF e-Factura |
| **Guardrail** | Verificare automată pentru prevenire halucinații |
| **Handover** | Transfer conversație de la AI la operator uman |
| **Embedding** | Reprezentare vectorială pentru căutare semantică |

---

## Anexă D: Structura Finală Documente Etapa 3

```text
/home/claude/etapa3-docs/
├── 00-INDEX-ETAPA3.md              # Index principal
├── etapa3-plan-implementare.md      # Plan detaliat (acest document)
├── etapa3-adrs.md                   # Architecture Decision Records
├── etapa3-standards.md              # Standarde tehnice
├── etapa3-standards-procedures.md   # Proceduri operaționale
│
├── # Schemes Database
├── etapa3-schema-products.md        # Schema produse
├── etapa3-schema-negotiations.md    # Schema negocieri
├── etapa3-schema-fiscal.md          # Schema facturare
├── etapa3-migrations.md             # Migrații database
│
├── # API & Backend
├── etapa3-api-endpoints.md          # Documentație API
├── etapa3-hitl-system.md            # Sistem HITL complet
│
├── # Workers
├── etapa3-workers-overview.md       # Overview workers
├── etapa3-workers-triggers.md       # Trigger patterns
├── etapa3-workers-A-product-knowledge.md
├── etapa3-workers-B-hybrid-search.md
├── etapa3-workers-C-ai-agent-core.md
├── etapa3-workers-D-negotiation-fsm.md
├── etapa3-workers-E-pricing-discount.md
├── etapa3-workers-F-stock-inventory.md
├── etapa3-workers-G-oblio-integration.md
├── etapa3-workers-H-efactura-spv.md
├── etapa3-workers-I-document-generation.md
├── etapa3-workers-J-handover-channel.md
├── etapa3-workers-K-sentiment-intent.md
├── etapa3-workers-L-mcp-server.md
├── etapa3-workers-M-guardrails.md
├── etapa3-workers-N-human-intervention.md
│
├── # Frontend UI/UX
├── etapa3-ui-pages.md               # Pagini principale
├── etapa3-ui-components.md          # Componente React
├── etapa3-ui-forms-dialogs.md       # Formulare și dialoguri
├── etapa3-ui-tables.md              # Tabele și DataTables
├── etapa3-ui-charts-navigation.md   # Grafice și navigație
│
├── # Operations
├── etapa3-monitoring-observability.md  # Monitoring
├── etapa3-runbook-operational.md       # Runbook operații
├── etapa3-runbook-monitoring.md        # Runbook monitoring
├── etapa3-testing-strategy.md          # Strategie testare
└── ...
```

---

**Document generat**: 2026-01-19  
**Proiect**: Cerniq App - Etapa 3 AI Sales Agent  
**Status**: COMPLET ✅  
**Linii documentație**: ~2000 (acest document), ~180,000+ (total Etapa 3)  
**Tasks definite**: 99 task-uri granulare  

---

*Acest document face parte din documentația completă a platformei Cerniq App pentru automatizarea vânzărilor B2B în sectorul agricol din România.*
