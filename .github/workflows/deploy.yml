# =============================================================================
# CERNIQ.APP ‚Äî CD Pipeline for Deployments
# =============================================================================
# Workflow: deploy.yml
# Trigger: 
#   - Push to feature/*, develop ‚Üí Staging
#   - Push to main ‚Üí Production  
#   - Git tags (v*.*.*) ‚Üí Production
#   - Manual dispatch
# Purpose: Build, Push to Registry, Deploy to Environment
# 
# Reference: ADR-0107 CI/CD Pipeline Strategy
# Created: 2026-02-01
# Updated: 2026-02-03 - Added branch triggers for auto-deploy
# =============================================================================

name: CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'feat/**'
      - 'fix/**'
      - 'hotfix/**'
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (e.g., v1.0.0)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/cerniq

jobs:
  # ===========================================================================
  # JOB 1: Determine Environment and Version
  # ===========================================================================
  setup:
    name: üîß Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine.outputs.environment }}
      version: ${{ steps.determine.outputs.version }}
      sha: ${{ steps.determine.outputs.sha }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Determine deployment parameters
        id: determine
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            # Tag push - extract version from tag
            TAG="${{ github.ref_name }}"
            echo "version=${TAG}" >> $GITHUB_OUTPUT
            
            # Production for release tags (v1.0.0), staging for pre-release (v1.0.0-rc.1)
            if [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
            else
              echo "environment=staging" >> $GITHUB_OUTPUT
            fi
          else
            # Branch push - determine environment by branch name
            BRANCH="${{ github.ref_name }}"
            SHORT_SHA="${{ github.sha }}"
            SHORT_SHA="${SHORT_SHA:0:7}"
            
            if [[ "$BRANCH" == "main" ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
              echo "version=main-${SHORT_SHA}" >> $GITHUB_OUTPUT
            else
              # All other branches (develop, feature/*, feat/*, fix/*, hotfix/*) ‚Üí staging
              echo "environment=staging" >> $GITHUB_OUTPUT
              # Sanitize branch name for version tag
              SAFE_BRANCH=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9]/-/g' | cut -c1-20)
              echo "version=${SAFE_BRANCH}-${SHORT_SHA}" >> $GITHUB_OUTPUT
            fi
          fi
          echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: üìã Display deployment info
        run: |
          echo "üéØ Environment: ${{ steps.determine.outputs.environment }}"
          echo "üè∑Ô∏è Version: ${{ steps.determine.outputs.version }}"
          echo "üìù SHA: ${{ steps.determine.outputs.sha }}"

  # ===========================================================================
  # JOB 2: Build and Push Docker Images
  # ===========================================================================
  build-push:
    name: üê≥ Build & Push Images
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        app:
          - name: api
            context: ./apps/api
          - name: web
            context: ./apps/web
          - name: web-admin
            context: ./apps/web-admin
          - name: worker-ai
            context: ./workers/ai
          - name: worker-enrichment
            context: ./workers/enrichment
          - name: worker-outreach
            context: ./workers/outreach

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üìã Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.app.name }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.setup.outputs.version }}
            type=sha,prefix=sha-

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.app.context }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.setup.outputs.version }}
            BUILD_SHA=${{ needs.setup.outputs.sha }}

  # ===========================================================================
  # JOB 3: Security Scan Published Images
  # ===========================================================================
  scan-images:
    name: üîí Scan Images
    runs-on: ubuntu-latest
    needs: [setup, build-push]
    continue-on-error: true

    strategy:
      matrix:
        app: [api, web, web-admin, worker-ai, worker-enrichment, worker-outreach]

    steps:
      - name: üîí Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.app }}:${{ needs.setup.outputs.version }}'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
          format: 'sarif'
          output: 'trivy-${{ matrix.app }}.sarif'

      - name: üì§ Upload scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-${{ matrix.app }}.sarif'
          category: 'trivy-${{ matrix.app }}'

  # ===========================================================================
  # JOB 4: Deploy to Staging
  # ===========================================================================
  deploy-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [setup, build-push]
    if: needs.setup.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.cerniq.app

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: üöÄ Deploy via Docker Compose
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ENDSSH'
            cd /opt/cerniq
            
            # Pull latest images
            docker compose pull || echo "No images to pull yet"
            
            # Update with zero-downtime
            docker compose up -d --remove-orphans
            
            # Health check for PostgreSQL
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30
            
            # Check PostgreSQL health
            if docker ps --format '{{.Names}}' | grep -q "cerniq-postgres"; then
              docker exec cerniq-postgres pg_isready -U postgres || echo "PostgreSQL starting..."
            fi
            
            echo "‚úÖ Staging deployment complete: ${{ needs.setup.outputs.version }}"
          ENDSSH

      - name: üß™ Run Infrastructure Validation Tests
        continue-on-error: true
        run: |
          # Copy validation script to server
          scp -i ~/.ssh/deploy_key infra/scripts/validate-infrastructure.sh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:/tmp/ || echo "Script copy failed"
          
          # Run validation tests on server
          ssh -i ~/.ssh/deploy_key ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ENDSSH'
            if [ -f /tmp/validate-infrastructure.sh ]; then
              chmod +x /tmp/validate-infrastructure.sh
              /tmp/validate-infrastructure.sh staging || true
            else
              echo "‚ö†Ô∏è  Validation script not available"
            fi
          ENDSSH

      - name: üì§ Upload Validation Results
        if: always()
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: staging-validation-results
          path: /tmp/validation-results.json
          retention-days: 30
          if-no-files-found: ignore

      - name: üì¢ Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "${{ job.status == 'success' && '‚úÖ' || '‚ùå' }} Staging deployment ${{ job.status }}: ${{ needs.setup.outputs.version }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ===========================================================================
  # JOB 5: Deploy to Production
  # ===========================================================================
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: [setup, build-push, scan-images]
    if: needs.setup.outputs.environment == 'production'
    environment:
      name: production
      url: https://app.cerniq.app

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: üîÑ Create database backup
        continue-on-error: true
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            cd /opt/cerniq
            # Run backup script if it exists
            if [ -f ./scripts/backup-pre-deploy.sh ]; then
              chmod +x ./scripts/backup-pre-deploy.sh
              ./scripts/backup-pre-deploy.sh
            else
              echo "‚ö†Ô∏è  Backup script not found, skipping (normal for initial deployment)"
            fi
          ENDSSH

      - name: üöÄ Deploy via Docker Compose
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            cd /opt/cerniq
            
            # Use docker-compose.yml (production overlay will be added later)
            # Pull latest images
            docker compose pull || echo "No images to pull yet"
            
            # Deploy infrastructure services
            docker compose up -d --remove-orphans
            
            # Health check for PostgreSQL (main service for now)
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30
            
            # Check PostgreSQL health
            if docker ps --format '{{.Names}}' | grep -q "cerniq-postgres"; then
              docker exec cerniq-postgres pg_isready -U postgres || echo "PostgreSQL starting..."
            fi
            
            echo "‚úÖ Production deployment complete: ${{ needs.setup.outputs.version }}"
          ENDSSH

      - name: üß™ Run Infrastructure Validation Tests
        continue-on-error: true
        run: |
          # Copy validation script to server
          scp -i ~/.ssh/deploy_key infra/scripts/validate-infrastructure.sh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/ || echo "Script copy failed"
          
          # Run validation tests on server
          ssh -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            if [ -f /tmp/validate-infrastructure.sh ]; then
              chmod +x /tmp/validate-infrastructure.sh
              /tmp/validate-infrastructure.sh production || true
            else
              echo "‚ö†Ô∏è  Validation script not available"
            fi
          ENDSSH

      - name: üì§ Upload Validation Results
        if: always()
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: production-validation-results
          path: /tmp/validation-results.json
          retention-days: 90
          if-no-files-found: ignore

      - name: üì¢ Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "${{ job.status == 'success' && '‚úÖ' || '‚ùå' }} Production deployment ${{ job.status }}: ${{ needs.setup.outputs.version }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ===========================================================================
  # JOB 6: Post-Deployment Verification
  # ===========================================================================
  verify:
    name: ‚úÖ Verify Deployment
    runs-on: ubuntu-latest
    needs: [setup, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH for verification
        run: |
          mkdir -p ~/.ssh
          ENV=${{ needs.setup.outputs.environment }}
          if [[ "$ENV" == "production" ]]; then
            echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
            HOST="${{ secrets.PRODUCTION_HOST }}"
            USER="${{ secrets.PRODUCTION_USER }}"
          else
            echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/deploy_key
            HOST="${{ secrets.STAGING_HOST }}"
            USER="${{ secrets.STAGING_USER }}"
          fi
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "$HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: üß™ Run smoke tests
        continue-on-error: true
        run: |
          ENV=${{ needs.setup.outputs.environment }}
          if [[ "$ENV" == "production" ]]; then
            HOST="${{ secrets.PRODUCTION_HOST }}"
            USER="${{ secrets.PRODUCTION_USER }}"
          else
            HOST="${{ secrets.STAGING_HOST }}"
            USER="${{ secrets.STAGING_USER }}"
          fi
          
          # SSH-based health checks (since apps not exposed yet)
          ssh -i ~/.ssh/deploy_key ${USER}@${HOST} << 'ENDSSH'
            echo "üîç Running smoke tests..."
            
            # Check Docker is running
            docker info >/dev/null 2>&1 && echo "‚úÖ Docker: OK" || echo "‚ùå Docker: FAIL"
            
            # Check networks
            docker network ls | grep -q cerniq && echo "‚úÖ Networks: OK" || echo "‚ùå Networks: FAIL"
            
            # Check PostgreSQL
            if docker ps | grep -q cerniq-postgres; then
              echo "‚úÖ PostgreSQL: Running"
            else
              echo "‚ö†Ô∏è  PostgreSQL: Not running (may be expected)"
            fi
            
            # Check PgBouncer  
            if docker ps | grep -q cerniq-pgbouncer; then
              echo "‚úÖ PgBouncer: Running"
            else
              echo "‚ö†Ô∏è  PgBouncer: Not running (may be expected)"
            fi
            
            echo "‚úÖ Smoke tests complete"
          ENDSSH

      - name: üìã Create GitHub Release
        if: needs.setup.outputs.environment == 'production' && startsWith(github.ref, 'refs/tags/')
        continue-on-error: true
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.setup.outputs.version }}
          generate_release_notes: true
          draft: false
          prerelease: false
